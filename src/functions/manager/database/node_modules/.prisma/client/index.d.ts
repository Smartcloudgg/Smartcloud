
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';


/**
 * Model Manager
 */

export type Manager = {
  id: string
  createdAt: Date
  ownerId: string
  ip: string
  url: string
  port: number
  type: ManagerLevels
  restartSchedule: string
  downtimeHistory: Prisma.JsonValue[]
  tasksCompleted: number
  parentID: string | null
}

/**
 * Model Host
 */

export type Host = {
  id: number
  createdAt: Date
  ownerId: string
  ip: string
  url: string
  port: number
  shardLimit: number
}

/**
 * Model Bot
 */

export type Bot = {
  id: number
  createdAt: Date
  updatedAt: Date
  ownerId: string
  hostsId: number
  priorityHostId: number | null
  discordToken: string | null
  twitterToken: string | null
  twitchAuthId: number
  recommendedShards: number
  currentShards: number
}

/**
 * Model Shard
 */

export type Shard = {
  id: string
  createdAt: Date
  lanchedAt: Date | null
  hostId: number
  botId: number
  status: ShardStatus
  shardID: number
}

/**
 * Model User
 */

export type User = {
  id: string
  firstName: string | null
  lastName: string | null
  email: string
  password: string
  isAdmin: boolean
}

/**
 * Model PAT
 */

export type PAT = {
  id: string
  userId: string
  createdAt: Date
  updatedAt: Date
  status: PATStatus
}

/**
 * Model transaction
 */

export type transaction = {
  id: string
  createdAt: Date
  completedAt: Date | null
  managerId: string
  patId: string | null
  suspicious: boolean
  fraudulent: boolean
  reversedAt: Date | null
}

/**
 * Model DiscordUser
 */

export type DiscordUser = {
  id: string
  username: string
  discrim: number
  userId: string | null
}

/**
 * Model guild
 */

export type guild = {
  id: number
  name: string
}

/**
 * Model UsersOnGuilds
 */

export type UsersOnGuilds = {
  userId: string
  guildId: number
  createdAt: Date
}

/**
 * Model AdminOnGuilds
 */

export type AdminOnGuilds = {
  userId: string
  guildId: number
  createdAt: Date
}

/**
 * Model Command
 */

export type Command = {
  id: string
  ownerId: string
  registeredAt: Date
  version: number
  usage: number
  cost: number
  type: DiscordExecutionType
  url: string
}

/**
 * Model Action
 */

export type Action = {
  id: number
  ownerId: string
  registeredAt: Date
  version: number
  usage: number
  cost: number
  type: DiscordExecutionType
  url: string
}

/**
 * Model TwitchUser
 */

export type TwitchUser = {
  id: number
  username: string
  accessToken: string
  refreshToken: string
  userId: string | null
}

/**
 * Model TwitchAuth
 */

export type TwitchAuth = {
  id: number
  clientID: string
  twitchSecret: string
  sessionSecret: string
}

/**
 * Model TwitterUser
 */

export type TwitterUser = {
  id: string
  username: string
  discrim: number
  userId: string | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const ManagerLevels: {
  ROOT: 'ROOT',
  AUTHORISED: 'AUTHORISED',
  SHADOW: 'SHADOW',
  VALIDATOR: 'VALIDATOR'
};

export type ManagerLevels = (typeof ManagerLevels)[keyof typeof ManagerLevels]


export const ShardStatus: {
  REGISTERED: 'REGISTERED',
  STARTING: 'STARTING',
  ONLINE: 'ONLINE',
  DISCONNECTED: 'DISCONNECTED',
  EXPIRED: 'EXPIRED'
};

export type ShardStatus = (typeof ShardStatus)[keyof typeof ShardStatus]


export const PATStatus: {
  ENABLED: 'ENABLED',
  DISABLED: 'DISABLED',
  REVOKED: 'REVOKED',
  EXPOSED: 'EXPOSED'
};

export type PATStatus = (typeof PATStatus)[keyof typeof PATStatus]


export const DiscordExecutionType: {
  JSON: 'JSON',
  JS: 'JS',
  PY: 'PY'
};

export type DiscordExecutionType = (typeof DiscordExecutionType)[keyof typeof DiscordExecutionType]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Managers
 * const managers = await prisma.manager.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Managers
   * const managers = await prisma.manager.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<T>;

  /**
   * Execute queries in a transaction
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   */
  $transaction: PromiseConstructor['all']

      /**
   * `prisma.manager`: Exposes CRUD operations for the **Manager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Managers
    * const managers = await prisma.manager.findMany()
    * ```
    */
  get manager(): Prisma.ManagerDelegate<GlobalReject>;

  /**
   * `prisma.host`: Exposes CRUD operations for the **Host** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hosts
    * const hosts = await prisma.host.findMany()
    * ```
    */
  get host(): Prisma.HostDelegate<GlobalReject>;

  /**
   * `prisma.bot`: Exposes CRUD operations for the **Bot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bots
    * const bots = await prisma.bot.findMany()
    * ```
    */
  get bot(): Prisma.BotDelegate<GlobalReject>;

  /**
   * `prisma.shard`: Exposes CRUD operations for the **Shard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shards
    * const shards = await prisma.shard.findMany()
    * ```
    */
  get shard(): Prisma.ShardDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.pAT`: Exposes CRUD operations for the **PAT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PATS
    * const pATS = await prisma.pAT.findMany()
    * ```
    */
  get pAT(): Prisma.PATDelegate<GlobalReject>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.transactionDelegate<GlobalReject>;

  /**
   * `prisma.discordUser`: Exposes CRUD operations for the **DiscordUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiscordUsers
    * const discordUsers = await prisma.discordUser.findMany()
    * ```
    */
  get discordUser(): Prisma.DiscordUserDelegate<GlobalReject>;

  /**
   * `prisma.guild`: Exposes CRUD operations for the **guild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guilds
    * const guilds = await prisma.guild.findMany()
    * ```
    */
  get guild(): Prisma.guildDelegate<GlobalReject>;

  /**
   * `prisma.usersOnGuilds`: Exposes CRUD operations for the **UsersOnGuilds** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsersOnGuilds
    * const usersOnGuilds = await prisma.usersOnGuilds.findMany()
    * ```
    */
  get usersOnGuilds(): Prisma.UsersOnGuildsDelegate<GlobalReject>;

  /**
   * `prisma.adminOnGuilds`: Exposes CRUD operations for the **AdminOnGuilds** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminOnGuilds
    * const adminOnGuilds = await prisma.adminOnGuilds.findMany()
    * ```
    */
  get adminOnGuilds(): Prisma.AdminOnGuildsDelegate<GlobalReject>;

  /**
   * `prisma.command`: Exposes CRUD operations for the **Command** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commands
    * const commands = await prisma.command.findMany()
    * ```
    */
  get command(): Prisma.CommandDelegate<GlobalReject>;

  /**
   * `prisma.action`: Exposes CRUD operations for the **Action** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actions
    * const actions = await prisma.action.findMany()
    * ```
    */
  get action(): Prisma.ActionDelegate<GlobalReject>;

  /**
   * `prisma.twitchUser`: Exposes CRUD operations for the **TwitchUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitchUsers
    * const twitchUsers = await prisma.twitchUser.findMany()
    * ```
    */
  get twitchUser(): Prisma.TwitchUserDelegate<GlobalReject>;

  /**
   * `prisma.twitchAuth`: Exposes CRUD operations for the **TwitchAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitchAuths
    * const twitchAuths = await prisma.twitchAuth.findMany()
    * ```
    */
  get twitchAuth(): Prisma.TwitchAuthDelegate<GlobalReject>;

  /**
   * `prisma.twitterUser`: Exposes CRUD operations for the **TwitterUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterUsers
    * const twitterUsers = await prisma.twitterUser.findMany()
    * ```
    */
  get twitterUser(): Prisma.TwitterUserDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.16.1
   * Query Engine version: 8b74ad57aaf2cc6c155f382a18a8e3ba95aceb03
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  /**
   * Allows creating `select` or `include` outside of the main statement
   * From https://github.com/prisma/prisma/issues/3372#issuecomment-762296484
   */

  type Cast<A1, A2> = A1 extends A2 ? A1 : A2;

  /**
   * `Exact` forces a type to comply by another type. It will need to be a subset
   * and must have exactly the same properties, no more, no less.
   */
  type Exact<A, W> = A & Cast<{
    [K in keyof A]: K extends keyof W ? A[K] : never
  }, W>;

  type Narrow<A, W = unknown> =
      A & {[K in keyof A]: NarrowAt<A, W, K>};

  type NarrowAt<A, W, K extends keyof A, AK = A[K], WK = Att<W, K>> =
      WK extends Widen<infer T> ? T :
      AK extends Narrowable ? AK & WK :
      Narrow<AK, WK>;

  type Att<O, K> = K extends keyof O ? O[K] : unknown;

  type Widen<A> = {[type]: A};

  type Narrowable =
  | string
  | number
  | bigint
  | boolean
  | [];

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<Narrow<S, V>, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Manager: 'Manager',
    Host: 'Host',
    Bot: 'Bot',
    Shard: 'Shard',
    User: 'User',
    PAT: 'PAT',
    transaction: 'transaction',
    DiscordUser: 'DiscordUser',
    guild: 'guild',
    UsersOnGuilds: 'UsersOnGuilds',
    AdminOnGuilds: 'AdminOnGuilds',
    Command: 'Command',
    Action: 'Action',
    TwitchUser: 'TwitchUser',
    TwitchAuth: 'TwitchAuth',
    TwitterUser: 'TwitterUser'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }


  /**
   * Model Manager
   */


  export type AggregateManager = {
    count: ManagerCountAggregateOutputType | null
    avg: ManagerAvgAggregateOutputType | null
    sum: ManagerSumAggregateOutputType | null
    min: ManagerMinAggregateOutputType | null
    max: ManagerMaxAggregateOutputType | null
  }

  export type ManagerAvgAggregateOutputType = {
    port: number
    tasksCompleted: number
  }

  export type ManagerSumAggregateOutputType = {
    port: number
    tasksCompleted: number
  }

  export type ManagerMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    ownerId: string | null
    ip: string | null
    url: string | null
    port: number
    type: ManagerLevels | null
    restartSchedule: string | null
    tasksCompleted: number
    parentID: string | null
  }

  export type ManagerMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    ownerId: string | null
    ip: string | null
    url: string | null
    port: number
    type: ManagerLevels | null
    restartSchedule: string | null
    tasksCompleted: number
    parentID: string | null
  }

  export type ManagerCountAggregateOutputType = {
    id: number | null
    createdAt: number | null
    ownerId: number | null
    ip: number | null
    url: number | null
    port: number
    type: number | null
    restartSchedule: number | null
    downtimeHistory: number | null
    tasksCompleted: number
    parentID: number | null
    _all: number
  }


  export type ManagerAvgAggregateInputType = {
    port?: true
    tasksCompleted?: true
  }

  export type ManagerSumAggregateInputType = {
    port?: true
    tasksCompleted?: true
  }

  export type ManagerMinAggregateInputType = {
    id?: true
    createdAt?: true
    ownerId?: true
    ip?: true
    url?: true
    port?: true
    type?: true
    restartSchedule?: true
    tasksCompleted?: true
    parentID?: true
  }

  export type ManagerMaxAggregateInputType = {
    id?: true
    createdAt?: true
    ownerId?: true
    ip?: true
    url?: true
    port?: true
    type?: true
    restartSchedule?: true
    tasksCompleted?: true
    parentID?: true
  }

  export type ManagerCountAggregateInputType = {
    id?: true
    createdAt?: true
    ownerId?: true
    ip?: true
    url?: true
    port?: true
    type?: true
    restartSchedule?: true
    downtimeHistory?: true
    tasksCompleted?: true
    parentID?: true
    _all?: true
  }

  export type ManagerAggregateArgs = {
    /**
     * Filter which Manager to aggregate.
    **/
    where?: ManagerWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Managers to fetch.
    **/
    orderBy?: Enumerable<ManagerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Managers
    **/
    count?: true | ManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ManagerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ManagerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ManagerMaxAggregateInputType
  }

  export type GetManagerAggregateType<T extends ManagerAggregateArgs> = {
    [P in keyof T & keyof AggregateManager]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManager[P]>
      : GetScalarType<T[P], AggregateManager[P]>
  }



  export type ManagerSelect = {
    id?: boolean
    createdAt?: boolean
    ownerId?: boolean
    ip?: boolean
    url?: boolean
    port?: boolean
    type?: boolean
    restartSchedule?: boolean
    downtimeHistory?: boolean
    tasksCompleted?: boolean
    parentID?: boolean
    owner?: boolean | UserArgs
    parentManager?: boolean | ManagerArgs
    childManagers?: boolean | ManagerFindManyArgs
    transaction?: boolean | transactionFindManyArgs
    Manager_B?: boolean | ManagerFindManyArgs
    Manager_A?: boolean | ManagerFindManyArgs
  }

  export type ManagerInclude = {
    owner?: boolean | UserArgs
    parentManager?: boolean | ManagerArgs
    childManagers?: boolean | ManagerFindManyArgs
    transaction?: boolean | transactionFindManyArgs
    Manager_B?: boolean | ManagerFindManyArgs
    Manager_A?: boolean | ManagerFindManyArgs
  }

  export type ManagerGetPayload<
    S extends boolean | null | undefined | ManagerArgs,
    U = keyof S
      > = S extends true
        ? Manager
    : S extends undefined
    ? never
    : S extends ManagerArgs | ManagerFindManyArgs
    ?'include' extends U
    ? Manager  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'owner'
        ? UserGetPayload<S['include'][P]> :
        P extends 'parentManager'
        ? ManagerGetPayload<S['include'][P]> | null :
        P extends 'childManagers'
        ? Array < ManagerGetPayload<S['include'][P]>>  :
        P extends 'transaction'
        ? Array < transactionGetPayload<S['include'][P]>>  :
        P extends 'Manager_B'
        ? Array < ManagerGetPayload<S['include'][P]>>  :
        P extends 'Manager_A'
        ? Array < ManagerGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Manager ?Manager [P]
  : 
          P extends 'owner'
        ? UserGetPayload<S['select'][P]> :
        P extends 'parentManager'
        ? ManagerGetPayload<S['select'][P]> | null :
        P extends 'childManagers'
        ? Array < ManagerGetPayload<S['select'][P]>>  :
        P extends 'transaction'
        ? Array < transactionGetPayload<S['select'][P]>>  :
        P extends 'Manager_B'
        ? Array < ManagerGetPayload<S['select'][P]>>  :
        P extends 'Manager_A'
        ? Array < ManagerGetPayload<S['select'][P]>>  : never
  } 
    : Manager
  : Manager


  type ManagerCountArgs = Merge<
    Omit<ManagerFindManyArgs, 'select' | 'include'> & {
      select?: ManagerCountAggregateInputType | true
    }
  >

  export interface ManagerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Manager that matches the filter.
     * @param {ManagerFindUniqueArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ManagerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ManagerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Manager'> extends True ? CheckSelect<T, Prisma__ManagerClient<Manager>, Prisma__ManagerClient<ManagerGetPayload<T>>> : CheckSelect<T, Prisma__ManagerClient<Manager | null >, Prisma__ManagerClient<ManagerGetPayload<T> | null >>

    /**
     * Find the first Manager that matches the filter.
     * @param {ManagerFindFirstArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ManagerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ManagerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Manager'> extends True ? CheckSelect<T, Prisma__ManagerClient<Manager>, Prisma__ManagerClient<ManagerGetPayload<T>>> : CheckSelect<T, Prisma__ManagerClient<Manager | null >, Prisma__ManagerClient<ManagerGetPayload<T> | null >>

    /**
     * Find zero or more Managers that matches the filter.
     * @param {ManagerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Managers
     * const managers = await prisma.manager.findMany()
     * 
     * // Get first 10 Managers
     * const managers = await prisma.manager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const managerWithIdOnly = await prisma.manager.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ManagerFindManyArgs>(
      args?: SelectSubset<T, ManagerFindManyArgs>
    ): CheckSelect<T, Promise<Array<Manager>>, Promise<Array<ManagerGetPayload<T>>>>

    /**
     * Create a Manager.
     * @param {ManagerCreateArgs} args - Arguments to create a Manager.
     * @example
     * // Create one Manager
     * const Manager = await prisma.manager.create({
     *   data: {
     *     // ... data to create a Manager
     *   }
     * })
     * 
    **/
    create<T extends ManagerCreateArgs>(
      args: SelectSubset<T, ManagerCreateArgs>
    ): CheckSelect<T, Prisma__ManagerClient<Manager>, Prisma__ManagerClient<ManagerGetPayload<T>>>

    /**
     * Delete a Manager.
     * @param {ManagerDeleteArgs} args - Arguments to delete one Manager.
     * @example
     * // Delete one Manager
     * const Manager = await prisma.manager.delete({
     *   where: {
     *     // ... filter to delete one Manager
     *   }
     * })
     * 
    **/
    delete<T extends ManagerDeleteArgs>(
      args: SelectSubset<T, ManagerDeleteArgs>
    ): CheckSelect<T, Prisma__ManagerClient<Manager>, Prisma__ManagerClient<ManagerGetPayload<T>>>

    /**
     * Update one Manager.
     * @param {ManagerUpdateArgs} args - Arguments to update one Manager.
     * @example
     * // Update one Manager
     * const manager = await prisma.manager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ManagerUpdateArgs>(
      args: SelectSubset<T, ManagerUpdateArgs>
    ): CheckSelect<T, Prisma__ManagerClient<Manager>, Prisma__ManagerClient<ManagerGetPayload<T>>>

    /**
     * Delete zero or more Managers.
     * @param {ManagerDeleteManyArgs} args - Arguments to filter Managers to delete.
     * @example
     * // Delete a few Managers
     * const { count } = await prisma.manager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ManagerDeleteManyArgs>(
      args?: SelectSubset<T, ManagerDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Managers.
     * @param {ManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Managers
     * const manager = await prisma.manager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ManagerUpdateManyArgs>(
      args: SelectSubset<T, ManagerUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Manager.
     * @param {ManagerUpsertArgs} args - Arguments to update or create a Manager.
     * @example
     * // Update or create a Manager
     * const manager = await prisma.manager.upsert({
     *   create: {
     *     // ... data to create a Manager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manager we want to update
     *   }
     * })
    **/
    upsert<T extends ManagerUpsertArgs>(
      args: SelectSubset<T, ManagerUpsertArgs>
    ): CheckSelect<T, Prisma__ManagerClient<Manager>, Prisma__ManagerClient<ManagerGetPayload<T>>>

    /**
     * Count the number of Managers.
     * @param {ManagerCountArgs} args - Arguments to filter Managers to count.
     * @example
     * // Count the number of Managers
     * const count = await prisma.manager.count({
     *   where: {
     *     // ... the filter for the Managers we want to count
     *   }
     * })
    **/
    count<T extends ManagerCountArgs>(
      args?: Subset<T, ManagerCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manager.
     * @param {ManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManagerAggregateArgs>(args: Subset<T, ManagerAggregateArgs>): Promise<GetManagerAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Manager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ManagerClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    owner<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    parentManager<T extends ManagerArgs = {}>(args?: Subset<T, ManagerArgs>): CheckSelect<T, Prisma__ManagerClient<Manager | null >, Prisma__ManagerClient<ManagerGetPayload<T> | null >>;

    childManagers<T extends ManagerFindManyArgs = {}>(args?: Subset<T, ManagerFindManyArgs>): CheckSelect<T, Promise<Array<Manager>>, Promise<Array<ManagerGetPayload<T>>>>;

    transaction<T extends transactionFindManyArgs = {}>(args?: Subset<T, transactionFindManyArgs>): CheckSelect<T, Promise<Array<transaction>>, Promise<Array<transactionGetPayload<T>>>>;

    Manager_B<T extends ManagerFindManyArgs = {}>(args?: Subset<T, ManagerFindManyArgs>): CheckSelect<T, Promise<Array<Manager>>, Promise<Array<ManagerGetPayload<T>>>>;

    Manager_A<T extends ManagerFindManyArgs = {}>(args?: Subset<T, ManagerFindManyArgs>): CheckSelect<T, Promise<Array<Manager>>, Promise<Array<ManagerGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Manager findUnique
   */
  export type ManagerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Manager
    **/
    select?: ManagerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ManagerInclude | null
    /**
     * Throw an Error if a Manager can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Manager to fetch.
    **/
    where: ManagerWhereUniqueInput
  }


  /**
   * Manager findFirst
   */
  export type ManagerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Manager
    **/
    select?: ManagerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ManagerInclude | null
    /**
     * Throw an Error if a Manager can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Manager to fetch.
    **/
    where?: ManagerWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Managers to fetch.
    **/
    orderBy?: Enumerable<ManagerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
    **/
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Managers.
    **/
    distinct?: Enumerable<ManagerScalarFieldEnum>
  }


  /**
   * Manager findMany
   */
  export type ManagerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Manager
    **/
    select?: ManagerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ManagerInclude | null
    /**
     * Filter, which Managers to fetch.
    **/
    where?: ManagerWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Managers to fetch.
    **/
    orderBy?: Enumerable<ManagerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Managers.
    **/
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
    **/
    skip?: number
    distinct?: Enumerable<ManagerScalarFieldEnum>
  }


  /**
   * Manager create
   */
  export type ManagerCreateArgs = {
    /**
     * Select specific fields to fetch from the Manager
    **/
    select?: ManagerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ManagerInclude | null
    /**
     * The data needed to create a Manager.
    **/
    data: XOR<ManagerUncheckedCreateInput, ManagerCreateInput>
  }


  /**
   * Manager update
   */
  export type ManagerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Manager
    **/
    select?: ManagerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ManagerInclude | null
    /**
     * The data needed to update a Manager.
    **/
    data: XOR<ManagerUncheckedUpdateInput, ManagerUpdateInput>
    /**
     * Choose, which Manager to update.
    **/
    where: ManagerWhereUniqueInput
  }


  /**
   * Manager updateMany
   */
  export type ManagerUpdateManyArgs = {
    data: XOR<ManagerUncheckedUpdateManyInput, ManagerUpdateManyMutationInput>
    where?: ManagerWhereInput
  }


  /**
   * Manager upsert
   */
  export type ManagerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Manager
    **/
    select?: ManagerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ManagerInclude | null
    /**
     * The filter to search for the Manager to update in case it exists.
    **/
    where: ManagerWhereUniqueInput
    /**
     * In case the Manager found by the `where` argument doesn't exist, create a new Manager with this data.
    **/
    create: XOR<ManagerUncheckedCreateInput, ManagerCreateInput>
    /**
     * In case the Manager was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ManagerUncheckedUpdateInput, ManagerUpdateInput>
  }


  /**
   * Manager delete
   */
  export type ManagerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Manager
    **/
    select?: ManagerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ManagerInclude | null
    /**
     * Filter which Manager to delete.
    **/
    where: ManagerWhereUniqueInput
  }


  /**
   * Manager deleteMany
   */
  export type ManagerDeleteManyArgs = {
    where?: ManagerWhereInput
  }


  /**
   * Manager without action
   */
  export type ManagerArgs = {
    /**
     * Select specific fields to fetch from the Manager
    **/
    select?: ManagerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ManagerInclude | null
  }



  /**
   * Model Host
   */


  export type AggregateHost = {
    count: HostCountAggregateOutputType | null
    avg: HostAvgAggregateOutputType | null
    sum: HostSumAggregateOutputType | null
    min: HostMinAggregateOutputType | null
    max: HostMaxAggregateOutputType | null
  }

  export type HostAvgAggregateOutputType = {
    id: number
    port: number
    shardLimit: number
  }

  export type HostSumAggregateOutputType = {
    id: number
    port: number
    shardLimit: number
  }

  export type HostMinAggregateOutputType = {
    id: number
    createdAt: Date | null
    ownerId: string | null
    ip: string | null
    url: string | null
    port: number
    shardLimit: number
  }

  export type HostMaxAggregateOutputType = {
    id: number
    createdAt: Date | null
    ownerId: string | null
    ip: string | null
    url: string | null
    port: number
    shardLimit: number
  }

  export type HostCountAggregateOutputType = {
    id: number
    createdAt: number | null
    ownerId: number | null
    ip: number | null
    url: number | null
    port: number
    shardLimit: number
    _all: number
  }


  export type HostAvgAggregateInputType = {
    id?: true
    port?: true
    shardLimit?: true
  }

  export type HostSumAggregateInputType = {
    id?: true
    port?: true
    shardLimit?: true
  }

  export type HostMinAggregateInputType = {
    id?: true
    createdAt?: true
    ownerId?: true
    ip?: true
    url?: true
    port?: true
    shardLimit?: true
  }

  export type HostMaxAggregateInputType = {
    id?: true
    createdAt?: true
    ownerId?: true
    ip?: true
    url?: true
    port?: true
    shardLimit?: true
  }

  export type HostCountAggregateInputType = {
    id?: true
    createdAt?: true
    ownerId?: true
    ip?: true
    url?: true
    port?: true
    shardLimit?: true
    _all?: true
  }

  export type HostAggregateArgs = {
    /**
     * Filter which Host to aggregate.
    **/
    where?: HostWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Hosts to fetch.
    **/
    orderBy?: Enumerable<HostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: HostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hosts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hosts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hosts
    **/
    count?: true | HostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: HostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: HostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: HostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: HostMaxAggregateInputType
  }

  export type GetHostAggregateType<T extends HostAggregateArgs> = {
    [P in keyof T & keyof AggregateHost]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHost[P]>
      : GetScalarType<T[P], AggregateHost[P]>
  }



  export type HostSelect = {
    id?: boolean
    createdAt?: boolean
    ownerId?: boolean
    ip?: boolean
    url?: boolean
    port?: boolean
    shardLimit?: boolean
    owner?: boolean | UserArgs
    bots?: boolean | BotFindManyArgs
    priorityBot?: boolean | BotFindManyArgs
    shards?: boolean | ShardFindManyArgs
  }

  export type HostInclude = {
    owner?: boolean | UserArgs
    bots?: boolean | BotFindManyArgs
    priorityBot?: boolean | BotFindManyArgs
    shards?: boolean | ShardFindManyArgs
  }

  export type HostGetPayload<
    S extends boolean | null | undefined | HostArgs,
    U = keyof S
      > = S extends true
        ? Host
    : S extends undefined
    ? never
    : S extends HostArgs | HostFindManyArgs
    ?'include' extends U
    ? Host  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'owner'
        ? UserGetPayload<S['include'][P]> :
        P extends 'bots'
        ? Array < BotGetPayload<S['include'][P]>>  :
        P extends 'priorityBot'
        ? Array < BotGetPayload<S['include'][P]>>  :
        P extends 'shards'
        ? Array < ShardGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Host ?Host [P]
  : 
          P extends 'owner'
        ? UserGetPayload<S['select'][P]> :
        P extends 'bots'
        ? Array < BotGetPayload<S['select'][P]>>  :
        P extends 'priorityBot'
        ? Array < BotGetPayload<S['select'][P]>>  :
        P extends 'shards'
        ? Array < ShardGetPayload<S['select'][P]>>  : never
  } 
    : Host
  : Host


  type HostCountArgs = Merge<
    Omit<HostFindManyArgs, 'select' | 'include'> & {
      select?: HostCountAggregateInputType | true
    }
  >

  export interface HostDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Host that matches the filter.
     * @param {HostFindUniqueArgs} args - Arguments to find a Host
     * @example
     * // Get one Host
     * const host = await prisma.host.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Host'> extends True ? CheckSelect<T, Prisma__HostClient<Host>, Prisma__HostClient<HostGetPayload<T>>> : CheckSelect<T, Prisma__HostClient<Host | null >, Prisma__HostClient<HostGetPayload<T> | null >>

    /**
     * Find the first Host that matches the filter.
     * @param {HostFindFirstArgs} args - Arguments to find a Host
     * @example
     * // Get one Host
     * const host = await prisma.host.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Host'> extends True ? CheckSelect<T, Prisma__HostClient<Host>, Prisma__HostClient<HostGetPayload<T>>> : CheckSelect<T, Prisma__HostClient<Host | null >, Prisma__HostClient<HostGetPayload<T> | null >>

    /**
     * Find zero or more Hosts that matches the filter.
     * @param {HostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hosts
     * const hosts = await prisma.host.findMany()
     * 
     * // Get first 10 Hosts
     * const hosts = await prisma.host.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hostWithIdOnly = await prisma.host.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HostFindManyArgs>(
      args?: SelectSubset<T, HostFindManyArgs>
    ): CheckSelect<T, Promise<Array<Host>>, Promise<Array<HostGetPayload<T>>>>

    /**
     * Create a Host.
     * @param {HostCreateArgs} args - Arguments to create a Host.
     * @example
     * // Create one Host
     * const Host = await prisma.host.create({
     *   data: {
     *     // ... data to create a Host
     *   }
     * })
     * 
    **/
    create<T extends HostCreateArgs>(
      args: SelectSubset<T, HostCreateArgs>
    ): CheckSelect<T, Prisma__HostClient<Host>, Prisma__HostClient<HostGetPayload<T>>>

    /**
     * Delete a Host.
     * @param {HostDeleteArgs} args - Arguments to delete one Host.
     * @example
     * // Delete one Host
     * const Host = await prisma.host.delete({
     *   where: {
     *     // ... filter to delete one Host
     *   }
     * })
     * 
    **/
    delete<T extends HostDeleteArgs>(
      args: SelectSubset<T, HostDeleteArgs>
    ): CheckSelect<T, Prisma__HostClient<Host>, Prisma__HostClient<HostGetPayload<T>>>

    /**
     * Update one Host.
     * @param {HostUpdateArgs} args - Arguments to update one Host.
     * @example
     * // Update one Host
     * const host = await prisma.host.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HostUpdateArgs>(
      args: SelectSubset<T, HostUpdateArgs>
    ): CheckSelect<T, Prisma__HostClient<Host>, Prisma__HostClient<HostGetPayload<T>>>

    /**
     * Delete zero or more Hosts.
     * @param {HostDeleteManyArgs} args - Arguments to filter Hosts to delete.
     * @example
     * // Delete a few Hosts
     * const { count } = await prisma.host.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HostDeleteManyArgs>(
      args?: SelectSubset<T, HostDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Hosts.
     * @param {HostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hosts
     * const host = await prisma.host.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HostUpdateManyArgs>(
      args: SelectSubset<T, HostUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Host.
     * @param {HostUpsertArgs} args - Arguments to update or create a Host.
     * @example
     * // Update or create a Host
     * const host = await prisma.host.upsert({
     *   create: {
     *     // ... data to create a Host
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Host we want to update
     *   }
     * })
    **/
    upsert<T extends HostUpsertArgs>(
      args: SelectSubset<T, HostUpsertArgs>
    ): CheckSelect<T, Prisma__HostClient<Host>, Prisma__HostClient<HostGetPayload<T>>>

    /**
     * Count the number of Hosts.
     * @param {HostCountArgs} args - Arguments to filter Hosts to count.
     * @example
     * // Count the number of Hosts
     * const count = await prisma.host.count({
     *   where: {
     *     // ... the filter for the Hosts we want to count
     *   }
     * })
    **/
    count<T extends HostCountArgs>(
      args?: Subset<T, HostCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Host.
     * @param {HostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HostAggregateArgs>(args: Subset<T, HostAggregateArgs>): Promise<GetHostAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Host.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HostClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    owner<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    bots<T extends BotFindManyArgs = {}>(args?: Subset<T, BotFindManyArgs>): CheckSelect<T, Promise<Array<Bot>>, Promise<Array<BotGetPayload<T>>>>;

    priorityBot<T extends BotFindManyArgs = {}>(args?: Subset<T, BotFindManyArgs>): CheckSelect<T, Promise<Array<Bot>>, Promise<Array<BotGetPayload<T>>>>;

    shards<T extends ShardFindManyArgs = {}>(args?: Subset<T, ShardFindManyArgs>): CheckSelect<T, Promise<Array<Shard>>, Promise<Array<ShardGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Host findUnique
   */
  export type HostFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Host
    **/
    select?: HostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: HostInclude | null
    /**
     * Throw an Error if a Host can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Host to fetch.
    **/
    where: HostWhereUniqueInput
  }


  /**
   * Host findFirst
   */
  export type HostFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Host
    **/
    select?: HostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: HostInclude | null
    /**
     * Throw an Error if a Host can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Host to fetch.
    **/
    where?: HostWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Hosts to fetch.
    **/
    orderBy?: Enumerable<HostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hosts.
    **/
    cursor?: HostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hosts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hosts.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Hosts.
    **/
    distinct?: Enumerable<HostScalarFieldEnum>
  }


  /**
   * Host findMany
   */
  export type HostFindManyArgs = {
    /**
     * Select specific fields to fetch from the Host
    **/
    select?: HostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: HostInclude | null
    /**
     * Filter, which Hosts to fetch.
    **/
    where?: HostWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Hosts to fetch.
    **/
    orderBy?: Enumerable<HostOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hosts.
    **/
    cursor?: HostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hosts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hosts.
    **/
    skip?: number
    distinct?: Enumerable<HostScalarFieldEnum>
  }


  /**
   * Host create
   */
  export type HostCreateArgs = {
    /**
     * Select specific fields to fetch from the Host
    **/
    select?: HostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: HostInclude | null
    /**
     * The data needed to create a Host.
    **/
    data: XOR<HostUncheckedCreateInput, HostCreateInput>
  }


  /**
   * Host update
   */
  export type HostUpdateArgs = {
    /**
     * Select specific fields to fetch from the Host
    **/
    select?: HostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: HostInclude | null
    /**
     * The data needed to update a Host.
    **/
    data: XOR<HostUncheckedUpdateInput, HostUpdateInput>
    /**
     * Choose, which Host to update.
    **/
    where: HostWhereUniqueInput
  }


  /**
   * Host updateMany
   */
  export type HostUpdateManyArgs = {
    data: XOR<HostUncheckedUpdateManyInput, HostUpdateManyMutationInput>
    where?: HostWhereInput
  }


  /**
   * Host upsert
   */
  export type HostUpsertArgs = {
    /**
     * Select specific fields to fetch from the Host
    **/
    select?: HostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: HostInclude | null
    /**
     * The filter to search for the Host to update in case it exists.
    **/
    where: HostWhereUniqueInput
    /**
     * In case the Host found by the `where` argument doesn't exist, create a new Host with this data.
    **/
    create: XOR<HostUncheckedCreateInput, HostCreateInput>
    /**
     * In case the Host was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<HostUncheckedUpdateInput, HostUpdateInput>
  }


  /**
   * Host delete
   */
  export type HostDeleteArgs = {
    /**
     * Select specific fields to fetch from the Host
    **/
    select?: HostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: HostInclude | null
    /**
     * Filter which Host to delete.
    **/
    where: HostWhereUniqueInput
  }


  /**
   * Host deleteMany
   */
  export type HostDeleteManyArgs = {
    where?: HostWhereInput
  }


  /**
   * Host without action
   */
  export type HostArgs = {
    /**
     * Select specific fields to fetch from the Host
    **/
    select?: HostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: HostInclude | null
  }



  /**
   * Model Bot
   */


  export type AggregateBot = {
    count: BotCountAggregateOutputType | null
    avg: BotAvgAggregateOutputType | null
    sum: BotSumAggregateOutputType | null
    min: BotMinAggregateOutputType | null
    max: BotMaxAggregateOutputType | null
  }

  export type BotAvgAggregateOutputType = {
    id: number
    hostsId: number
    priorityHostId: number | null
    twitchAuthId: number
    recommendedShards: number
    currentShards: number
  }

  export type BotSumAggregateOutputType = {
    id: number
    hostsId: number
    priorityHostId: number | null
    twitchAuthId: number
    recommendedShards: number
    currentShards: number
  }

  export type BotMinAggregateOutputType = {
    id: number
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
    hostsId: number
    priorityHostId: number | null
    discordToken: string | null
    twitterToken: string | null
    twitchAuthId: number
    recommendedShards: number
    currentShards: number
  }

  export type BotMaxAggregateOutputType = {
    id: number
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
    hostsId: number
    priorityHostId: number | null
    discordToken: string | null
    twitterToken: string | null
    twitchAuthId: number
    recommendedShards: number
    currentShards: number
  }

  export type BotCountAggregateOutputType = {
    id: number
    createdAt: number | null
    updatedAt: number | null
    ownerId: number | null
    hostsId: number
    priorityHostId: number | null
    discordToken: number | null
    twitterToken: number | null
    twitchAuthId: number
    recommendedShards: number
    currentShards: number
    _all: number
  }


  export type BotAvgAggregateInputType = {
    id?: true
    hostsId?: true
    priorityHostId?: true
    twitchAuthId?: true
    recommendedShards?: true
    currentShards?: true
  }

  export type BotSumAggregateInputType = {
    id?: true
    hostsId?: true
    priorityHostId?: true
    twitchAuthId?: true
    recommendedShards?: true
    currentShards?: true
  }

  export type BotMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    hostsId?: true
    priorityHostId?: true
    discordToken?: true
    twitterToken?: true
    twitchAuthId?: true
    recommendedShards?: true
    currentShards?: true
  }

  export type BotMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    hostsId?: true
    priorityHostId?: true
    discordToken?: true
    twitterToken?: true
    twitchAuthId?: true
    recommendedShards?: true
    currentShards?: true
  }

  export type BotCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    hostsId?: true
    priorityHostId?: true
    discordToken?: true
    twitterToken?: true
    twitchAuthId?: true
    recommendedShards?: true
    currentShards?: true
    _all?: true
  }

  export type BotAggregateArgs = {
    /**
     * Filter which Bot to aggregate.
    **/
    where?: BotWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Bots to fetch.
    **/
    orderBy?: Enumerable<BotOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bots from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bots
    **/
    count?: true | BotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: BotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: BotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: BotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: BotMaxAggregateInputType
  }

  export type GetBotAggregateType<T extends BotAggregateArgs> = {
    [P in keyof T & keyof AggregateBot]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBot[P]>
      : GetScalarType<T[P], AggregateBot[P]>
  }



  export type BotSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    hostsId?: boolean
    priorityHostId?: boolean
    discordToken?: boolean
    twitterToken?: boolean
    twitchAuthId?: boolean
    recommendedShards?: boolean
    currentShards?: boolean
    hosts?: boolean | HostArgs
    owner?: boolean | UserArgs
    priorityHost?: boolean | HostArgs
    twitchAuth?: boolean | TwitchAuthArgs
    shards?: boolean | ShardFindManyArgs
  }

  export type BotInclude = {
    hosts?: boolean | HostArgs
    owner?: boolean | UserArgs
    priorityHost?: boolean | HostArgs
    twitchAuth?: boolean | TwitchAuthArgs
    shards?: boolean | ShardFindManyArgs
  }

  export type BotGetPayload<
    S extends boolean | null | undefined | BotArgs,
    U = keyof S
      > = S extends true
        ? Bot
    : S extends undefined
    ? never
    : S extends BotArgs | BotFindManyArgs
    ?'include' extends U
    ? Bot  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'hosts'
        ? HostGetPayload<S['include'][P]> :
        P extends 'owner'
        ? UserGetPayload<S['include'][P]> :
        P extends 'priorityHost'
        ? HostGetPayload<S['include'][P]> | null :
        P extends 'twitchAuth'
        ? TwitchAuthGetPayload<S['include'][P]> :
        P extends 'shards'
        ? Array < ShardGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Bot ?Bot [P]
  : 
          P extends 'hosts'
        ? HostGetPayload<S['select'][P]> :
        P extends 'owner'
        ? UserGetPayload<S['select'][P]> :
        P extends 'priorityHost'
        ? HostGetPayload<S['select'][P]> | null :
        P extends 'twitchAuth'
        ? TwitchAuthGetPayload<S['select'][P]> :
        P extends 'shards'
        ? Array < ShardGetPayload<S['select'][P]>>  : never
  } 
    : Bot
  : Bot


  type BotCountArgs = Merge<
    Omit<BotFindManyArgs, 'select' | 'include'> & {
      select?: BotCountAggregateInputType | true
    }
  >

  export interface BotDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Bot that matches the filter.
     * @param {BotFindUniqueArgs} args - Arguments to find a Bot
     * @example
     * // Get one Bot
     * const bot = await prisma.bot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BotFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BotFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Bot'> extends True ? CheckSelect<T, Prisma__BotClient<Bot>, Prisma__BotClient<BotGetPayload<T>>> : CheckSelect<T, Prisma__BotClient<Bot | null >, Prisma__BotClient<BotGetPayload<T> | null >>

    /**
     * Find the first Bot that matches the filter.
     * @param {BotFindFirstArgs} args - Arguments to find a Bot
     * @example
     * // Get one Bot
     * const bot = await prisma.bot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BotFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BotFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Bot'> extends True ? CheckSelect<T, Prisma__BotClient<Bot>, Prisma__BotClient<BotGetPayload<T>>> : CheckSelect<T, Prisma__BotClient<Bot | null >, Prisma__BotClient<BotGetPayload<T> | null >>

    /**
     * Find zero or more Bots that matches the filter.
     * @param {BotFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bots
     * const bots = await prisma.bot.findMany()
     * 
     * // Get first 10 Bots
     * const bots = await prisma.bot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const botWithIdOnly = await prisma.bot.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BotFindManyArgs>(
      args?: SelectSubset<T, BotFindManyArgs>
    ): CheckSelect<T, Promise<Array<Bot>>, Promise<Array<BotGetPayload<T>>>>

    /**
     * Create a Bot.
     * @param {BotCreateArgs} args - Arguments to create a Bot.
     * @example
     * // Create one Bot
     * const Bot = await prisma.bot.create({
     *   data: {
     *     // ... data to create a Bot
     *   }
     * })
     * 
    **/
    create<T extends BotCreateArgs>(
      args: SelectSubset<T, BotCreateArgs>
    ): CheckSelect<T, Prisma__BotClient<Bot>, Prisma__BotClient<BotGetPayload<T>>>

    /**
     * Delete a Bot.
     * @param {BotDeleteArgs} args - Arguments to delete one Bot.
     * @example
     * // Delete one Bot
     * const Bot = await prisma.bot.delete({
     *   where: {
     *     // ... filter to delete one Bot
     *   }
     * })
     * 
    **/
    delete<T extends BotDeleteArgs>(
      args: SelectSubset<T, BotDeleteArgs>
    ): CheckSelect<T, Prisma__BotClient<Bot>, Prisma__BotClient<BotGetPayload<T>>>

    /**
     * Update one Bot.
     * @param {BotUpdateArgs} args - Arguments to update one Bot.
     * @example
     * // Update one Bot
     * const bot = await prisma.bot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BotUpdateArgs>(
      args: SelectSubset<T, BotUpdateArgs>
    ): CheckSelect<T, Prisma__BotClient<Bot>, Prisma__BotClient<BotGetPayload<T>>>

    /**
     * Delete zero or more Bots.
     * @param {BotDeleteManyArgs} args - Arguments to filter Bots to delete.
     * @example
     * // Delete a few Bots
     * const { count } = await prisma.bot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BotDeleteManyArgs>(
      args?: SelectSubset<T, BotDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Bots.
     * @param {BotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bots
     * const bot = await prisma.bot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BotUpdateManyArgs>(
      args: SelectSubset<T, BotUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Bot.
     * @param {BotUpsertArgs} args - Arguments to update or create a Bot.
     * @example
     * // Update or create a Bot
     * const bot = await prisma.bot.upsert({
     *   create: {
     *     // ... data to create a Bot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bot we want to update
     *   }
     * })
    **/
    upsert<T extends BotUpsertArgs>(
      args: SelectSubset<T, BotUpsertArgs>
    ): CheckSelect<T, Prisma__BotClient<Bot>, Prisma__BotClient<BotGetPayload<T>>>

    /**
     * Count the number of Bots.
     * @param {BotCountArgs} args - Arguments to filter Bots to count.
     * @example
     * // Count the number of Bots
     * const count = await prisma.bot.count({
     *   where: {
     *     // ... the filter for the Bots we want to count
     *   }
     * })
    **/
    count<T extends BotCountArgs>(
      args?: Subset<T, BotCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bot.
     * @param {BotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotAggregateArgs>(args: Subset<T, BotAggregateArgs>): Promise<GetBotAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Bot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BotClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    hosts<T extends HostArgs = {}>(args?: Subset<T, HostArgs>): CheckSelect<T, Prisma__HostClient<Host | null >, Prisma__HostClient<HostGetPayload<T> | null >>;

    owner<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    priorityHost<T extends HostArgs = {}>(args?: Subset<T, HostArgs>): CheckSelect<T, Prisma__HostClient<Host | null >, Prisma__HostClient<HostGetPayload<T> | null >>;

    twitchAuth<T extends TwitchAuthArgs = {}>(args?: Subset<T, TwitchAuthArgs>): CheckSelect<T, Prisma__TwitchAuthClient<TwitchAuth | null >, Prisma__TwitchAuthClient<TwitchAuthGetPayload<T> | null >>;

    shards<T extends ShardFindManyArgs = {}>(args?: Subset<T, ShardFindManyArgs>): CheckSelect<T, Promise<Array<Shard>>, Promise<Array<ShardGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Bot findUnique
   */
  export type BotFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Bot
    **/
    select?: BotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BotInclude | null
    /**
     * Throw an Error if a Bot can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Bot to fetch.
    **/
    where: BotWhereUniqueInput
  }


  /**
   * Bot findFirst
   */
  export type BotFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Bot
    **/
    select?: BotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BotInclude | null
    /**
     * Throw an Error if a Bot can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Bot to fetch.
    **/
    where?: BotWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Bots to fetch.
    **/
    orderBy?: Enumerable<BotOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bots.
    **/
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bots from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Bots.
    **/
    distinct?: Enumerable<BotScalarFieldEnum>
  }


  /**
   * Bot findMany
   */
  export type BotFindManyArgs = {
    /**
     * Select specific fields to fetch from the Bot
    **/
    select?: BotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BotInclude | null
    /**
     * Filter, which Bots to fetch.
    **/
    where?: BotWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Bots to fetch.
    **/
    orderBy?: Enumerable<BotOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bots.
    **/
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bots from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
    **/
    skip?: number
    distinct?: Enumerable<BotScalarFieldEnum>
  }


  /**
   * Bot create
   */
  export type BotCreateArgs = {
    /**
     * Select specific fields to fetch from the Bot
    **/
    select?: BotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BotInclude | null
    /**
     * The data needed to create a Bot.
    **/
    data: XOR<BotUncheckedCreateInput, BotCreateInput>
  }


  /**
   * Bot update
   */
  export type BotUpdateArgs = {
    /**
     * Select specific fields to fetch from the Bot
    **/
    select?: BotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BotInclude | null
    /**
     * The data needed to update a Bot.
    **/
    data: XOR<BotUncheckedUpdateInput, BotUpdateInput>
    /**
     * Choose, which Bot to update.
    **/
    where: BotWhereUniqueInput
  }


  /**
   * Bot updateMany
   */
  export type BotUpdateManyArgs = {
    data: XOR<BotUncheckedUpdateManyInput, BotUpdateManyMutationInput>
    where?: BotWhereInput
  }


  /**
   * Bot upsert
   */
  export type BotUpsertArgs = {
    /**
     * Select specific fields to fetch from the Bot
    **/
    select?: BotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BotInclude | null
    /**
     * The filter to search for the Bot to update in case it exists.
    **/
    where: BotWhereUniqueInput
    /**
     * In case the Bot found by the `where` argument doesn't exist, create a new Bot with this data.
    **/
    create: XOR<BotUncheckedCreateInput, BotCreateInput>
    /**
     * In case the Bot was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<BotUncheckedUpdateInput, BotUpdateInput>
  }


  /**
   * Bot delete
   */
  export type BotDeleteArgs = {
    /**
     * Select specific fields to fetch from the Bot
    **/
    select?: BotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BotInclude | null
    /**
     * Filter which Bot to delete.
    **/
    where: BotWhereUniqueInput
  }


  /**
   * Bot deleteMany
   */
  export type BotDeleteManyArgs = {
    where?: BotWhereInput
  }


  /**
   * Bot without action
   */
  export type BotArgs = {
    /**
     * Select specific fields to fetch from the Bot
    **/
    select?: BotSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BotInclude | null
  }



  /**
   * Model Shard
   */


  export type AggregateShard = {
    count: ShardCountAggregateOutputType | null
    avg: ShardAvgAggregateOutputType | null
    sum: ShardSumAggregateOutputType | null
    min: ShardMinAggregateOutputType | null
    max: ShardMaxAggregateOutputType | null
  }

  export type ShardAvgAggregateOutputType = {
    hostId: number
    botId: number
    shardID: number
  }

  export type ShardSumAggregateOutputType = {
    hostId: number
    botId: number
    shardID: number
  }

  export type ShardMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    lanchedAt: Date | null
    hostId: number
    botId: number
    status: ShardStatus | null
    shardID: number
  }

  export type ShardMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    lanchedAt: Date | null
    hostId: number
    botId: number
    status: ShardStatus | null
    shardID: number
  }

  export type ShardCountAggregateOutputType = {
    id: number | null
    createdAt: number | null
    lanchedAt: number | null
    hostId: number
    botId: number
    status: number | null
    shardID: number
    _all: number
  }


  export type ShardAvgAggregateInputType = {
    hostId?: true
    botId?: true
    shardID?: true
  }

  export type ShardSumAggregateInputType = {
    hostId?: true
    botId?: true
    shardID?: true
  }

  export type ShardMinAggregateInputType = {
    id?: true
    createdAt?: true
    lanchedAt?: true
    hostId?: true
    botId?: true
    status?: true
    shardID?: true
  }

  export type ShardMaxAggregateInputType = {
    id?: true
    createdAt?: true
    lanchedAt?: true
    hostId?: true
    botId?: true
    status?: true
    shardID?: true
  }

  export type ShardCountAggregateInputType = {
    id?: true
    createdAt?: true
    lanchedAt?: true
    hostId?: true
    botId?: true
    status?: true
    shardID?: true
    _all?: true
  }

  export type ShardAggregateArgs = {
    /**
     * Filter which Shard to aggregate.
    **/
    where?: ShardWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Shards to fetch.
    **/
    orderBy?: Enumerable<ShardOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ShardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shards from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shards.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shards
    **/
    count?: true | ShardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ShardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ShardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ShardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ShardMaxAggregateInputType
  }

  export type GetShardAggregateType<T extends ShardAggregateArgs> = {
    [P in keyof T & keyof AggregateShard]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShard[P]>
      : GetScalarType<T[P], AggregateShard[P]>
  }



  export type ShardSelect = {
    id?: boolean
    createdAt?: boolean
    lanchedAt?: boolean
    hostId?: boolean
    botId?: boolean
    status?: boolean
    shardID?: boolean
    bot?: boolean | BotArgs
    Host?: boolean | HostArgs
  }

  export type ShardInclude = {
    bot?: boolean | BotArgs
    Host?: boolean | HostArgs
  }

  export type ShardGetPayload<
    S extends boolean | null | undefined | ShardArgs,
    U = keyof S
      > = S extends true
        ? Shard
    : S extends undefined
    ? never
    : S extends ShardArgs | ShardFindManyArgs
    ?'include' extends U
    ? Shard  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'bot'
        ? BotGetPayload<S['include'][P]> :
        P extends 'Host'
        ? HostGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Shard ?Shard [P]
  : 
          P extends 'bot'
        ? BotGetPayload<S['select'][P]> :
        P extends 'Host'
        ? HostGetPayload<S['select'][P]> : never
  } 
    : Shard
  : Shard


  type ShardCountArgs = Merge<
    Omit<ShardFindManyArgs, 'select' | 'include'> & {
      select?: ShardCountAggregateInputType | true
    }
  >

  export interface ShardDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Shard that matches the filter.
     * @param {ShardFindUniqueArgs} args - Arguments to find a Shard
     * @example
     * // Get one Shard
     * const shard = await prisma.shard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShardFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ShardFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Shard'> extends True ? CheckSelect<T, Prisma__ShardClient<Shard>, Prisma__ShardClient<ShardGetPayload<T>>> : CheckSelect<T, Prisma__ShardClient<Shard | null >, Prisma__ShardClient<ShardGetPayload<T> | null >>

    /**
     * Find the first Shard that matches the filter.
     * @param {ShardFindFirstArgs} args - Arguments to find a Shard
     * @example
     * // Get one Shard
     * const shard = await prisma.shard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShardFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ShardFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Shard'> extends True ? CheckSelect<T, Prisma__ShardClient<Shard>, Prisma__ShardClient<ShardGetPayload<T>>> : CheckSelect<T, Prisma__ShardClient<Shard | null >, Prisma__ShardClient<ShardGetPayload<T> | null >>

    /**
     * Find zero or more Shards that matches the filter.
     * @param {ShardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shards
     * const shards = await prisma.shard.findMany()
     * 
     * // Get first 10 Shards
     * const shards = await prisma.shard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shardWithIdOnly = await prisma.shard.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShardFindManyArgs>(
      args?: SelectSubset<T, ShardFindManyArgs>
    ): CheckSelect<T, Promise<Array<Shard>>, Promise<Array<ShardGetPayload<T>>>>

    /**
     * Create a Shard.
     * @param {ShardCreateArgs} args - Arguments to create a Shard.
     * @example
     * // Create one Shard
     * const Shard = await prisma.shard.create({
     *   data: {
     *     // ... data to create a Shard
     *   }
     * })
     * 
    **/
    create<T extends ShardCreateArgs>(
      args: SelectSubset<T, ShardCreateArgs>
    ): CheckSelect<T, Prisma__ShardClient<Shard>, Prisma__ShardClient<ShardGetPayload<T>>>

    /**
     * Delete a Shard.
     * @param {ShardDeleteArgs} args - Arguments to delete one Shard.
     * @example
     * // Delete one Shard
     * const Shard = await prisma.shard.delete({
     *   where: {
     *     // ... filter to delete one Shard
     *   }
     * })
     * 
    **/
    delete<T extends ShardDeleteArgs>(
      args: SelectSubset<T, ShardDeleteArgs>
    ): CheckSelect<T, Prisma__ShardClient<Shard>, Prisma__ShardClient<ShardGetPayload<T>>>

    /**
     * Update one Shard.
     * @param {ShardUpdateArgs} args - Arguments to update one Shard.
     * @example
     * // Update one Shard
     * const shard = await prisma.shard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShardUpdateArgs>(
      args: SelectSubset<T, ShardUpdateArgs>
    ): CheckSelect<T, Prisma__ShardClient<Shard>, Prisma__ShardClient<ShardGetPayload<T>>>

    /**
     * Delete zero or more Shards.
     * @param {ShardDeleteManyArgs} args - Arguments to filter Shards to delete.
     * @example
     * // Delete a few Shards
     * const { count } = await prisma.shard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShardDeleteManyArgs>(
      args?: SelectSubset<T, ShardDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Shards.
     * @param {ShardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shards
     * const shard = await prisma.shard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShardUpdateManyArgs>(
      args: SelectSubset<T, ShardUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Shard.
     * @param {ShardUpsertArgs} args - Arguments to update or create a Shard.
     * @example
     * // Update or create a Shard
     * const shard = await prisma.shard.upsert({
     *   create: {
     *     // ... data to create a Shard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shard we want to update
     *   }
     * })
    **/
    upsert<T extends ShardUpsertArgs>(
      args: SelectSubset<T, ShardUpsertArgs>
    ): CheckSelect<T, Prisma__ShardClient<Shard>, Prisma__ShardClient<ShardGetPayload<T>>>

    /**
     * Count the number of Shards.
     * @param {ShardCountArgs} args - Arguments to filter Shards to count.
     * @example
     * // Count the number of Shards
     * const count = await prisma.shard.count({
     *   where: {
     *     // ... the filter for the Shards we want to count
     *   }
     * })
    **/
    count<T extends ShardCountArgs>(
      args?: Subset<T, ShardCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shard.
     * @param {ShardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShardAggregateArgs>(args: Subset<T, ShardAggregateArgs>): Promise<GetShardAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Shard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ShardClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    bot<T extends BotArgs = {}>(args?: Subset<T, BotArgs>): CheckSelect<T, Prisma__BotClient<Bot | null >, Prisma__BotClient<BotGetPayload<T> | null >>;

    Host<T extends HostArgs = {}>(args?: Subset<T, HostArgs>): CheckSelect<T, Prisma__HostClient<Host | null >, Prisma__HostClient<HostGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Shard findUnique
   */
  export type ShardFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Shard
    **/
    select?: ShardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ShardInclude | null
    /**
     * Throw an Error if a Shard can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Shard to fetch.
    **/
    where: ShardWhereUniqueInput
  }


  /**
   * Shard findFirst
   */
  export type ShardFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Shard
    **/
    select?: ShardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ShardInclude | null
    /**
     * Throw an Error if a Shard can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Shard to fetch.
    **/
    where?: ShardWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Shards to fetch.
    **/
    orderBy?: Enumerable<ShardOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shards.
    **/
    cursor?: ShardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shards from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shards.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Shards.
    **/
    distinct?: Enumerable<ShardScalarFieldEnum>
  }


  /**
   * Shard findMany
   */
  export type ShardFindManyArgs = {
    /**
     * Select specific fields to fetch from the Shard
    **/
    select?: ShardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ShardInclude | null
    /**
     * Filter, which Shards to fetch.
    **/
    where?: ShardWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Shards to fetch.
    **/
    orderBy?: Enumerable<ShardOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shards.
    **/
    cursor?: ShardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shards from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shards.
    **/
    skip?: number
    distinct?: Enumerable<ShardScalarFieldEnum>
  }


  /**
   * Shard create
   */
  export type ShardCreateArgs = {
    /**
     * Select specific fields to fetch from the Shard
    **/
    select?: ShardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ShardInclude | null
    /**
     * The data needed to create a Shard.
    **/
    data: XOR<ShardUncheckedCreateInput, ShardCreateInput>
  }


  /**
   * Shard update
   */
  export type ShardUpdateArgs = {
    /**
     * Select specific fields to fetch from the Shard
    **/
    select?: ShardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ShardInclude | null
    /**
     * The data needed to update a Shard.
    **/
    data: XOR<ShardUncheckedUpdateInput, ShardUpdateInput>
    /**
     * Choose, which Shard to update.
    **/
    where: ShardWhereUniqueInput
  }


  /**
   * Shard updateMany
   */
  export type ShardUpdateManyArgs = {
    data: XOR<ShardUncheckedUpdateManyInput, ShardUpdateManyMutationInput>
    where?: ShardWhereInput
  }


  /**
   * Shard upsert
   */
  export type ShardUpsertArgs = {
    /**
     * Select specific fields to fetch from the Shard
    **/
    select?: ShardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ShardInclude | null
    /**
     * The filter to search for the Shard to update in case it exists.
    **/
    where: ShardWhereUniqueInput
    /**
     * In case the Shard found by the `where` argument doesn't exist, create a new Shard with this data.
    **/
    create: XOR<ShardUncheckedCreateInput, ShardCreateInput>
    /**
     * In case the Shard was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ShardUncheckedUpdateInput, ShardUpdateInput>
  }


  /**
   * Shard delete
   */
  export type ShardDeleteArgs = {
    /**
     * Select specific fields to fetch from the Shard
    **/
    select?: ShardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ShardInclude | null
    /**
     * Filter which Shard to delete.
    **/
    where: ShardWhereUniqueInput
  }


  /**
   * Shard deleteMany
   */
  export type ShardDeleteManyArgs = {
    where?: ShardWhereInput
  }


  /**
   * Shard without action
   */
  export type ShardArgs = {
    /**
     * Select specific fields to fetch from the Shard
    **/
    select?: ShardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ShardInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    count: UserCountAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    isAdmin: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    isAdmin: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number | null
    firstName: number | null
    lastName: number | null
    email: number | null
    password: number | null
    isAdmin: number | null
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    isAdmin?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    isAdmin?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    isAdmin?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
    **/
    where?: UserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }



  export type UserSelect = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    isAdmin?: boolean
    actions?: boolean | ActionFindManyArgs
    Bot?: boolean | BotFindManyArgs
    commands?: boolean | CommandFindManyArgs
    discord?: boolean | DiscordUserArgs
    Hosts?: boolean | HostFindManyArgs
    Manager?: boolean | ManagerFindManyArgs
    pat?: boolean | PATFindManyArgs
    twitch?: boolean | TwitchUserArgs
    TwitterUser?: boolean | TwitterUserFindManyArgs
  }

  export type UserInclude = {
    actions?: boolean | ActionFindManyArgs
    Bot?: boolean | BotFindManyArgs
    commands?: boolean | CommandFindManyArgs
    discord?: boolean | DiscordUserArgs
    Hosts?: boolean | HostFindManyArgs
    Manager?: boolean | ManagerFindManyArgs
    pat?: boolean | PATFindManyArgs
    twitch?: boolean | TwitchUserArgs
    TwitterUser?: boolean | TwitterUserFindManyArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'actions'
        ? Array < ActionGetPayload<S['include'][P]>>  :
        P extends 'Bot'
        ? Array < BotGetPayload<S['include'][P]>>  :
        P extends 'commands'
        ? Array < CommandGetPayload<S['include'][P]>>  :
        P extends 'discord'
        ? DiscordUserGetPayload<S['include'][P]> | null :
        P extends 'Hosts'
        ? Array < HostGetPayload<S['include'][P]>>  :
        P extends 'Manager'
        ? Array < ManagerGetPayload<S['include'][P]>>  :
        P extends 'pat'
        ? Array < PATGetPayload<S['include'][P]>>  :
        P extends 'twitch'
        ? TwitchUserGetPayload<S['include'][P]> | null :
        P extends 'TwitterUser'
        ? Array < TwitterUserGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'actions'
        ? Array < ActionGetPayload<S['select'][P]>>  :
        P extends 'Bot'
        ? Array < BotGetPayload<S['select'][P]>>  :
        P extends 'commands'
        ? Array < CommandGetPayload<S['select'][P]>>  :
        P extends 'discord'
        ? DiscordUserGetPayload<S['select'][P]> | null :
        P extends 'Hosts'
        ? Array < HostGetPayload<S['select'][P]>>  :
        P extends 'Manager'
        ? Array < ManagerGetPayload<S['select'][P]>>  :
        P extends 'pat'
        ? Array < PATGetPayload<S['select'][P]>>  :
        P extends 'twitch'
        ? TwitchUserGetPayload<S['select'][P]> | null :
        P extends 'TwitterUser'
        ? Array < TwitterUserGetPayload<S['select'][P]>>  : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, Promise<Array<User>>, Promise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Users.
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Promise<GetUserAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    actions<T extends ActionFindManyArgs = {}>(args?: Subset<T, ActionFindManyArgs>): CheckSelect<T, Promise<Array<Action>>, Promise<Array<ActionGetPayload<T>>>>;

    Bot<T extends BotFindManyArgs = {}>(args?: Subset<T, BotFindManyArgs>): CheckSelect<T, Promise<Array<Bot>>, Promise<Array<BotGetPayload<T>>>>;

    commands<T extends CommandFindManyArgs = {}>(args?: Subset<T, CommandFindManyArgs>): CheckSelect<T, Promise<Array<Command>>, Promise<Array<CommandGetPayload<T>>>>;

    discord<T extends DiscordUserArgs = {}>(args?: Subset<T, DiscordUserArgs>): CheckSelect<T, Prisma__DiscordUserClient<DiscordUser | null >, Prisma__DiscordUserClient<DiscordUserGetPayload<T> | null >>;

    Hosts<T extends HostFindManyArgs = {}>(args?: Subset<T, HostFindManyArgs>): CheckSelect<T, Promise<Array<Host>>, Promise<Array<HostGetPayload<T>>>>;

    Manager<T extends ManagerFindManyArgs = {}>(args?: Subset<T, ManagerFindManyArgs>): CheckSelect<T, Promise<Array<Manager>>, Promise<Array<ManagerGetPayload<T>>>>;

    pat<T extends PATFindManyArgs = {}>(args?: Subset<T, PATFindManyArgs>): CheckSelect<T, Promise<Array<PAT>>, Promise<Array<PATGetPayload<T>>>>;

    twitch<T extends TwitchUserArgs = {}>(args?: Subset<T, TwitchUserArgs>): CheckSelect<T, Prisma__TwitchUserClient<TwitchUser | null >, Prisma__TwitchUserClient<TwitchUserGetPayload<T> | null >>;

    TwitterUser<T extends TwitterUserFindManyArgs = {}>(args?: Subset<T, TwitterUserFindManyArgs>): CheckSelect<T, Promise<Array<TwitterUser>>, Promise<Array<TwitterUserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where?: UserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Users.
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
    **/
    where?: UserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
    **/
    data: XOR<UserUncheckedCreateInput, UserCreateInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
    **/
    data: XOR<UserUncheckedUpdateInput, UserUpdateInput>
    /**
     * Choose, which User to update.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUncheckedUpdateManyInput, UserUpdateManyMutationInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
    **/
    create: XOR<UserUncheckedCreateInput, UserCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<UserUncheckedUpdateInput, UserUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
  }



  /**
   * Model PAT
   */


  export type AggregatePAT = {
    count: PATCountAggregateOutputType | null
    min: PATMinAggregateOutputType | null
    max: PATMaxAggregateOutputType | null
  }

  export type PATMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: PATStatus | null
  }

  export type PATMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: PATStatus | null
  }

  export type PATCountAggregateOutputType = {
    id: number | null
    userId: number | null
    createdAt: number | null
    updatedAt: number | null
    status: number | null
    _all: number
  }


  export type PATMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type PATMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type PATCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type PATAggregateArgs = {
    /**
     * Filter which PAT to aggregate.
    **/
    where?: PATWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of PATS to fetch.
    **/
    orderBy?: Enumerable<PATOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PATS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PATS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PATS
    **/
    count?: true | PATCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PATMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PATMaxAggregateInputType
  }

  export type GetPATAggregateType<T extends PATAggregateArgs> = {
    [P in keyof T & keyof AggregatePAT]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePAT[P]>
      : GetScalarType<T[P], AggregatePAT[P]>
  }



  export type PATSelect = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    user?: boolean | UserArgs
    transaction?: boolean | transactionFindManyArgs
  }

  export type PATInclude = {
    user?: boolean | UserArgs
    transaction?: boolean | transactionFindManyArgs
  }

  export type PATGetPayload<
    S extends boolean | null | undefined | PATArgs,
    U = keyof S
      > = S extends true
        ? PAT
    : S extends undefined
    ? never
    : S extends PATArgs | PATFindManyArgs
    ?'include' extends U
    ? PAT  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'transaction'
        ? Array < transactionGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PAT ?PAT [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'transaction'
        ? Array < transactionGetPayload<S['select'][P]>>  : never
  } 
    : PAT
  : PAT


  type PATCountArgs = Merge<
    Omit<PATFindManyArgs, 'select' | 'include'> & {
      select?: PATCountAggregateInputType | true
    }
  >

  export interface PATDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PAT that matches the filter.
     * @param {PATFindUniqueArgs} args - Arguments to find a PAT
     * @example
     * // Get one PAT
     * const pAT = await prisma.pAT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PATFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PATFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PAT'> extends True ? CheckSelect<T, Prisma__PATClient<PAT>, Prisma__PATClient<PATGetPayload<T>>> : CheckSelect<T, Prisma__PATClient<PAT | null >, Prisma__PATClient<PATGetPayload<T> | null >>

    /**
     * Find the first PAT that matches the filter.
     * @param {PATFindFirstArgs} args - Arguments to find a PAT
     * @example
     * // Get one PAT
     * const pAT = await prisma.pAT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PATFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PATFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PAT'> extends True ? CheckSelect<T, Prisma__PATClient<PAT>, Prisma__PATClient<PATGetPayload<T>>> : CheckSelect<T, Prisma__PATClient<PAT | null >, Prisma__PATClient<PATGetPayload<T> | null >>

    /**
     * Find zero or more PATS that matches the filter.
     * @param {PATFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PATS
     * const pATS = await prisma.pAT.findMany()
     * 
     * // Get first 10 PATS
     * const pATS = await prisma.pAT.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pATWithIdOnly = await prisma.pAT.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PATFindManyArgs>(
      args?: SelectSubset<T, PATFindManyArgs>
    ): CheckSelect<T, Promise<Array<PAT>>, Promise<Array<PATGetPayload<T>>>>

    /**
     * Create a PAT.
     * @param {PATCreateArgs} args - Arguments to create a PAT.
     * @example
     * // Create one PAT
     * const PAT = await prisma.pAT.create({
     *   data: {
     *     // ... data to create a PAT
     *   }
     * })
     * 
    **/
    create<T extends PATCreateArgs>(
      args: SelectSubset<T, PATCreateArgs>
    ): CheckSelect<T, Prisma__PATClient<PAT>, Prisma__PATClient<PATGetPayload<T>>>

    /**
     * Delete a PAT.
     * @param {PATDeleteArgs} args - Arguments to delete one PAT.
     * @example
     * // Delete one PAT
     * const PAT = await prisma.pAT.delete({
     *   where: {
     *     // ... filter to delete one PAT
     *   }
     * })
     * 
    **/
    delete<T extends PATDeleteArgs>(
      args: SelectSubset<T, PATDeleteArgs>
    ): CheckSelect<T, Prisma__PATClient<PAT>, Prisma__PATClient<PATGetPayload<T>>>

    /**
     * Update one PAT.
     * @param {PATUpdateArgs} args - Arguments to update one PAT.
     * @example
     * // Update one PAT
     * const pAT = await prisma.pAT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PATUpdateArgs>(
      args: SelectSubset<T, PATUpdateArgs>
    ): CheckSelect<T, Prisma__PATClient<PAT>, Prisma__PATClient<PATGetPayload<T>>>

    /**
     * Delete zero or more PATS.
     * @param {PATDeleteManyArgs} args - Arguments to filter PATS to delete.
     * @example
     * // Delete a few PATS
     * const { count } = await prisma.pAT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PATDeleteManyArgs>(
      args?: SelectSubset<T, PATDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more PATS.
     * @param {PATUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PATS
     * const pAT = await prisma.pAT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PATUpdateManyArgs>(
      args: SelectSubset<T, PATUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one PAT.
     * @param {PATUpsertArgs} args - Arguments to update or create a PAT.
     * @example
     * // Update or create a PAT
     * const pAT = await prisma.pAT.upsert({
     *   create: {
     *     // ... data to create a PAT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PAT we want to update
     *   }
     * })
    **/
    upsert<T extends PATUpsertArgs>(
      args: SelectSubset<T, PATUpsertArgs>
    ): CheckSelect<T, Prisma__PATClient<PAT>, Prisma__PATClient<PATGetPayload<T>>>

    /**
     * Count the number of PATS.
     * @param {PATCountArgs} args - Arguments to filter PATS to count.
     * @example
     * // Count the number of PATS
     * const count = await prisma.pAT.count({
     *   where: {
     *     // ... the filter for the PATS we want to count
     *   }
     * })
    **/
    count<T extends PATCountArgs>(
      args?: Subset<T, PATCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PATCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PAT.
     * @param {PATAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PATAggregateArgs>(args: Subset<T, PATAggregateArgs>): Promise<GetPATAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for PAT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PATClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    transaction<T extends transactionFindManyArgs = {}>(args?: Subset<T, transactionFindManyArgs>): CheckSelect<T, Promise<Array<transaction>>, Promise<Array<transactionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PAT findUnique
   */
  export type PATFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PAT
    **/
    select?: PATSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PATInclude | null
    /**
     * Throw an Error if a PAT can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PAT to fetch.
    **/
    where: PATWhereUniqueInput
  }


  /**
   * PAT findFirst
   */
  export type PATFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PAT
    **/
    select?: PATSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PATInclude | null
    /**
     * Throw an Error if a PAT can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PAT to fetch.
    **/
    where?: PATWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of PATS to fetch.
    **/
    orderBy?: Enumerable<PATOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PATS.
    **/
    cursor?: PATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PATS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PATS.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of PATS.
    **/
    distinct?: Enumerable<PATScalarFieldEnum>
  }


  /**
   * PAT findMany
   */
  export type PATFindManyArgs = {
    /**
     * Select specific fields to fetch from the PAT
    **/
    select?: PATSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PATInclude | null
    /**
     * Filter, which PATS to fetch.
    **/
    where?: PATWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of PATS to fetch.
    **/
    orderBy?: Enumerable<PATOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PATS.
    **/
    cursor?: PATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PATS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PATS.
    **/
    skip?: number
    distinct?: Enumerable<PATScalarFieldEnum>
  }


  /**
   * PAT create
   */
  export type PATCreateArgs = {
    /**
     * Select specific fields to fetch from the PAT
    **/
    select?: PATSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PATInclude | null
    /**
     * The data needed to create a PAT.
    **/
    data: XOR<PATUncheckedCreateInput, PATCreateInput>
  }


  /**
   * PAT update
   */
  export type PATUpdateArgs = {
    /**
     * Select specific fields to fetch from the PAT
    **/
    select?: PATSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PATInclude | null
    /**
     * The data needed to update a PAT.
    **/
    data: XOR<PATUncheckedUpdateInput, PATUpdateInput>
    /**
     * Choose, which PAT to update.
    **/
    where: PATWhereUniqueInput
  }


  /**
   * PAT updateMany
   */
  export type PATUpdateManyArgs = {
    data: XOR<PATUncheckedUpdateManyInput, PATUpdateManyMutationInput>
    where?: PATWhereInput
  }


  /**
   * PAT upsert
   */
  export type PATUpsertArgs = {
    /**
     * Select specific fields to fetch from the PAT
    **/
    select?: PATSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PATInclude | null
    /**
     * The filter to search for the PAT to update in case it exists.
    **/
    where: PATWhereUniqueInput
    /**
     * In case the PAT found by the `where` argument doesn't exist, create a new PAT with this data.
    **/
    create: XOR<PATUncheckedCreateInput, PATCreateInput>
    /**
     * In case the PAT was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PATUncheckedUpdateInput, PATUpdateInput>
  }


  /**
   * PAT delete
   */
  export type PATDeleteArgs = {
    /**
     * Select specific fields to fetch from the PAT
    **/
    select?: PATSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PATInclude | null
    /**
     * Filter which PAT to delete.
    **/
    where: PATWhereUniqueInput
  }


  /**
   * PAT deleteMany
   */
  export type PATDeleteManyArgs = {
    where?: PATWhereInput
  }


  /**
   * PAT without action
   */
  export type PATArgs = {
    /**
     * Select specific fields to fetch from the PAT
    **/
    select?: PATSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PATInclude | null
  }



  /**
   * Model transaction
   */


  export type AggregateTransaction = {
    count: TransactionCountAggregateOutputType | null
    min: TransactionMinAggregateOutputType | null
    max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    completedAt: Date | null
    managerId: string | null
    patId: string | null
    suspicious: boolean | null
    fraudulent: boolean | null
    reversedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    completedAt: Date | null
    managerId: string | null
    patId: string | null
    suspicious: boolean | null
    fraudulent: boolean | null
    reversedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number | null
    createdAt: number | null
    completedAt: number | null
    managerId: number | null
    patId: number | null
    suspicious: number | null
    fraudulent: number | null
    reversedAt: number | null
    _all: number
  }


  export type TransactionMinAggregateInputType = {
    id?: true
    createdAt?: true
    completedAt?: true
    managerId?: true
    patId?: true
    suspicious?: true
    fraudulent?: true
    reversedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    completedAt?: true
    managerId?: true
    patId?: true
    suspicious?: true
    fraudulent?: true
    reversedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    createdAt?: true
    completedAt?: true
    managerId?: true
    patId?: true
    suspicious?: true
    fraudulent?: true
    reversedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs = {
    /**
     * Filter which transaction to aggregate.
    **/
    where?: transactionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of transactions to fetch.
    **/
    orderBy?: Enumerable<transactionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactions
    **/
    count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
    [P in keyof T & keyof AggregateTransaction]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }



  export type transactionSelect = {
    id?: boolean
    createdAt?: boolean
    completedAt?: boolean
    managerId?: boolean
    patId?: boolean
    suspicious?: boolean
    fraudulent?: boolean
    reversedAt?: boolean
    responsibleManager?: boolean | ManagerArgs
    pat?: boolean | PATArgs
  }

  export type transactionInclude = {
    responsibleManager?: boolean | ManagerArgs
    pat?: boolean | PATArgs
  }

  export type transactionGetPayload<
    S extends boolean | null | undefined | transactionArgs,
    U = keyof S
      > = S extends true
        ? transaction
    : S extends undefined
    ? never
    : S extends transactionArgs | transactionFindManyArgs
    ?'include' extends U
    ? transaction  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'responsibleManager'
        ? ManagerGetPayload<S['include'][P]> :
        P extends 'pat'
        ? PATGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof transaction ?transaction [P]
  : 
          P extends 'responsibleManager'
        ? ManagerGetPayload<S['select'][P]> :
        P extends 'pat'
        ? PATGetPayload<S['select'][P]> | null : never
  } 
    : transaction
  : transaction


  type transactionCountArgs = Merge<
    Omit<transactionFindManyArgs, 'select' | 'include'> & {
      select?: TransactionCountAggregateInputType | true
    }
  >

  export interface transactionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {transactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends transactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, transactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'transaction'> extends True ? CheckSelect<T, Prisma__transactionClient<transaction>, Prisma__transactionClient<transactionGetPayload<T>>> : CheckSelect<T, Prisma__transactionClient<transaction | null >, Prisma__transactionClient<transactionGetPayload<T> | null >>

    /**
     * Find the first Transaction that matches the filter.
     * @param {transactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends transactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, transactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'transaction'> extends True ? CheckSelect<T, Prisma__transactionClient<transaction>, Prisma__transactionClient<transactionGetPayload<T>>> : CheckSelect<T, Prisma__transactionClient<transaction | null >, Prisma__transactionClient<transactionGetPayload<T> | null >>

    /**
     * Find zero or more Transactions that matches the filter.
     * @param {transactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends transactionFindManyArgs>(
      args?: SelectSubset<T, transactionFindManyArgs>
    ): CheckSelect<T, Promise<Array<transaction>>, Promise<Array<transactionGetPayload<T>>>>

    /**
     * Create a Transaction.
     * @param {transactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
    **/
    create<T extends transactionCreateArgs>(
      args: SelectSubset<T, transactionCreateArgs>
    ): CheckSelect<T, Prisma__transactionClient<transaction>, Prisma__transactionClient<transactionGetPayload<T>>>

    /**
     * Delete a Transaction.
     * @param {transactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
    **/
    delete<T extends transactionDeleteArgs>(
      args: SelectSubset<T, transactionDeleteArgs>
    ): CheckSelect<T, Prisma__transactionClient<transaction>, Prisma__transactionClient<transactionGetPayload<T>>>

    /**
     * Update one Transaction.
     * @param {transactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends transactionUpdateArgs>(
      args: SelectSubset<T, transactionUpdateArgs>
    ): CheckSelect<T, Prisma__transactionClient<transaction>, Prisma__transactionClient<transactionGetPayload<T>>>

    /**
     * Delete zero or more Transactions.
     * @param {transactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends transactionDeleteManyArgs>(
      args?: SelectSubset<T, transactionDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * @param {transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends transactionUpdateManyArgs>(
      args: SelectSubset<T, transactionUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {transactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
    **/
    upsert<T extends transactionUpsertArgs>(
      args: SelectSubset<T, transactionUpsertArgs>
    ): CheckSelect<T, Prisma__transactionClient<transaction>, Prisma__transactionClient<transactionGetPayload<T>>>

    /**
     * Count the number of Transactions.
     * @param {transactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends transactionCountArgs>(
      args?: Subset<T, transactionCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Promise<GetTransactionAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__transactionClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    responsibleManager<T extends ManagerArgs = {}>(args?: Subset<T, ManagerArgs>): CheckSelect<T, Prisma__ManagerClient<Manager | null >, Prisma__ManagerClient<ManagerGetPayload<T> | null >>;

    pat<T extends PATArgs = {}>(args?: Subset<T, PATArgs>): CheckSelect<T, Prisma__PATClient<PAT | null >, Prisma__PATClient<PATGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * transaction findUnique
   */
  export type transactionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the transaction
    **/
    select?: transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: transactionInclude | null
    /**
     * Throw an Error if a transaction can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which transaction to fetch.
    **/
    where: transactionWhereUniqueInput
  }


  /**
   * transaction findFirst
   */
  export type transactionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the transaction
    **/
    select?: transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: transactionInclude | null
    /**
     * Throw an Error if a transaction can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which transaction to fetch.
    **/
    where?: transactionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of transactions to fetch.
    **/
    orderBy?: Enumerable<transactionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
    **/
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of transactions.
    **/
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * transaction findMany
   */
  export type transactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the transaction
    **/
    select?: transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: transactionInclude | null
    /**
     * Filter, which transactions to fetch.
    **/
    where?: transactionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of transactions to fetch.
    **/
    orderBy?: Enumerable<transactionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactions.
    **/
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
    **/
    skip?: number
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * transaction create
   */
  export type transactionCreateArgs = {
    /**
     * Select specific fields to fetch from the transaction
    **/
    select?: transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: transactionInclude | null
    /**
     * The data needed to create a transaction.
    **/
    data: XOR<transactionUncheckedCreateInput, transactionCreateInput>
  }


  /**
   * transaction update
   */
  export type transactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the transaction
    **/
    select?: transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: transactionInclude | null
    /**
     * The data needed to update a transaction.
    **/
    data: XOR<transactionUncheckedUpdateInput, transactionUpdateInput>
    /**
     * Choose, which transaction to update.
    **/
    where: transactionWhereUniqueInput
  }


  /**
   * transaction updateMany
   */
  export type transactionUpdateManyArgs = {
    data: XOR<transactionUncheckedUpdateManyInput, transactionUpdateManyMutationInput>
    where?: transactionWhereInput
  }


  /**
   * transaction upsert
   */
  export type transactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the transaction
    **/
    select?: transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: transactionInclude | null
    /**
     * The filter to search for the transaction to update in case it exists.
    **/
    where: transactionWhereUniqueInput
    /**
     * In case the transaction found by the `where` argument doesn't exist, create a new transaction with this data.
    **/
    create: XOR<transactionUncheckedCreateInput, transactionCreateInput>
    /**
     * In case the transaction was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<transactionUncheckedUpdateInput, transactionUpdateInput>
  }


  /**
   * transaction delete
   */
  export type transactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the transaction
    **/
    select?: transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: transactionInclude | null
    /**
     * Filter which transaction to delete.
    **/
    where: transactionWhereUniqueInput
  }


  /**
   * transaction deleteMany
   */
  export type transactionDeleteManyArgs = {
    where?: transactionWhereInput
  }


  /**
   * transaction without action
   */
  export type transactionArgs = {
    /**
     * Select specific fields to fetch from the transaction
    **/
    select?: transactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: transactionInclude | null
  }



  /**
   * Model DiscordUser
   */


  export type AggregateDiscordUser = {
    count: DiscordUserCountAggregateOutputType | null
    avg: DiscordUserAvgAggregateOutputType | null
    sum: DiscordUserSumAggregateOutputType | null
    min: DiscordUserMinAggregateOutputType | null
    max: DiscordUserMaxAggregateOutputType | null
  }

  export type DiscordUserAvgAggregateOutputType = {
    discrim: number
  }

  export type DiscordUserSumAggregateOutputType = {
    discrim: number
  }

  export type DiscordUserMinAggregateOutputType = {
    id: string | null
    username: string | null
    discrim: number
    userId: string | null
  }

  export type DiscordUserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    discrim: number
    userId: string | null
  }

  export type DiscordUserCountAggregateOutputType = {
    id: number | null
    username: number | null
    discrim: number
    userId: number | null
    _all: number
  }


  export type DiscordUserAvgAggregateInputType = {
    discrim?: true
  }

  export type DiscordUserSumAggregateInputType = {
    discrim?: true
  }

  export type DiscordUserMinAggregateInputType = {
    id?: true
    username?: true
    discrim?: true
    userId?: true
  }

  export type DiscordUserMaxAggregateInputType = {
    id?: true
    username?: true
    discrim?: true
    userId?: true
  }

  export type DiscordUserCountAggregateInputType = {
    id?: true
    username?: true
    discrim?: true
    userId?: true
    _all?: true
  }

  export type DiscordUserAggregateArgs = {
    /**
     * Filter which DiscordUser to aggregate.
    **/
    where?: DiscordUserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of DiscordUsers to fetch.
    **/
    orderBy?: Enumerable<DiscordUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: DiscordUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscordUsers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordUsers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiscordUsers
    **/
    count?: true | DiscordUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: DiscordUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: DiscordUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: DiscordUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: DiscordUserMaxAggregateInputType
  }

  export type GetDiscordUserAggregateType<T extends DiscordUserAggregateArgs> = {
    [P in keyof T & keyof AggregateDiscordUser]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscordUser[P]>
      : GetScalarType<T[P], AggregateDiscordUser[P]>
  }



  export type DiscordUserSelect = {
    id?: boolean
    username?: boolean
    discrim?: boolean
    userId?: boolean
    user?: boolean | UserArgs
    administates?: boolean | AdminOnGuildsFindManyArgs
    UsersOnGuilds?: boolean | UsersOnGuildsFindManyArgs
  }

  export type DiscordUserInclude = {
    user?: boolean | UserArgs
    administates?: boolean | AdminOnGuildsFindManyArgs
    UsersOnGuilds?: boolean | UsersOnGuildsFindManyArgs
  }

  export type DiscordUserGetPayload<
    S extends boolean | null | undefined | DiscordUserArgs,
    U = keyof S
      > = S extends true
        ? DiscordUser
    : S extends undefined
    ? never
    : S extends DiscordUserArgs | DiscordUserFindManyArgs
    ?'include' extends U
    ? DiscordUser  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> | null :
        P extends 'administates'
        ? Array < AdminOnGuildsGetPayload<S['include'][P]>>  :
        P extends 'UsersOnGuilds'
        ? Array < UsersOnGuildsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DiscordUser ?DiscordUser [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> | null :
        P extends 'administates'
        ? Array < AdminOnGuildsGetPayload<S['select'][P]>>  :
        P extends 'UsersOnGuilds'
        ? Array < UsersOnGuildsGetPayload<S['select'][P]>>  : never
  } 
    : DiscordUser
  : DiscordUser


  type DiscordUserCountArgs = Merge<
    Omit<DiscordUserFindManyArgs, 'select' | 'include'> & {
      select?: DiscordUserCountAggregateInputType | true
    }
  >

  export interface DiscordUserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DiscordUser that matches the filter.
     * @param {DiscordUserFindUniqueArgs} args - Arguments to find a DiscordUser
     * @example
     * // Get one DiscordUser
     * const discordUser = await prisma.discordUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiscordUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DiscordUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DiscordUser'> extends True ? CheckSelect<T, Prisma__DiscordUserClient<DiscordUser>, Prisma__DiscordUserClient<DiscordUserGetPayload<T>>> : CheckSelect<T, Prisma__DiscordUserClient<DiscordUser | null >, Prisma__DiscordUserClient<DiscordUserGetPayload<T> | null >>

    /**
     * Find the first DiscordUser that matches the filter.
     * @param {DiscordUserFindFirstArgs} args - Arguments to find a DiscordUser
     * @example
     * // Get one DiscordUser
     * const discordUser = await prisma.discordUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiscordUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DiscordUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DiscordUser'> extends True ? CheckSelect<T, Prisma__DiscordUserClient<DiscordUser>, Prisma__DiscordUserClient<DiscordUserGetPayload<T>>> : CheckSelect<T, Prisma__DiscordUserClient<DiscordUser | null >, Prisma__DiscordUserClient<DiscordUserGetPayload<T> | null >>

    /**
     * Find zero or more DiscordUsers that matches the filter.
     * @param {DiscordUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiscordUsers
     * const discordUsers = await prisma.discordUser.findMany()
     * 
     * // Get first 10 DiscordUsers
     * const discordUsers = await prisma.discordUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discordUserWithIdOnly = await prisma.discordUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DiscordUserFindManyArgs>(
      args?: SelectSubset<T, DiscordUserFindManyArgs>
    ): CheckSelect<T, Promise<Array<DiscordUser>>, Promise<Array<DiscordUserGetPayload<T>>>>

    /**
     * Create a DiscordUser.
     * @param {DiscordUserCreateArgs} args - Arguments to create a DiscordUser.
     * @example
     * // Create one DiscordUser
     * const DiscordUser = await prisma.discordUser.create({
     *   data: {
     *     // ... data to create a DiscordUser
     *   }
     * })
     * 
    **/
    create<T extends DiscordUserCreateArgs>(
      args: SelectSubset<T, DiscordUserCreateArgs>
    ): CheckSelect<T, Prisma__DiscordUserClient<DiscordUser>, Prisma__DiscordUserClient<DiscordUserGetPayload<T>>>

    /**
     * Delete a DiscordUser.
     * @param {DiscordUserDeleteArgs} args - Arguments to delete one DiscordUser.
     * @example
     * // Delete one DiscordUser
     * const DiscordUser = await prisma.discordUser.delete({
     *   where: {
     *     // ... filter to delete one DiscordUser
     *   }
     * })
     * 
    **/
    delete<T extends DiscordUserDeleteArgs>(
      args: SelectSubset<T, DiscordUserDeleteArgs>
    ): CheckSelect<T, Prisma__DiscordUserClient<DiscordUser>, Prisma__DiscordUserClient<DiscordUserGetPayload<T>>>

    /**
     * Update one DiscordUser.
     * @param {DiscordUserUpdateArgs} args - Arguments to update one DiscordUser.
     * @example
     * // Update one DiscordUser
     * const discordUser = await prisma.discordUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiscordUserUpdateArgs>(
      args: SelectSubset<T, DiscordUserUpdateArgs>
    ): CheckSelect<T, Prisma__DiscordUserClient<DiscordUser>, Prisma__DiscordUserClient<DiscordUserGetPayload<T>>>

    /**
     * Delete zero or more DiscordUsers.
     * @param {DiscordUserDeleteManyArgs} args - Arguments to filter DiscordUsers to delete.
     * @example
     * // Delete a few DiscordUsers
     * const { count } = await prisma.discordUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiscordUserDeleteManyArgs>(
      args?: SelectSubset<T, DiscordUserDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more DiscordUsers.
     * @param {DiscordUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiscordUsers
     * const discordUser = await prisma.discordUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiscordUserUpdateManyArgs>(
      args: SelectSubset<T, DiscordUserUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one DiscordUser.
     * @param {DiscordUserUpsertArgs} args - Arguments to update or create a DiscordUser.
     * @example
     * // Update or create a DiscordUser
     * const discordUser = await prisma.discordUser.upsert({
     *   create: {
     *     // ... data to create a DiscordUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiscordUser we want to update
     *   }
     * })
    **/
    upsert<T extends DiscordUserUpsertArgs>(
      args: SelectSubset<T, DiscordUserUpsertArgs>
    ): CheckSelect<T, Prisma__DiscordUserClient<DiscordUser>, Prisma__DiscordUserClient<DiscordUserGetPayload<T>>>

    /**
     * Count the number of DiscordUsers.
     * @param {DiscordUserCountArgs} args - Arguments to filter DiscordUsers to count.
     * @example
     * // Count the number of DiscordUsers
     * const count = await prisma.discordUser.count({
     *   where: {
     *     // ... the filter for the DiscordUsers we want to count
     *   }
     * })
    **/
    count<T extends DiscordUserCountArgs>(
      args?: Subset<T, DiscordUserCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscordUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiscordUser.
     * @param {DiscordUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscordUserAggregateArgs>(args: Subset<T, DiscordUserAggregateArgs>): Promise<GetDiscordUserAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for DiscordUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DiscordUserClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    administates<T extends AdminOnGuildsFindManyArgs = {}>(args?: Subset<T, AdminOnGuildsFindManyArgs>): CheckSelect<T, Promise<Array<AdminOnGuilds>>, Promise<Array<AdminOnGuildsGetPayload<T>>>>;

    UsersOnGuilds<T extends UsersOnGuildsFindManyArgs = {}>(args?: Subset<T, UsersOnGuildsFindManyArgs>): CheckSelect<T, Promise<Array<UsersOnGuilds>>, Promise<Array<UsersOnGuildsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DiscordUser findUnique
   */
  export type DiscordUserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DiscordUser
    **/
    select?: DiscordUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DiscordUserInclude | null
    /**
     * Throw an Error if a DiscordUser can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DiscordUser to fetch.
    **/
    where: DiscordUserWhereUniqueInput
  }


  /**
   * DiscordUser findFirst
   */
  export type DiscordUserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DiscordUser
    **/
    select?: DiscordUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DiscordUserInclude | null
    /**
     * Throw an Error if a DiscordUser can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DiscordUser to fetch.
    **/
    where?: DiscordUserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of DiscordUsers to fetch.
    **/
    orderBy?: Enumerable<DiscordUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscordUsers.
    **/
    cursor?: DiscordUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscordUsers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordUsers.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of DiscordUsers.
    **/
    distinct?: Enumerable<DiscordUserScalarFieldEnum>
  }


  /**
   * DiscordUser findMany
   */
  export type DiscordUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the DiscordUser
    **/
    select?: DiscordUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DiscordUserInclude | null
    /**
     * Filter, which DiscordUsers to fetch.
    **/
    where?: DiscordUserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of DiscordUsers to fetch.
    **/
    orderBy?: Enumerable<DiscordUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiscordUsers.
    **/
    cursor?: DiscordUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscordUsers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordUsers.
    **/
    skip?: number
    distinct?: Enumerable<DiscordUserScalarFieldEnum>
  }


  /**
   * DiscordUser create
   */
  export type DiscordUserCreateArgs = {
    /**
     * Select specific fields to fetch from the DiscordUser
    **/
    select?: DiscordUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DiscordUserInclude | null
    /**
     * The data needed to create a DiscordUser.
    **/
    data: XOR<DiscordUserUncheckedCreateInput, DiscordUserCreateInput>
  }


  /**
   * DiscordUser update
   */
  export type DiscordUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the DiscordUser
    **/
    select?: DiscordUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DiscordUserInclude | null
    /**
     * The data needed to update a DiscordUser.
    **/
    data: XOR<DiscordUserUncheckedUpdateInput, DiscordUserUpdateInput>
    /**
     * Choose, which DiscordUser to update.
    **/
    where: DiscordUserWhereUniqueInput
  }


  /**
   * DiscordUser updateMany
   */
  export type DiscordUserUpdateManyArgs = {
    data: XOR<DiscordUserUncheckedUpdateManyInput, DiscordUserUpdateManyMutationInput>
    where?: DiscordUserWhereInput
  }


  /**
   * DiscordUser upsert
   */
  export type DiscordUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the DiscordUser
    **/
    select?: DiscordUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DiscordUserInclude | null
    /**
     * The filter to search for the DiscordUser to update in case it exists.
    **/
    where: DiscordUserWhereUniqueInput
    /**
     * In case the DiscordUser found by the `where` argument doesn't exist, create a new DiscordUser with this data.
    **/
    create: XOR<DiscordUserUncheckedCreateInput, DiscordUserCreateInput>
    /**
     * In case the DiscordUser was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<DiscordUserUncheckedUpdateInput, DiscordUserUpdateInput>
  }


  /**
   * DiscordUser delete
   */
  export type DiscordUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the DiscordUser
    **/
    select?: DiscordUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DiscordUserInclude | null
    /**
     * Filter which DiscordUser to delete.
    **/
    where: DiscordUserWhereUniqueInput
  }


  /**
   * DiscordUser deleteMany
   */
  export type DiscordUserDeleteManyArgs = {
    where?: DiscordUserWhereInput
  }


  /**
   * DiscordUser without action
   */
  export type DiscordUserArgs = {
    /**
     * Select specific fields to fetch from the DiscordUser
    **/
    select?: DiscordUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: DiscordUserInclude | null
  }



  /**
   * Model guild
   */


  export type AggregateGuild = {
    count: GuildCountAggregateOutputType | null
    avg: GuildAvgAggregateOutputType | null
    sum: GuildSumAggregateOutputType | null
    min: GuildMinAggregateOutputType | null
    max: GuildMaxAggregateOutputType | null
  }

  export type GuildAvgAggregateOutputType = {
    id: number
  }

  export type GuildSumAggregateOutputType = {
    id: number
  }

  export type GuildMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type GuildMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type GuildCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type GuildAvgAggregateInputType = {
    id?: true
  }

  export type GuildSumAggregateInputType = {
    id?: true
  }

  export type GuildMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type GuildMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type GuildCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type GuildAggregateArgs = {
    /**
     * Filter which guild to aggregate.
    **/
    where?: guildWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of guilds to fetch.
    **/
    orderBy?: Enumerable<guildOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: guildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guilds from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guilds.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned guilds
    **/
    count?: true | GuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: GuildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: GuildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: GuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: GuildMaxAggregateInputType
  }

  export type GetGuildAggregateType<T extends GuildAggregateArgs> = {
    [P in keyof T & keyof AggregateGuild]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuild[P]>
      : GetScalarType<T[P], AggregateGuild[P]>
  }



  export type guildSelect = {
    id?: boolean
    name?: boolean
    admins?: boolean | AdminOnGuildsFindManyArgs
    members?: boolean | UsersOnGuildsFindManyArgs
  }

  export type guildInclude = {
    admins?: boolean | AdminOnGuildsFindManyArgs
    members?: boolean | UsersOnGuildsFindManyArgs
  }

  export type guildGetPayload<
    S extends boolean | null | undefined | guildArgs,
    U = keyof S
      > = S extends true
        ? guild
    : S extends undefined
    ? never
    : S extends guildArgs | guildFindManyArgs
    ?'include' extends U
    ? guild  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'admins'
        ? Array < AdminOnGuildsGetPayload<S['include'][P]>>  :
        P extends 'members'
        ? Array < UsersOnGuildsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof guild ?guild [P]
  : 
          P extends 'admins'
        ? Array < AdminOnGuildsGetPayload<S['select'][P]>>  :
        P extends 'members'
        ? Array < UsersOnGuildsGetPayload<S['select'][P]>>  : never
  } 
    : guild
  : guild


  type guildCountArgs = Merge<
    Omit<guildFindManyArgs, 'select' | 'include'> & {
      select?: GuildCountAggregateInputType | true
    }
  >

  export interface guildDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Guild that matches the filter.
     * @param {guildFindUniqueArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends guildFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, guildFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'guild'> extends True ? CheckSelect<T, Prisma__guildClient<guild>, Prisma__guildClient<guildGetPayload<T>>> : CheckSelect<T, Prisma__guildClient<guild | null >, Prisma__guildClient<guildGetPayload<T> | null >>

    /**
     * Find the first Guild that matches the filter.
     * @param {guildFindFirstArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends guildFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, guildFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'guild'> extends True ? CheckSelect<T, Prisma__guildClient<guild>, Prisma__guildClient<guildGetPayload<T>>> : CheckSelect<T, Prisma__guildClient<guild | null >, Prisma__guildClient<guildGetPayload<T> | null >>

    /**
     * Find zero or more Guilds that matches the filter.
     * @param {guildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guilds
     * const guilds = await prisma.guild.findMany()
     * 
     * // Get first 10 Guilds
     * const guilds = await prisma.guild.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildWithIdOnly = await prisma.guild.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends guildFindManyArgs>(
      args?: SelectSubset<T, guildFindManyArgs>
    ): CheckSelect<T, Promise<Array<guild>>, Promise<Array<guildGetPayload<T>>>>

    /**
     * Create a Guild.
     * @param {guildCreateArgs} args - Arguments to create a Guild.
     * @example
     * // Create one Guild
     * const Guild = await prisma.guild.create({
     *   data: {
     *     // ... data to create a Guild
     *   }
     * })
     * 
    **/
    create<T extends guildCreateArgs>(
      args: SelectSubset<T, guildCreateArgs>
    ): CheckSelect<T, Prisma__guildClient<guild>, Prisma__guildClient<guildGetPayload<T>>>

    /**
     * Delete a Guild.
     * @param {guildDeleteArgs} args - Arguments to delete one Guild.
     * @example
     * // Delete one Guild
     * const Guild = await prisma.guild.delete({
     *   where: {
     *     // ... filter to delete one Guild
     *   }
     * })
     * 
    **/
    delete<T extends guildDeleteArgs>(
      args: SelectSubset<T, guildDeleteArgs>
    ): CheckSelect<T, Prisma__guildClient<guild>, Prisma__guildClient<guildGetPayload<T>>>

    /**
     * Update one Guild.
     * @param {guildUpdateArgs} args - Arguments to update one Guild.
     * @example
     * // Update one Guild
     * const guild = await prisma.guild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends guildUpdateArgs>(
      args: SelectSubset<T, guildUpdateArgs>
    ): CheckSelect<T, Prisma__guildClient<guild>, Prisma__guildClient<guildGetPayload<T>>>

    /**
     * Delete zero or more Guilds.
     * @param {guildDeleteManyArgs} args - Arguments to filter Guilds to delete.
     * @example
     * // Delete a few Guilds
     * const { count } = await prisma.guild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends guildDeleteManyArgs>(
      args?: SelectSubset<T, guildDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Guilds.
     * @param {guildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guilds
     * const guild = await prisma.guild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends guildUpdateManyArgs>(
      args: SelectSubset<T, guildUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Guild.
     * @param {guildUpsertArgs} args - Arguments to update or create a Guild.
     * @example
     * // Update or create a Guild
     * const guild = await prisma.guild.upsert({
     *   create: {
     *     // ... data to create a Guild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guild we want to update
     *   }
     * })
    **/
    upsert<T extends guildUpsertArgs>(
      args: SelectSubset<T, guildUpsertArgs>
    ): CheckSelect<T, Prisma__guildClient<guild>, Prisma__guildClient<guildGetPayload<T>>>

    /**
     * Count the number of Guilds.
     * @param {guildCountArgs} args - Arguments to filter Guilds to count.
     * @example
     * // Count the number of Guilds
     * const count = await prisma.guild.count({
     *   where: {
     *     // ... the filter for the Guilds we want to count
     *   }
     * })
    **/
    count<T extends guildCountArgs>(
      args?: Subset<T, guildCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guild.
     * @param {GuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildAggregateArgs>(args: Subset<T, GuildAggregateArgs>): Promise<GetGuildAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for guild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__guildClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    admins<T extends AdminOnGuildsFindManyArgs = {}>(args?: Subset<T, AdminOnGuildsFindManyArgs>): CheckSelect<T, Promise<Array<AdminOnGuilds>>, Promise<Array<AdminOnGuildsGetPayload<T>>>>;

    members<T extends UsersOnGuildsFindManyArgs = {}>(args?: Subset<T, UsersOnGuildsFindManyArgs>): CheckSelect<T, Promise<Array<UsersOnGuilds>>, Promise<Array<UsersOnGuildsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * guild findUnique
   */
  export type guildFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the guild
    **/
    select?: guildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: guildInclude | null
    /**
     * Throw an Error if a guild can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which guild to fetch.
    **/
    where: guildWhereUniqueInput
  }


  /**
   * guild findFirst
   */
  export type guildFindFirstArgs = {
    /**
     * Select specific fields to fetch from the guild
    **/
    select?: guildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: guildInclude | null
    /**
     * Throw an Error if a guild can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which guild to fetch.
    **/
    where?: guildWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of guilds to fetch.
    **/
    orderBy?: Enumerable<guildOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guilds.
    **/
    cursor?: guildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guilds from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guilds.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of guilds.
    **/
    distinct?: Enumerable<GuildScalarFieldEnum>
  }


  /**
   * guild findMany
   */
  export type guildFindManyArgs = {
    /**
     * Select specific fields to fetch from the guild
    **/
    select?: guildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: guildInclude | null
    /**
     * Filter, which guilds to fetch.
    **/
    where?: guildWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of guilds to fetch.
    **/
    orderBy?: Enumerable<guildOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing guilds.
    **/
    cursor?: guildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guilds from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guilds.
    **/
    skip?: number
    distinct?: Enumerable<GuildScalarFieldEnum>
  }


  /**
   * guild create
   */
  export type guildCreateArgs = {
    /**
     * Select specific fields to fetch from the guild
    **/
    select?: guildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: guildInclude | null
    /**
     * The data needed to create a guild.
    **/
    data: XOR<guildUncheckedCreateInput, guildCreateInput>
  }


  /**
   * guild update
   */
  export type guildUpdateArgs = {
    /**
     * Select specific fields to fetch from the guild
    **/
    select?: guildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: guildInclude | null
    /**
     * The data needed to update a guild.
    **/
    data: XOR<guildUncheckedUpdateInput, guildUpdateInput>
    /**
     * Choose, which guild to update.
    **/
    where: guildWhereUniqueInput
  }


  /**
   * guild updateMany
   */
  export type guildUpdateManyArgs = {
    data: XOR<guildUncheckedUpdateManyInput, guildUpdateManyMutationInput>
    where?: guildWhereInput
  }


  /**
   * guild upsert
   */
  export type guildUpsertArgs = {
    /**
     * Select specific fields to fetch from the guild
    **/
    select?: guildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: guildInclude | null
    /**
     * The filter to search for the guild to update in case it exists.
    **/
    where: guildWhereUniqueInput
    /**
     * In case the guild found by the `where` argument doesn't exist, create a new guild with this data.
    **/
    create: XOR<guildUncheckedCreateInput, guildCreateInput>
    /**
     * In case the guild was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<guildUncheckedUpdateInput, guildUpdateInput>
  }


  /**
   * guild delete
   */
  export type guildDeleteArgs = {
    /**
     * Select specific fields to fetch from the guild
    **/
    select?: guildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: guildInclude | null
    /**
     * Filter which guild to delete.
    **/
    where: guildWhereUniqueInput
  }


  /**
   * guild deleteMany
   */
  export type guildDeleteManyArgs = {
    where?: guildWhereInput
  }


  /**
   * guild without action
   */
  export type guildArgs = {
    /**
     * Select specific fields to fetch from the guild
    **/
    select?: guildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: guildInclude | null
  }



  /**
   * Model UsersOnGuilds
   */


  export type AggregateUsersOnGuilds = {
    count: UsersOnGuildsCountAggregateOutputType | null
    avg: UsersOnGuildsAvgAggregateOutputType | null
    sum: UsersOnGuildsSumAggregateOutputType | null
    min: UsersOnGuildsMinAggregateOutputType | null
    max: UsersOnGuildsMaxAggregateOutputType | null
  }

  export type UsersOnGuildsAvgAggregateOutputType = {
    guildId: number
  }

  export type UsersOnGuildsSumAggregateOutputType = {
    guildId: number
  }

  export type UsersOnGuildsMinAggregateOutputType = {
    userId: string | null
    guildId: number
    createdAt: Date | null
  }

  export type UsersOnGuildsMaxAggregateOutputType = {
    userId: string | null
    guildId: number
    createdAt: Date | null
  }

  export type UsersOnGuildsCountAggregateOutputType = {
    userId: number | null
    guildId: number
    createdAt: number | null
    _all: number
  }


  export type UsersOnGuildsAvgAggregateInputType = {
    guildId?: true
  }

  export type UsersOnGuildsSumAggregateInputType = {
    guildId?: true
  }

  export type UsersOnGuildsMinAggregateInputType = {
    userId?: true
    guildId?: true
    createdAt?: true
  }

  export type UsersOnGuildsMaxAggregateInputType = {
    userId?: true
    guildId?: true
    createdAt?: true
  }

  export type UsersOnGuildsCountAggregateInputType = {
    userId?: true
    guildId?: true
    createdAt?: true
    _all?: true
  }

  export type UsersOnGuildsAggregateArgs = {
    /**
     * Filter which UsersOnGuilds to aggregate.
    **/
    where?: UsersOnGuildsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of UsersOnGuilds to fetch.
    **/
    orderBy?: Enumerable<UsersOnGuildsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UsersOnGuildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnGuilds from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnGuilds.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsersOnGuilds
    **/
    count?: true | UsersOnGuildsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: UsersOnGuildsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: UsersOnGuildsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UsersOnGuildsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UsersOnGuildsMaxAggregateInputType
  }

  export type GetUsersOnGuildsAggregateType<T extends UsersOnGuildsAggregateArgs> = {
    [P in keyof T & keyof AggregateUsersOnGuilds]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsersOnGuilds[P]>
      : GetScalarType<T[P], AggregateUsersOnGuilds[P]>
  }



  export type UsersOnGuildsSelect = {
    userId?: boolean
    guildId?: boolean
    createdAt?: boolean
    guild?: boolean | guildArgs
    user?: boolean | DiscordUserArgs
  }

  export type UsersOnGuildsInclude = {
    guild?: boolean | guildArgs
    user?: boolean | DiscordUserArgs
  }

  export type UsersOnGuildsGetPayload<
    S extends boolean | null | undefined | UsersOnGuildsArgs,
    U = keyof S
      > = S extends true
        ? UsersOnGuilds
    : S extends undefined
    ? never
    : S extends UsersOnGuildsArgs | UsersOnGuildsFindManyArgs
    ?'include' extends U
    ? UsersOnGuilds  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'guild'
        ? guildGetPayload<S['include'][P]> :
        P extends 'user'
        ? DiscordUserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UsersOnGuilds ?UsersOnGuilds [P]
  : 
          P extends 'guild'
        ? guildGetPayload<S['select'][P]> :
        P extends 'user'
        ? DiscordUserGetPayload<S['select'][P]> : never
  } 
    : UsersOnGuilds
  : UsersOnGuilds


  type UsersOnGuildsCountArgs = Merge<
    Omit<UsersOnGuildsFindManyArgs, 'select' | 'include'> & {
      select?: UsersOnGuildsCountAggregateInputType | true
    }
  >

  export interface UsersOnGuildsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UsersOnGuilds that matches the filter.
     * @param {UsersOnGuildsFindUniqueArgs} args - Arguments to find a UsersOnGuilds
     * @example
     * // Get one UsersOnGuilds
     * const usersOnGuilds = await prisma.usersOnGuilds.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsersOnGuildsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UsersOnGuildsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UsersOnGuilds'> extends True ? CheckSelect<T, Prisma__UsersOnGuildsClient<UsersOnGuilds>, Prisma__UsersOnGuildsClient<UsersOnGuildsGetPayload<T>>> : CheckSelect<T, Prisma__UsersOnGuildsClient<UsersOnGuilds | null >, Prisma__UsersOnGuildsClient<UsersOnGuildsGetPayload<T> | null >>

    /**
     * Find the first UsersOnGuilds that matches the filter.
     * @param {UsersOnGuildsFindFirstArgs} args - Arguments to find a UsersOnGuilds
     * @example
     * // Get one UsersOnGuilds
     * const usersOnGuilds = await prisma.usersOnGuilds.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsersOnGuildsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UsersOnGuildsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UsersOnGuilds'> extends True ? CheckSelect<T, Prisma__UsersOnGuildsClient<UsersOnGuilds>, Prisma__UsersOnGuildsClient<UsersOnGuildsGetPayload<T>>> : CheckSelect<T, Prisma__UsersOnGuildsClient<UsersOnGuilds | null >, Prisma__UsersOnGuildsClient<UsersOnGuildsGetPayload<T> | null >>

    /**
     * Find zero or more UsersOnGuilds that matches the filter.
     * @param {UsersOnGuildsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsersOnGuilds
     * const usersOnGuilds = await prisma.usersOnGuilds.findMany()
     * 
     * // Get first 10 UsersOnGuilds
     * const usersOnGuilds = await prisma.usersOnGuilds.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const usersOnGuildsWithUserIdOnly = await prisma.usersOnGuilds.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UsersOnGuildsFindManyArgs>(
      args?: SelectSubset<T, UsersOnGuildsFindManyArgs>
    ): CheckSelect<T, Promise<Array<UsersOnGuilds>>, Promise<Array<UsersOnGuildsGetPayload<T>>>>

    /**
     * Create a UsersOnGuilds.
     * @param {UsersOnGuildsCreateArgs} args - Arguments to create a UsersOnGuilds.
     * @example
     * // Create one UsersOnGuilds
     * const UsersOnGuilds = await prisma.usersOnGuilds.create({
     *   data: {
     *     // ... data to create a UsersOnGuilds
     *   }
     * })
     * 
    **/
    create<T extends UsersOnGuildsCreateArgs>(
      args: SelectSubset<T, UsersOnGuildsCreateArgs>
    ): CheckSelect<T, Prisma__UsersOnGuildsClient<UsersOnGuilds>, Prisma__UsersOnGuildsClient<UsersOnGuildsGetPayload<T>>>

    /**
     * Delete a UsersOnGuilds.
     * @param {UsersOnGuildsDeleteArgs} args - Arguments to delete one UsersOnGuilds.
     * @example
     * // Delete one UsersOnGuilds
     * const UsersOnGuilds = await prisma.usersOnGuilds.delete({
     *   where: {
     *     // ... filter to delete one UsersOnGuilds
     *   }
     * })
     * 
    **/
    delete<T extends UsersOnGuildsDeleteArgs>(
      args: SelectSubset<T, UsersOnGuildsDeleteArgs>
    ): CheckSelect<T, Prisma__UsersOnGuildsClient<UsersOnGuilds>, Prisma__UsersOnGuildsClient<UsersOnGuildsGetPayload<T>>>

    /**
     * Update one UsersOnGuilds.
     * @param {UsersOnGuildsUpdateArgs} args - Arguments to update one UsersOnGuilds.
     * @example
     * // Update one UsersOnGuilds
     * const usersOnGuilds = await prisma.usersOnGuilds.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsersOnGuildsUpdateArgs>(
      args: SelectSubset<T, UsersOnGuildsUpdateArgs>
    ): CheckSelect<T, Prisma__UsersOnGuildsClient<UsersOnGuilds>, Prisma__UsersOnGuildsClient<UsersOnGuildsGetPayload<T>>>

    /**
     * Delete zero or more UsersOnGuilds.
     * @param {UsersOnGuildsDeleteManyArgs} args - Arguments to filter UsersOnGuilds to delete.
     * @example
     * // Delete a few UsersOnGuilds
     * const { count } = await prisma.usersOnGuilds.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsersOnGuildsDeleteManyArgs>(
      args?: SelectSubset<T, UsersOnGuildsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more UsersOnGuilds.
     * @param {UsersOnGuildsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsersOnGuilds
     * const usersOnGuilds = await prisma.usersOnGuilds.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsersOnGuildsUpdateManyArgs>(
      args: SelectSubset<T, UsersOnGuildsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one UsersOnGuilds.
     * @param {UsersOnGuildsUpsertArgs} args - Arguments to update or create a UsersOnGuilds.
     * @example
     * // Update or create a UsersOnGuilds
     * const usersOnGuilds = await prisma.usersOnGuilds.upsert({
     *   create: {
     *     // ... data to create a UsersOnGuilds
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsersOnGuilds we want to update
     *   }
     * })
    **/
    upsert<T extends UsersOnGuildsUpsertArgs>(
      args: SelectSubset<T, UsersOnGuildsUpsertArgs>
    ): CheckSelect<T, Prisma__UsersOnGuildsClient<UsersOnGuilds>, Prisma__UsersOnGuildsClient<UsersOnGuildsGetPayload<T>>>

    /**
     * Count the number of UsersOnGuilds.
     * @param {UsersOnGuildsCountArgs} args - Arguments to filter UsersOnGuilds to count.
     * @example
     * // Count the number of UsersOnGuilds
     * const count = await prisma.usersOnGuilds.count({
     *   where: {
     *     // ... the filter for the UsersOnGuilds we want to count
     *   }
     * })
    **/
    count<T extends UsersOnGuildsCountArgs>(
      args?: Subset<T, UsersOnGuildsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersOnGuildsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsersOnGuilds.
     * @param {UsersOnGuildsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersOnGuildsAggregateArgs>(args: Subset<T, UsersOnGuildsAggregateArgs>): Promise<GetUsersOnGuildsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for UsersOnGuilds.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsersOnGuildsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    guild<T extends guildArgs = {}>(args?: Subset<T, guildArgs>): CheckSelect<T, Prisma__guildClient<guild | null >, Prisma__guildClient<guildGetPayload<T> | null >>;

    user<T extends DiscordUserArgs = {}>(args?: Subset<T, DiscordUserArgs>): CheckSelect<T, Prisma__DiscordUserClient<DiscordUser | null >, Prisma__DiscordUserClient<DiscordUserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UsersOnGuilds findUnique
   */
  export type UsersOnGuildsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UsersOnGuilds
    **/
    select?: UsersOnGuildsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersOnGuildsInclude | null
    /**
     * Throw an Error if a UsersOnGuilds can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UsersOnGuilds to fetch.
    **/
    where: UsersOnGuildsWhereUniqueInput
  }


  /**
   * UsersOnGuilds findFirst
   */
  export type UsersOnGuildsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UsersOnGuilds
    **/
    select?: UsersOnGuildsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersOnGuildsInclude | null
    /**
     * Throw an Error if a UsersOnGuilds can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UsersOnGuilds to fetch.
    **/
    where?: UsersOnGuildsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of UsersOnGuilds to fetch.
    **/
    orderBy?: Enumerable<UsersOnGuildsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersOnGuilds.
    **/
    cursor?: UsersOnGuildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnGuilds from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnGuilds.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of UsersOnGuilds.
    **/
    distinct?: Enumerable<UsersOnGuildsScalarFieldEnum>
  }


  /**
   * UsersOnGuilds findMany
   */
  export type UsersOnGuildsFindManyArgs = {
    /**
     * Select specific fields to fetch from the UsersOnGuilds
    **/
    select?: UsersOnGuildsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersOnGuildsInclude | null
    /**
     * Filter, which UsersOnGuilds to fetch.
    **/
    where?: UsersOnGuildsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of UsersOnGuilds to fetch.
    **/
    orderBy?: Enumerable<UsersOnGuildsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsersOnGuilds.
    **/
    cursor?: UsersOnGuildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnGuilds from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnGuilds.
    **/
    skip?: number
    distinct?: Enumerable<UsersOnGuildsScalarFieldEnum>
  }


  /**
   * UsersOnGuilds create
   */
  export type UsersOnGuildsCreateArgs = {
    /**
     * Select specific fields to fetch from the UsersOnGuilds
    **/
    select?: UsersOnGuildsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersOnGuildsInclude | null
    /**
     * The data needed to create a UsersOnGuilds.
    **/
    data: XOR<UsersOnGuildsUncheckedCreateInput, UsersOnGuildsCreateInput>
  }


  /**
   * UsersOnGuilds update
   */
  export type UsersOnGuildsUpdateArgs = {
    /**
     * Select specific fields to fetch from the UsersOnGuilds
    **/
    select?: UsersOnGuildsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersOnGuildsInclude | null
    /**
     * The data needed to update a UsersOnGuilds.
    **/
    data: XOR<UsersOnGuildsUncheckedUpdateInput, UsersOnGuildsUpdateInput>
    /**
     * Choose, which UsersOnGuilds to update.
    **/
    where: UsersOnGuildsWhereUniqueInput
  }


  /**
   * UsersOnGuilds updateMany
   */
  export type UsersOnGuildsUpdateManyArgs = {
    data: XOR<UsersOnGuildsUncheckedUpdateManyInput, UsersOnGuildsUpdateManyMutationInput>
    where?: UsersOnGuildsWhereInput
  }


  /**
   * UsersOnGuilds upsert
   */
  export type UsersOnGuildsUpsertArgs = {
    /**
     * Select specific fields to fetch from the UsersOnGuilds
    **/
    select?: UsersOnGuildsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersOnGuildsInclude | null
    /**
     * The filter to search for the UsersOnGuilds to update in case it exists.
    **/
    where: UsersOnGuildsWhereUniqueInput
    /**
     * In case the UsersOnGuilds found by the `where` argument doesn't exist, create a new UsersOnGuilds with this data.
    **/
    create: XOR<UsersOnGuildsUncheckedCreateInput, UsersOnGuildsCreateInput>
    /**
     * In case the UsersOnGuilds was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<UsersOnGuildsUncheckedUpdateInput, UsersOnGuildsUpdateInput>
  }


  /**
   * UsersOnGuilds delete
   */
  export type UsersOnGuildsDeleteArgs = {
    /**
     * Select specific fields to fetch from the UsersOnGuilds
    **/
    select?: UsersOnGuildsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersOnGuildsInclude | null
    /**
     * Filter which UsersOnGuilds to delete.
    **/
    where: UsersOnGuildsWhereUniqueInput
  }


  /**
   * UsersOnGuilds deleteMany
   */
  export type UsersOnGuildsDeleteManyArgs = {
    where?: UsersOnGuildsWhereInput
  }


  /**
   * UsersOnGuilds without action
   */
  export type UsersOnGuildsArgs = {
    /**
     * Select specific fields to fetch from the UsersOnGuilds
    **/
    select?: UsersOnGuildsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsersOnGuildsInclude | null
  }



  /**
   * Model AdminOnGuilds
   */


  export type AggregateAdminOnGuilds = {
    count: AdminOnGuildsCountAggregateOutputType | null
    avg: AdminOnGuildsAvgAggregateOutputType | null
    sum: AdminOnGuildsSumAggregateOutputType | null
    min: AdminOnGuildsMinAggregateOutputType | null
    max: AdminOnGuildsMaxAggregateOutputType | null
  }

  export type AdminOnGuildsAvgAggregateOutputType = {
    guildId: number
  }

  export type AdminOnGuildsSumAggregateOutputType = {
    guildId: number
  }

  export type AdminOnGuildsMinAggregateOutputType = {
    userId: string | null
    guildId: number
    createdAt: Date | null
  }

  export type AdminOnGuildsMaxAggregateOutputType = {
    userId: string | null
    guildId: number
    createdAt: Date | null
  }

  export type AdminOnGuildsCountAggregateOutputType = {
    userId: number | null
    guildId: number
    createdAt: number | null
    _all: number
  }


  export type AdminOnGuildsAvgAggregateInputType = {
    guildId?: true
  }

  export type AdminOnGuildsSumAggregateInputType = {
    guildId?: true
  }

  export type AdminOnGuildsMinAggregateInputType = {
    userId?: true
    guildId?: true
    createdAt?: true
  }

  export type AdminOnGuildsMaxAggregateInputType = {
    userId?: true
    guildId?: true
    createdAt?: true
  }

  export type AdminOnGuildsCountAggregateInputType = {
    userId?: true
    guildId?: true
    createdAt?: true
    _all?: true
  }

  export type AdminOnGuildsAggregateArgs = {
    /**
     * Filter which AdminOnGuilds to aggregate.
    **/
    where?: AdminOnGuildsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of AdminOnGuilds to fetch.
    **/
    orderBy?: Enumerable<AdminOnGuildsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AdminOnGuildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOnGuilds from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOnGuilds.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminOnGuilds
    **/
    count?: true | AdminOnGuildsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AdminOnGuildsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AdminOnGuildsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AdminOnGuildsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AdminOnGuildsMaxAggregateInputType
  }

  export type GetAdminOnGuildsAggregateType<T extends AdminOnGuildsAggregateArgs> = {
    [P in keyof T & keyof AggregateAdminOnGuilds]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminOnGuilds[P]>
      : GetScalarType<T[P], AggregateAdminOnGuilds[P]>
  }



  export type AdminOnGuildsSelect = {
    userId?: boolean
    guildId?: boolean
    createdAt?: boolean
    guild?: boolean | guildArgs
    user?: boolean | DiscordUserArgs
  }

  export type AdminOnGuildsInclude = {
    guild?: boolean | guildArgs
    user?: boolean | DiscordUserArgs
  }

  export type AdminOnGuildsGetPayload<
    S extends boolean | null | undefined | AdminOnGuildsArgs,
    U = keyof S
      > = S extends true
        ? AdminOnGuilds
    : S extends undefined
    ? never
    : S extends AdminOnGuildsArgs | AdminOnGuildsFindManyArgs
    ?'include' extends U
    ? AdminOnGuilds  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'guild'
        ? guildGetPayload<S['include'][P]> :
        P extends 'user'
        ? DiscordUserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AdminOnGuilds ?AdminOnGuilds [P]
  : 
          P extends 'guild'
        ? guildGetPayload<S['select'][P]> :
        P extends 'user'
        ? DiscordUserGetPayload<S['select'][P]> : never
  } 
    : AdminOnGuilds
  : AdminOnGuilds


  type AdminOnGuildsCountArgs = Merge<
    Omit<AdminOnGuildsFindManyArgs, 'select' | 'include'> & {
      select?: AdminOnGuildsCountAggregateInputType | true
    }
  >

  export interface AdminOnGuildsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AdminOnGuilds that matches the filter.
     * @param {AdminOnGuildsFindUniqueArgs} args - Arguments to find a AdminOnGuilds
     * @example
     * // Get one AdminOnGuilds
     * const adminOnGuilds = await prisma.adminOnGuilds.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminOnGuildsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AdminOnGuildsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AdminOnGuilds'> extends True ? CheckSelect<T, Prisma__AdminOnGuildsClient<AdminOnGuilds>, Prisma__AdminOnGuildsClient<AdminOnGuildsGetPayload<T>>> : CheckSelect<T, Prisma__AdminOnGuildsClient<AdminOnGuilds | null >, Prisma__AdminOnGuildsClient<AdminOnGuildsGetPayload<T> | null >>

    /**
     * Find the first AdminOnGuilds that matches the filter.
     * @param {AdminOnGuildsFindFirstArgs} args - Arguments to find a AdminOnGuilds
     * @example
     * // Get one AdminOnGuilds
     * const adminOnGuilds = await prisma.adminOnGuilds.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminOnGuildsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AdminOnGuildsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AdminOnGuilds'> extends True ? CheckSelect<T, Prisma__AdminOnGuildsClient<AdminOnGuilds>, Prisma__AdminOnGuildsClient<AdminOnGuildsGetPayload<T>>> : CheckSelect<T, Prisma__AdminOnGuildsClient<AdminOnGuilds | null >, Prisma__AdminOnGuildsClient<AdminOnGuildsGetPayload<T> | null >>

    /**
     * Find zero or more AdminOnGuilds that matches the filter.
     * @param {AdminOnGuildsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminOnGuilds
     * const adminOnGuilds = await prisma.adminOnGuilds.findMany()
     * 
     * // Get first 10 AdminOnGuilds
     * const adminOnGuilds = await prisma.adminOnGuilds.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const adminOnGuildsWithUserIdOnly = await prisma.adminOnGuilds.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends AdminOnGuildsFindManyArgs>(
      args?: SelectSubset<T, AdminOnGuildsFindManyArgs>
    ): CheckSelect<T, Promise<Array<AdminOnGuilds>>, Promise<Array<AdminOnGuildsGetPayload<T>>>>

    /**
     * Create a AdminOnGuilds.
     * @param {AdminOnGuildsCreateArgs} args - Arguments to create a AdminOnGuilds.
     * @example
     * // Create one AdminOnGuilds
     * const AdminOnGuilds = await prisma.adminOnGuilds.create({
     *   data: {
     *     // ... data to create a AdminOnGuilds
     *   }
     * })
     * 
    **/
    create<T extends AdminOnGuildsCreateArgs>(
      args: SelectSubset<T, AdminOnGuildsCreateArgs>
    ): CheckSelect<T, Prisma__AdminOnGuildsClient<AdminOnGuilds>, Prisma__AdminOnGuildsClient<AdminOnGuildsGetPayload<T>>>

    /**
     * Delete a AdminOnGuilds.
     * @param {AdminOnGuildsDeleteArgs} args - Arguments to delete one AdminOnGuilds.
     * @example
     * // Delete one AdminOnGuilds
     * const AdminOnGuilds = await prisma.adminOnGuilds.delete({
     *   where: {
     *     // ... filter to delete one AdminOnGuilds
     *   }
     * })
     * 
    **/
    delete<T extends AdminOnGuildsDeleteArgs>(
      args: SelectSubset<T, AdminOnGuildsDeleteArgs>
    ): CheckSelect<T, Prisma__AdminOnGuildsClient<AdminOnGuilds>, Prisma__AdminOnGuildsClient<AdminOnGuildsGetPayload<T>>>

    /**
     * Update one AdminOnGuilds.
     * @param {AdminOnGuildsUpdateArgs} args - Arguments to update one AdminOnGuilds.
     * @example
     * // Update one AdminOnGuilds
     * const adminOnGuilds = await prisma.adminOnGuilds.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminOnGuildsUpdateArgs>(
      args: SelectSubset<T, AdminOnGuildsUpdateArgs>
    ): CheckSelect<T, Prisma__AdminOnGuildsClient<AdminOnGuilds>, Prisma__AdminOnGuildsClient<AdminOnGuildsGetPayload<T>>>

    /**
     * Delete zero or more AdminOnGuilds.
     * @param {AdminOnGuildsDeleteManyArgs} args - Arguments to filter AdminOnGuilds to delete.
     * @example
     * // Delete a few AdminOnGuilds
     * const { count } = await prisma.adminOnGuilds.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminOnGuildsDeleteManyArgs>(
      args?: SelectSubset<T, AdminOnGuildsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more AdminOnGuilds.
     * @param {AdminOnGuildsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminOnGuilds
     * const adminOnGuilds = await prisma.adminOnGuilds.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminOnGuildsUpdateManyArgs>(
      args: SelectSubset<T, AdminOnGuildsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one AdminOnGuilds.
     * @param {AdminOnGuildsUpsertArgs} args - Arguments to update or create a AdminOnGuilds.
     * @example
     * // Update or create a AdminOnGuilds
     * const adminOnGuilds = await prisma.adminOnGuilds.upsert({
     *   create: {
     *     // ... data to create a AdminOnGuilds
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminOnGuilds we want to update
     *   }
     * })
    **/
    upsert<T extends AdminOnGuildsUpsertArgs>(
      args: SelectSubset<T, AdminOnGuildsUpsertArgs>
    ): CheckSelect<T, Prisma__AdminOnGuildsClient<AdminOnGuilds>, Prisma__AdminOnGuildsClient<AdminOnGuildsGetPayload<T>>>

    /**
     * Count the number of AdminOnGuilds.
     * @param {AdminOnGuildsCountArgs} args - Arguments to filter AdminOnGuilds to count.
     * @example
     * // Count the number of AdminOnGuilds
     * const count = await prisma.adminOnGuilds.count({
     *   where: {
     *     // ... the filter for the AdminOnGuilds we want to count
     *   }
     * })
    **/
    count<T extends AdminOnGuildsCountArgs>(
      args?: Subset<T, AdminOnGuildsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminOnGuildsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminOnGuilds.
     * @param {AdminOnGuildsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminOnGuildsAggregateArgs>(args: Subset<T, AdminOnGuildsAggregateArgs>): Promise<GetAdminOnGuildsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminOnGuilds.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AdminOnGuildsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    guild<T extends guildArgs = {}>(args?: Subset<T, guildArgs>): CheckSelect<T, Prisma__guildClient<guild | null >, Prisma__guildClient<guildGetPayload<T> | null >>;

    user<T extends DiscordUserArgs = {}>(args?: Subset<T, DiscordUserArgs>): CheckSelect<T, Prisma__DiscordUserClient<DiscordUser | null >, Prisma__DiscordUserClient<DiscordUserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AdminOnGuilds findUnique
   */
  export type AdminOnGuildsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AdminOnGuilds
    **/
    select?: AdminOnGuildsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminOnGuildsInclude | null
    /**
     * Throw an Error if a AdminOnGuilds can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AdminOnGuilds to fetch.
    **/
    where: AdminOnGuildsWhereUniqueInput
  }


  /**
   * AdminOnGuilds findFirst
   */
  export type AdminOnGuildsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AdminOnGuilds
    **/
    select?: AdminOnGuildsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminOnGuildsInclude | null
    /**
     * Throw an Error if a AdminOnGuilds can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AdminOnGuilds to fetch.
    **/
    where?: AdminOnGuildsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of AdminOnGuilds to fetch.
    **/
    orderBy?: Enumerable<AdminOnGuildsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminOnGuilds.
    **/
    cursor?: AdminOnGuildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOnGuilds from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOnGuilds.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of AdminOnGuilds.
    **/
    distinct?: Enumerable<AdminOnGuildsScalarFieldEnum>
  }


  /**
   * AdminOnGuilds findMany
   */
  export type AdminOnGuildsFindManyArgs = {
    /**
     * Select specific fields to fetch from the AdminOnGuilds
    **/
    select?: AdminOnGuildsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminOnGuildsInclude | null
    /**
     * Filter, which AdminOnGuilds to fetch.
    **/
    where?: AdminOnGuildsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of AdminOnGuilds to fetch.
    **/
    orderBy?: Enumerable<AdminOnGuildsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminOnGuilds.
    **/
    cursor?: AdminOnGuildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOnGuilds from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOnGuilds.
    **/
    skip?: number
    distinct?: Enumerable<AdminOnGuildsScalarFieldEnum>
  }


  /**
   * AdminOnGuilds create
   */
  export type AdminOnGuildsCreateArgs = {
    /**
     * Select specific fields to fetch from the AdminOnGuilds
    **/
    select?: AdminOnGuildsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminOnGuildsInclude | null
    /**
     * The data needed to create a AdminOnGuilds.
    **/
    data: XOR<AdminOnGuildsUncheckedCreateInput, AdminOnGuildsCreateInput>
  }


  /**
   * AdminOnGuilds update
   */
  export type AdminOnGuildsUpdateArgs = {
    /**
     * Select specific fields to fetch from the AdminOnGuilds
    **/
    select?: AdminOnGuildsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminOnGuildsInclude | null
    /**
     * The data needed to update a AdminOnGuilds.
    **/
    data: XOR<AdminOnGuildsUncheckedUpdateInput, AdminOnGuildsUpdateInput>
    /**
     * Choose, which AdminOnGuilds to update.
    **/
    where: AdminOnGuildsWhereUniqueInput
  }


  /**
   * AdminOnGuilds updateMany
   */
  export type AdminOnGuildsUpdateManyArgs = {
    data: XOR<AdminOnGuildsUncheckedUpdateManyInput, AdminOnGuildsUpdateManyMutationInput>
    where?: AdminOnGuildsWhereInput
  }


  /**
   * AdminOnGuilds upsert
   */
  export type AdminOnGuildsUpsertArgs = {
    /**
     * Select specific fields to fetch from the AdminOnGuilds
    **/
    select?: AdminOnGuildsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminOnGuildsInclude | null
    /**
     * The filter to search for the AdminOnGuilds to update in case it exists.
    **/
    where: AdminOnGuildsWhereUniqueInput
    /**
     * In case the AdminOnGuilds found by the `where` argument doesn't exist, create a new AdminOnGuilds with this data.
    **/
    create: XOR<AdminOnGuildsUncheckedCreateInput, AdminOnGuildsCreateInput>
    /**
     * In case the AdminOnGuilds was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AdminOnGuildsUncheckedUpdateInput, AdminOnGuildsUpdateInput>
  }


  /**
   * AdminOnGuilds delete
   */
  export type AdminOnGuildsDeleteArgs = {
    /**
     * Select specific fields to fetch from the AdminOnGuilds
    **/
    select?: AdminOnGuildsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminOnGuildsInclude | null
    /**
     * Filter which AdminOnGuilds to delete.
    **/
    where: AdminOnGuildsWhereUniqueInput
  }


  /**
   * AdminOnGuilds deleteMany
   */
  export type AdminOnGuildsDeleteManyArgs = {
    where?: AdminOnGuildsWhereInput
  }


  /**
   * AdminOnGuilds without action
   */
  export type AdminOnGuildsArgs = {
    /**
     * Select specific fields to fetch from the AdminOnGuilds
    **/
    select?: AdminOnGuildsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdminOnGuildsInclude | null
  }



  /**
   * Model Command
   */


  export type AggregateCommand = {
    count: CommandCountAggregateOutputType | null
    avg: CommandAvgAggregateOutputType | null
    sum: CommandSumAggregateOutputType | null
    min: CommandMinAggregateOutputType | null
    max: CommandMaxAggregateOutputType | null
  }

  export type CommandAvgAggregateOutputType = {
    version: number
    usage: number
    cost: number
  }

  export type CommandSumAggregateOutputType = {
    version: number
    usage: number
    cost: number
  }

  export type CommandMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    registeredAt: Date | null
    version: number
    usage: number
    cost: number
    type: DiscordExecutionType | null
    url: string | null
  }

  export type CommandMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    registeredAt: Date | null
    version: number
    usage: number
    cost: number
    type: DiscordExecutionType | null
    url: string | null
  }

  export type CommandCountAggregateOutputType = {
    id: number | null
    ownerId: number | null
    registeredAt: number | null
    version: number
    usage: number
    cost: number
    type: number | null
    url: number | null
    _all: number
  }


  export type CommandAvgAggregateInputType = {
    version?: true
    usage?: true
    cost?: true
  }

  export type CommandSumAggregateInputType = {
    version?: true
    usage?: true
    cost?: true
  }

  export type CommandMinAggregateInputType = {
    id?: true
    ownerId?: true
    registeredAt?: true
    version?: true
    usage?: true
    cost?: true
    type?: true
    url?: true
  }

  export type CommandMaxAggregateInputType = {
    id?: true
    ownerId?: true
    registeredAt?: true
    version?: true
    usage?: true
    cost?: true
    type?: true
    url?: true
  }

  export type CommandCountAggregateInputType = {
    id?: true
    ownerId?: true
    registeredAt?: true
    version?: true
    usage?: true
    cost?: true
    type?: true
    url?: true
    _all?: true
  }

  export type CommandAggregateArgs = {
    /**
     * Filter which Command to aggregate.
    **/
    where?: CommandWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Commands to fetch.
    **/
    orderBy?: Enumerable<CommandOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commands
    **/
    count?: true | CommandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommandMaxAggregateInputType
  }

  export type GetCommandAggregateType<T extends CommandAggregateArgs> = {
    [P in keyof T & keyof AggregateCommand]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommand[P]>
      : GetScalarType<T[P], AggregateCommand[P]>
  }



  export type CommandSelect = {
    id?: boolean
    ownerId?: boolean
    registeredAt?: boolean
    version?: boolean
    usage?: boolean
    cost?: boolean
    type?: boolean
    url?: boolean
    owner?: boolean | UserArgs
  }

  export type CommandInclude = {
    owner?: boolean | UserArgs
  }

  export type CommandGetPayload<
    S extends boolean | null | undefined | CommandArgs,
    U = keyof S
      > = S extends true
        ? Command
    : S extends undefined
    ? never
    : S extends CommandArgs | CommandFindManyArgs
    ?'include' extends U
    ? Command  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'owner'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Command ?Command [P]
  : 
          P extends 'owner'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Command
  : Command


  type CommandCountArgs = Merge<
    Omit<CommandFindManyArgs, 'select' | 'include'> & {
      select?: CommandCountAggregateInputType | true
    }
  >

  export interface CommandDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Command that matches the filter.
     * @param {CommandFindUniqueArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommandFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommandFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Command'> extends True ? CheckSelect<T, Prisma__CommandClient<Command>, Prisma__CommandClient<CommandGetPayload<T>>> : CheckSelect<T, Prisma__CommandClient<Command | null >, Prisma__CommandClient<CommandGetPayload<T> | null >>

    /**
     * Find the first Command that matches the filter.
     * @param {CommandFindFirstArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommandFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommandFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Command'> extends True ? CheckSelect<T, Prisma__CommandClient<Command>, Prisma__CommandClient<CommandGetPayload<T>>> : CheckSelect<T, Prisma__CommandClient<Command | null >, Prisma__CommandClient<CommandGetPayload<T> | null >>

    /**
     * Find zero or more Commands that matches the filter.
     * @param {CommandFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commands
     * const commands = await prisma.command.findMany()
     * 
     * // Get first 10 Commands
     * const commands = await prisma.command.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commandWithIdOnly = await prisma.command.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommandFindManyArgs>(
      args?: SelectSubset<T, CommandFindManyArgs>
    ): CheckSelect<T, Promise<Array<Command>>, Promise<Array<CommandGetPayload<T>>>>

    /**
     * Create a Command.
     * @param {CommandCreateArgs} args - Arguments to create a Command.
     * @example
     * // Create one Command
     * const Command = await prisma.command.create({
     *   data: {
     *     // ... data to create a Command
     *   }
     * })
     * 
    **/
    create<T extends CommandCreateArgs>(
      args: SelectSubset<T, CommandCreateArgs>
    ): CheckSelect<T, Prisma__CommandClient<Command>, Prisma__CommandClient<CommandGetPayload<T>>>

    /**
     * Delete a Command.
     * @param {CommandDeleteArgs} args - Arguments to delete one Command.
     * @example
     * // Delete one Command
     * const Command = await prisma.command.delete({
     *   where: {
     *     // ... filter to delete one Command
     *   }
     * })
     * 
    **/
    delete<T extends CommandDeleteArgs>(
      args: SelectSubset<T, CommandDeleteArgs>
    ): CheckSelect<T, Prisma__CommandClient<Command>, Prisma__CommandClient<CommandGetPayload<T>>>

    /**
     * Update one Command.
     * @param {CommandUpdateArgs} args - Arguments to update one Command.
     * @example
     * // Update one Command
     * const command = await prisma.command.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommandUpdateArgs>(
      args: SelectSubset<T, CommandUpdateArgs>
    ): CheckSelect<T, Prisma__CommandClient<Command>, Prisma__CommandClient<CommandGetPayload<T>>>

    /**
     * Delete zero or more Commands.
     * @param {CommandDeleteManyArgs} args - Arguments to filter Commands to delete.
     * @example
     * // Delete a few Commands
     * const { count } = await prisma.command.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommandDeleteManyArgs>(
      args?: SelectSubset<T, CommandDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Commands.
     * @param {CommandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commands
     * const command = await prisma.command.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommandUpdateManyArgs>(
      args: SelectSubset<T, CommandUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Command.
     * @param {CommandUpsertArgs} args - Arguments to update or create a Command.
     * @example
     * // Update or create a Command
     * const command = await prisma.command.upsert({
     *   create: {
     *     // ... data to create a Command
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Command we want to update
     *   }
     * })
    **/
    upsert<T extends CommandUpsertArgs>(
      args: SelectSubset<T, CommandUpsertArgs>
    ): CheckSelect<T, Prisma__CommandClient<Command>, Prisma__CommandClient<CommandGetPayload<T>>>

    /**
     * Count the number of Commands.
     * @param {CommandCountArgs} args - Arguments to filter Commands to count.
     * @example
     * // Count the number of Commands
     * const count = await prisma.command.count({
     *   where: {
     *     // ... the filter for the Commands we want to count
     *   }
     * })
    **/
    count<T extends CommandCountArgs>(
      args?: Subset<T, CommandCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Command.
     * @param {CommandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandAggregateArgs>(args: Subset<T, CommandAggregateArgs>): Promise<GetCommandAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Command.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommandClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    owner<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Command findUnique
   */
  export type CommandFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Command
    **/
    select?: CommandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommandInclude | null
    /**
     * Throw an Error if a Command can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Command to fetch.
    **/
    where: CommandWhereUniqueInput
  }


  /**
   * Command findFirst
   */
  export type CommandFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Command
    **/
    select?: CommandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommandInclude | null
    /**
     * Throw an Error if a Command can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Command to fetch.
    **/
    where?: CommandWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Commands to fetch.
    **/
    orderBy?: Enumerable<CommandOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commands.
    **/
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Commands.
    **/
    distinct?: Enumerable<CommandScalarFieldEnum>
  }


  /**
   * Command findMany
   */
  export type CommandFindManyArgs = {
    /**
     * Select specific fields to fetch from the Command
    **/
    select?: CommandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommandInclude | null
    /**
     * Filter, which Commands to fetch.
    **/
    where?: CommandWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Commands to fetch.
    **/
    orderBy?: Enumerable<CommandOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commands.
    **/
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
    **/
    skip?: number
    distinct?: Enumerable<CommandScalarFieldEnum>
  }


  /**
   * Command create
   */
  export type CommandCreateArgs = {
    /**
     * Select specific fields to fetch from the Command
    **/
    select?: CommandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommandInclude | null
    /**
     * The data needed to create a Command.
    **/
    data: XOR<CommandUncheckedCreateInput, CommandCreateInput>
  }


  /**
   * Command update
   */
  export type CommandUpdateArgs = {
    /**
     * Select specific fields to fetch from the Command
    **/
    select?: CommandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommandInclude | null
    /**
     * The data needed to update a Command.
    **/
    data: XOR<CommandUncheckedUpdateInput, CommandUpdateInput>
    /**
     * Choose, which Command to update.
    **/
    where: CommandWhereUniqueInput
  }


  /**
   * Command updateMany
   */
  export type CommandUpdateManyArgs = {
    data: XOR<CommandUncheckedUpdateManyInput, CommandUpdateManyMutationInput>
    where?: CommandWhereInput
  }


  /**
   * Command upsert
   */
  export type CommandUpsertArgs = {
    /**
     * Select specific fields to fetch from the Command
    **/
    select?: CommandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommandInclude | null
    /**
     * The filter to search for the Command to update in case it exists.
    **/
    where: CommandWhereUniqueInput
    /**
     * In case the Command found by the `where` argument doesn't exist, create a new Command with this data.
    **/
    create: XOR<CommandUncheckedCreateInput, CommandCreateInput>
    /**
     * In case the Command was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommandUncheckedUpdateInput, CommandUpdateInput>
  }


  /**
   * Command delete
   */
  export type CommandDeleteArgs = {
    /**
     * Select specific fields to fetch from the Command
    **/
    select?: CommandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommandInclude | null
    /**
     * Filter which Command to delete.
    **/
    where: CommandWhereUniqueInput
  }


  /**
   * Command deleteMany
   */
  export type CommandDeleteManyArgs = {
    where?: CommandWhereInput
  }


  /**
   * Command without action
   */
  export type CommandArgs = {
    /**
     * Select specific fields to fetch from the Command
    **/
    select?: CommandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommandInclude | null
  }



  /**
   * Model Action
   */


  export type AggregateAction = {
    count: ActionCountAggregateOutputType | null
    avg: ActionAvgAggregateOutputType | null
    sum: ActionSumAggregateOutputType | null
    min: ActionMinAggregateOutputType | null
    max: ActionMaxAggregateOutputType | null
  }

  export type ActionAvgAggregateOutputType = {
    id: number
    version: number
    usage: number
    cost: number
  }

  export type ActionSumAggregateOutputType = {
    id: number
    version: number
    usage: number
    cost: number
  }

  export type ActionMinAggregateOutputType = {
    id: number
    ownerId: string | null
    registeredAt: Date | null
    version: number
    usage: number
    cost: number
    type: DiscordExecutionType | null
    url: string | null
  }

  export type ActionMaxAggregateOutputType = {
    id: number
    ownerId: string | null
    registeredAt: Date | null
    version: number
    usage: number
    cost: number
    type: DiscordExecutionType | null
    url: string | null
  }

  export type ActionCountAggregateOutputType = {
    id: number
    ownerId: number | null
    registeredAt: number | null
    version: number
    usage: number
    cost: number
    type: number | null
    url: number | null
    _all: number
  }


  export type ActionAvgAggregateInputType = {
    id?: true
    version?: true
    usage?: true
    cost?: true
  }

  export type ActionSumAggregateInputType = {
    id?: true
    version?: true
    usage?: true
    cost?: true
  }

  export type ActionMinAggregateInputType = {
    id?: true
    ownerId?: true
    registeredAt?: true
    version?: true
    usage?: true
    cost?: true
    type?: true
    url?: true
  }

  export type ActionMaxAggregateInputType = {
    id?: true
    ownerId?: true
    registeredAt?: true
    version?: true
    usage?: true
    cost?: true
    type?: true
    url?: true
  }

  export type ActionCountAggregateInputType = {
    id?: true
    ownerId?: true
    registeredAt?: true
    version?: true
    usage?: true
    cost?: true
    type?: true
    url?: true
    _all?: true
  }

  export type ActionAggregateArgs = {
    /**
     * Filter which Action to aggregate.
    **/
    where?: ActionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Actions to fetch.
    **/
    orderBy?: Enumerable<ActionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actions
    **/
    count?: true | ActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ActionMaxAggregateInputType
  }

  export type GetActionAggregateType<T extends ActionAggregateArgs> = {
    [P in keyof T & keyof AggregateAction]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAction[P]>
      : GetScalarType<T[P], AggregateAction[P]>
  }



  export type ActionSelect = {
    id?: boolean
    ownerId?: boolean
    registeredAt?: boolean
    version?: boolean
    usage?: boolean
    cost?: boolean
    type?: boolean
    url?: boolean
    owner?: boolean | UserArgs
  }

  export type ActionInclude = {
    owner?: boolean | UserArgs
  }

  export type ActionGetPayload<
    S extends boolean | null | undefined | ActionArgs,
    U = keyof S
      > = S extends true
        ? Action
    : S extends undefined
    ? never
    : S extends ActionArgs | ActionFindManyArgs
    ?'include' extends U
    ? Action  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'owner'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Action ?Action [P]
  : 
          P extends 'owner'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Action
  : Action


  type ActionCountArgs = Merge<
    Omit<ActionFindManyArgs, 'select' | 'include'> & {
      select?: ActionCountAggregateInputType | true
    }
  >

  export interface ActionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Action that matches the filter.
     * @param {ActionFindUniqueArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ActionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Action'> extends True ? CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>> : CheckSelect<T, Prisma__ActionClient<Action | null >, Prisma__ActionClient<ActionGetPayload<T> | null >>

    /**
     * Find the first Action that matches the filter.
     * @param {ActionFindFirstArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ActionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Action'> extends True ? CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>> : CheckSelect<T, Prisma__ActionClient<Action | null >, Prisma__ActionClient<ActionGetPayload<T> | null >>

    /**
     * Find zero or more Actions that matches the filter.
     * @param {ActionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actions
     * const actions = await prisma.action.findMany()
     * 
     * // Get first 10 Actions
     * const actions = await prisma.action.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionWithIdOnly = await prisma.action.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ActionFindManyArgs>(
      args?: SelectSubset<T, ActionFindManyArgs>
    ): CheckSelect<T, Promise<Array<Action>>, Promise<Array<ActionGetPayload<T>>>>

    /**
     * Create a Action.
     * @param {ActionCreateArgs} args - Arguments to create a Action.
     * @example
     * // Create one Action
     * const Action = await prisma.action.create({
     *   data: {
     *     // ... data to create a Action
     *   }
     * })
     * 
    **/
    create<T extends ActionCreateArgs>(
      args: SelectSubset<T, ActionCreateArgs>
    ): CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>>

    /**
     * Delete a Action.
     * @param {ActionDeleteArgs} args - Arguments to delete one Action.
     * @example
     * // Delete one Action
     * const Action = await prisma.action.delete({
     *   where: {
     *     // ... filter to delete one Action
     *   }
     * })
     * 
    **/
    delete<T extends ActionDeleteArgs>(
      args: SelectSubset<T, ActionDeleteArgs>
    ): CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>>

    /**
     * Update one Action.
     * @param {ActionUpdateArgs} args - Arguments to update one Action.
     * @example
     * // Update one Action
     * const action = await prisma.action.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActionUpdateArgs>(
      args: SelectSubset<T, ActionUpdateArgs>
    ): CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>>

    /**
     * Delete zero or more Actions.
     * @param {ActionDeleteManyArgs} args - Arguments to filter Actions to delete.
     * @example
     * // Delete a few Actions
     * const { count } = await prisma.action.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActionDeleteManyArgs>(
      args?: SelectSubset<T, ActionDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Actions.
     * @param {ActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actions
     * const action = await prisma.action.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActionUpdateManyArgs>(
      args: SelectSubset<T, ActionUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Action.
     * @param {ActionUpsertArgs} args - Arguments to update or create a Action.
     * @example
     * // Update or create a Action
     * const action = await prisma.action.upsert({
     *   create: {
     *     // ... data to create a Action
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Action we want to update
     *   }
     * })
    **/
    upsert<T extends ActionUpsertArgs>(
      args: SelectSubset<T, ActionUpsertArgs>
    ): CheckSelect<T, Prisma__ActionClient<Action>, Prisma__ActionClient<ActionGetPayload<T>>>

    /**
     * Count the number of Actions.
     * @param {ActionCountArgs} args - Arguments to filter Actions to count.
     * @example
     * // Count the number of Actions
     * const count = await prisma.action.count({
     *   where: {
     *     // ... the filter for the Actions we want to count
     *   }
     * })
    **/
    count<T extends ActionCountArgs>(
      args?: Subset<T, ActionCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Action.
     * @param {ActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionAggregateArgs>(args: Subset<T, ActionAggregateArgs>): Promise<GetActionAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Action.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ActionClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    owner<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Action findUnique
   */
  export type ActionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Action
    **/
    select?: ActionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ActionInclude | null
    /**
     * Throw an Error if a Action can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Action to fetch.
    **/
    where: ActionWhereUniqueInput
  }


  /**
   * Action findFirst
   */
  export type ActionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Action
    **/
    select?: ActionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ActionInclude | null
    /**
     * Throw an Error if a Action can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Action to fetch.
    **/
    where?: ActionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Actions to fetch.
    **/
    orderBy?: Enumerable<ActionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
    **/
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Actions.
    **/
    distinct?: Enumerable<ActionScalarFieldEnum>
  }


  /**
   * Action findMany
   */
  export type ActionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Action
    **/
    select?: ActionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ActionInclude | null
    /**
     * Filter, which Actions to fetch.
    **/
    where?: ActionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Actions to fetch.
    **/
    orderBy?: Enumerable<ActionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actions.
    **/
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
    **/
    skip?: number
    distinct?: Enumerable<ActionScalarFieldEnum>
  }


  /**
   * Action create
   */
  export type ActionCreateArgs = {
    /**
     * Select specific fields to fetch from the Action
    **/
    select?: ActionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ActionInclude | null
    /**
     * The data needed to create a Action.
    **/
    data: XOR<ActionUncheckedCreateInput, ActionCreateInput>
  }


  /**
   * Action update
   */
  export type ActionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Action
    **/
    select?: ActionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ActionInclude | null
    /**
     * The data needed to update a Action.
    **/
    data: XOR<ActionUncheckedUpdateInput, ActionUpdateInput>
    /**
     * Choose, which Action to update.
    **/
    where: ActionWhereUniqueInput
  }


  /**
   * Action updateMany
   */
  export type ActionUpdateManyArgs = {
    data: XOR<ActionUncheckedUpdateManyInput, ActionUpdateManyMutationInput>
    where?: ActionWhereInput
  }


  /**
   * Action upsert
   */
  export type ActionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Action
    **/
    select?: ActionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ActionInclude | null
    /**
     * The filter to search for the Action to update in case it exists.
    **/
    where: ActionWhereUniqueInput
    /**
     * In case the Action found by the `where` argument doesn't exist, create a new Action with this data.
    **/
    create: XOR<ActionUncheckedCreateInput, ActionCreateInput>
    /**
     * In case the Action was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ActionUncheckedUpdateInput, ActionUpdateInput>
  }


  /**
   * Action delete
   */
  export type ActionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Action
    **/
    select?: ActionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ActionInclude | null
    /**
     * Filter which Action to delete.
    **/
    where: ActionWhereUniqueInput
  }


  /**
   * Action deleteMany
   */
  export type ActionDeleteManyArgs = {
    where?: ActionWhereInput
  }


  /**
   * Action without action
   */
  export type ActionArgs = {
    /**
     * Select specific fields to fetch from the Action
    **/
    select?: ActionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ActionInclude | null
  }



  /**
   * Model TwitchUser
   */


  export type AggregateTwitchUser = {
    count: TwitchUserCountAggregateOutputType | null
    avg: TwitchUserAvgAggregateOutputType | null
    sum: TwitchUserSumAggregateOutputType | null
    min: TwitchUserMinAggregateOutputType | null
    max: TwitchUserMaxAggregateOutputType | null
  }

  export type TwitchUserAvgAggregateOutputType = {
    id: number
  }

  export type TwitchUserSumAggregateOutputType = {
    id: number
  }

  export type TwitchUserMinAggregateOutputType = {
    id: number
    username: string | null
    accessToken: string | null
    refreshToken: string | null
    userId: string | null
  }

  export type TwitchUserMaxAggregateOutputType = {
    id: number
    username: string | null
    accessToken: string | null
    refreshToken: string | null
    userId: string | null
  }

  export type TwitchUserCountAggregateOutputType = {
    id: number
    username: number | null
    accessToken: number | null
    refreshToken: number | null
    userId: number | null
    _all: number
  }


  export type TwitchUserAvgAggregateInputType = {
    id?: true
  }

  export type TwitchUserSumAggregateInputType = {
    id?: true
  }

  export type TwitchUserMinAggregateInputType = {
    id?: true
    username?: true
    accessToken?: true
    refreshToken?: true
    userId?: true
  }

  export type TwitchUserMaxAggregateInputType = {
    id?: true
    username?: true
    accessToken?: true
    refreshToken?: true
    userId?: true
  }

  export type TwitchUserCountAggregateInputType = {
    id?: true
    username?: true
    accessToken?: true
    refreshToken?: true
    userId?: true
    _all?: true
  }

  export type TwitchUserAggregateArgs = {
    /**
     * Filter which TwitchUser to aggregate.
    **/
    where?: TwitchUserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TwitchUsers to fetch.
    **/
    orderBy?: Enumerable<TwitchUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: TwitchUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitchUsers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitchUsers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitchUsers
    **/
    count?: true | TwitchUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TwitchUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TwitchUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TwitchUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TwitchUserMaxAggregateInputType
  }

  export type GetTwitchUserAggregateType<T extends TwitchUserAggregateArgs> = {
    [P in keyof T & keyof AggregateTwitchUser]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitchUser[P]>
      : GetScalarType<T[P], AggregateTwitchUser[P]>
  }



  export type TwitchUserSelect = {
    id?: boolean
    username?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    userId?: boolean
    user?: boolean | UserArgs
  }

  export type TwitchUserInclude = {
    user?: boolean | UserArgs
  }

  export type TwitchUserGetPayload<
    S extends boolean | null | undefined | TwitchUserArgs,
    U = keyof S
      > = S extends true
        ? TwitchUser
    : S extends undefined
    ? never
    : S extends TwitchUserArgs | TwitchUserFindManyArgs
    ?'include' extends U
    ? TwitchUser  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TwitchUser ?TwitchUser [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> | null : never
  } 
    : TwitchUser
  : TwitchUser


  type TwitchUserCountArgs = Merge<
    Omit<TwitchUserFindManyArgs, 'select' | 'include'> & {
      select?: TwitchUserCountAggregateInputType | true
    }
  >

  export interface TwitchUserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TwitchUser that matches the filter.
     * @param {TwitchUserFindUniqueArgs} args - Arguments to find a TwitchUser
     * @example
     * // Get one TwitchUser
     * const twitchUser = await prisma.twitchUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitchUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitchUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitchUser'> extends True ? CheckSelect<T, Prisma__TwitchUserClient<TwitchUser>, Prisma__TwitchUserClient<TwitchUserGetPayload<T>>> : CheckSelect<T, Prisma__TwitchUserClient<TwitchUser | null >, Prisma__TwitchUserClient<TwitchUserGetPayload<T> | null >>

    /**
     * Find the first TwitchUser that matches the filter.
     * @param {TwitchUserFindFirstArgs} args - Arguments to find a TwitchUser
     * @example
     * // Get one TwitchUser
     * const twitchUser = await prisma.twitchUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitchUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitchUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitchUser'> extends True ? CheckSelect<T, Prisma__TwitchUserClient<TwitchUser>, Prisma__TwitchUserClient<TwitchUserGetPayload<T>>> : CheckSelect<T, Prisma__TwitchUserClient<TwitchUser | null >, Prisma__TwitchUserClient<TwitchUserGetPayload<T> | null >>

    /**
     * Find zero or more TwitchUsers that matches the filter.
     * @param {TwitchUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitchUsers
     * const twitchUsers = await prisma.twitchUser.findMany()
     * 
     * // Get first 10 TwitchUsers
     * const twitchUsers = await prisma.twitchUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitchUserWithIdOnly = await prisma.twitchUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitchUserFindManyArgs>(
      args?: SelectSubset<T, TwitchUserFindManyArgs>
    ): CheckSelect<T, Promise<Array<TwitchUser>>, Promise<Array<TwitchUserGetPayload<T>>>>

    /**
     * Create a TwitchUser.
     * @param {TwitchUserCreateArgs} args - Arguments to create a TwitchUser.
     * @example
     * // Create one TwitchUser
     * const TwitchUser = await prisma.twitchUser.create({
     *   data: {
     *     // ... data to create a TwitchUser
     *   }
     * })
     * 
    **/
    create<T extends TwitchUserCreateArgs>(
      args: SelectSubset<T, TwitchUserCreateArgs>
    ): CheckSelect<T, Prisma__TwitchUserClient<TwitchUser>, Prisma__TwitchUserClient<TwitchUserGetPayload<T>>>

    /**
     * Delete a TwitchUser.
     * @param {TwitchUserDeleteArgs} args - Arguments to delete one TwitchUser.
     * @example
     * // Delete one TwitchUser
     * const TwitchUser = await prisma.twitchUser.delete({
     *   where: {
     *     // ... filter to delete one TwitchUser
     *   }
     * })
     * 
    **/
    delete<T extends TwitchUserDeleteArgs>(
      args: SelectSubset<T, TwitchUserDeleteArgs>
    ): CheckSelect<T, Prisma__TwitchUserClient<TwitchUser>, Prisma__TwitchUserClient<TwitchUserGetPayload<T>>>

    /**
     * Update one TwitchUser.
     * @param {TwitchUserUpdateArgs} args - Arguments to update one TwitchUser.
     * @example
     * // Update one TwitchUser
     * const twitchUser = await prisma.twitchUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitchUserUpdateArgs>(
      args: SelectSubset<T, TwitchUserUpdateArgs>
    ): CheckSelect<T, Prisma__TwitchUserClient<TwitchUser>, Prisma__TwitchUserClient<TwitchUserGetPayload<T>>>

    /**
     * Delete zero or more TwitchUsers.
     * @param {TwitchUserDeleteManyArgs} args - Arguments to filter TwitchUsers to delete.
     * @example
     * // Delete a few TwitchUsers
     * const { count } = await prisma.twitchUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitchUserDeleteManyArgs>(
      args?: SelectSubset<T, TwitchUserDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more TwitchUsers.
     * @param {TwitchUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitchUsers
     * const twitchUser = await prisma.twitchUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitchUserUpdateManyArgs>(
      args: SelectSubset<T, TwitchUserUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one TwitchUser.
     * @param {TwitchUserUpsertArgs} args - Arguments to update or create a TwitchUser.
     * @example
     * // Update or create a TwitchUser
     * const twitchUser = await prisma.twitchUser.upsert({
     *   create: {
     *     // ... data to create a TwitchUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitchUser we want to update
     *   }
     * })
    **/
    upsert<T extends TwitchUserUpsertArgs>(
      args: SelectSubset<T, TwitchUserUpsertArgs>
    ): CheckSelect<T, Prisma__TwitchUserClient<TwitchUser>, Prisma__TwitchUserClient<TwitchUserGetPayload<T>>>

    /**
     * Count the number of TwitchUsers.
     * @param {TwitchUserCountArgs} args - Arguments to filter TwitchUsers to count.
     * @example
     * // Count the number of TwitchUsers
     * const count = await prisma.twitchUser.count({
     *   where: {
     *     // ... the filter for the TwitchUsers we want to count
     *   }
     * })
    **/
    count<T extends TwitchUserCountArgs>(
      args?: Subset<T, TwitchUserCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitchUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitchUser.
     * @param {TwitchUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitchUserAggregateArgs>(args: Subset<T, TwitchUserAggregateArgs>): Promise<GetTwitchUserAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitchUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitchUserClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TwitchUser findUnique
   */
  export type TwitchUserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TwitchUser
    **/
    select?: TwitchUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitchUserInclude | null
    /**
     * Throw an Error if a TwitchUser can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TwitchUser to fetch.
    **/
    where: TwitchUserWhereUniqueInput
  }


  /**
   * TwitchUser findFirst
   */
  export type TwitchUserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TwitchUser
    **/
    select?: TwitchUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitchUserInclude | null
    /**
     * Throw an Error if a TwitchUser can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TwitchUser to fetch.
    **/
    where?: TwitchUserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TwitchUsers to fetch.
    **/
    orderBy?: Enumerable<TwitchUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitchUsers.
    **/
    cursor?: TwitchUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitchUsers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitchUsers.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of TwitchUsers.
    **/
    distinct?: Enumerable<TwitchUserScalarFieldEnum>
  }


  /**
   * TwitchUser findMany
   */
  export type TwitchUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitchUser
    **/
    select?: TwitchUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitchUserInclude | null
    /**
     * Filter, which TwitchUsers to fetch.
    **/
    where?: TwitchUserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TwitchUsers to fetch.
    **/
    orderBy?: Enumerable<TwitchUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitchUsers.
    **/
    cursor?: TwitchUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitchUsers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitchUsers.
    **/
    skip?: number
    distinct?: Enumerable<TwitchUserScalarFieldEnum>
  }


  /**
   * TwitchUser create
   */
  export type TwitchUserCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitchUser
    **/
    select?: TwitchUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitchUserInclude | null
    /**
     * The data needed to create a TwitchUser.
    **/
    data: XOR<TwitchUserUncheckedCreateInput, TwitchUserCreateInput>
  }


  /**
   * TwitchUser update
   */
  export type TwitchUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitchUser
    **/
    select?: TwitchUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitchUserInclude | null
    /**
     * The data needed to update a TwitchUser.
    **/
    data: XOR<TwitchUserUncheckedUpdateInput, TwitchUserUpdateInput>
    /**
     * Choose, which TwitchUser to update.
    **/
    where: TwitchUserWhereUniqueInput
  }


  /**
   * TwitchUser updateMany
   */
  export type TwitchUserUpdateManyArgs = {
    data: XOR<TwitchUserUncheckedUpdateManyInput, TwitchUserUpdateManyMutationInput>
    where?: TwitchUserWhereInput
  }


  /**
   * TwitchUser upsert
   */
  export type TwitchUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitchUser
    **/
    select?: TwitchUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitchUserInclude | null
    /**
     * The filter to search for the TwitchUser to update in case it exists.
    **/
    where: TwitchUserWhereUniqueInput
    /**
     * In case the TwitchUser found by the `where` argument doesn't exist, create a new TwitchUser with this data.
    **/
    create: XOR<TwitchUserUncheckedCreateInput, TwitchUserCreateInput>
    /**
     * In case the TwitchUser was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<TwitchUserUncheckedUpdateInput, TwitchUserUpdateInput>
  }


  /**
   * TwitchUser delete
   */
  export type TwitchUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitchUser
    **/
    select?: TwitchUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitchUserInclude | null
    /**
     * Filter which TwitchUser to delete.
    **/
    where: TwitchUserWhereUniqueInput
  }


  /**
   * TwitchUser deleteMany
   */
  export type TwitchUserDeleteManyArgs = {
    where?: TwitchUserWhereInput
  }


  /**
   * TwitchUser without action
   */
  export type TwitchUserArgs = {
    /**
     * Select specific fields to fetch from the TwitchUser
    **/
    select?: TwitchUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitchUserInclude | null
  }



  /**
   * Model TwitchAuth
   */


  export type AggregateTwitchAuth = {
    count: TwitchAuthCountAggregateOutputType | null
    avg: TwitchAuthAvgAggregateOutputType | null
    sum: TwitchAuthSumAggregateOutputType | null
    min: TwitchAuthMinAggregateOutputType | null
    max: TwitchAuthMaxAggregateOutputType | null
  }

  export type TwitchAuthAvgAggregateOutputType = {
    id: number
  }

  export type TwitchAuthSumAggregateOutputType = {
    id: number
  }

  export type TwitchAuthMinAggregateOutputType = {
    id: number
    clientID: string | null
    twitchSecret: string | null
    sessionSecret: string | null
  }

  export type TwitchAuthMaxAggregateOutputType = {
    id: number
    clientID: string | null
    twitchSecret: string | null
    sessionSecret: string | null
  }

  export type TwitchAuthCountAggregateOutputType = {
    id: number
    clientID: number | null
    twitchSecret: number | null
    sessionSecret: number | null
    _all: number
  }


  export type TwitchAuthAvgAggregateInputType = {
    id?: true
  }

  export type TwitchAuthSumAggregateInputType = {
    id?: true
  }

  export type TwitchAuthMinAggregateInputType = {
    id?: true
    clientID?: true
    twitchSecret?: true
    sessionSecret?: true
  }

  export type TwitchAuthMaxAggregateInputType = {
    id?: true
    clientID?: true
    twitchSecret?: true
    sessionSecret?: true
  }

  export type TwitchAuthCountAggregateInputType = {
    id?: true
    clientID?: true
    twitchSecret?: true
    sessionSecret?: true
    _all?: true
  }

  export type TwitchAuthAggregateArgs = {
    /**
     * Filter which TwitchAuth to aggregate.
    **/
    where?: TwitchAuthWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TwitchAuths to fetch.
    **/
    orderBy?: Enumerable<TwitchAuthOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: TwitchAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitchAuths from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitchAuths.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitchAuths
    **/
    count?: true | TwitchAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TwitchAuthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TwitchAuthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TwitchAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TwitchAuthMaxAggregateInputType
  }

  export type GetTwitchAuthAggregateType<T extends TwitchAuthAggregateArgs> = {
    [P in keyof T & keyof AggregateTwitchAuth]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitchAuth[P]>
      : GetScalarType<T[P], AggregateTwitchAuth[P]>
  }



  export type TwitchAuthSelect = {
    id?: boolean
    clientID?: boolean
    twitchSecret?: boolean
    sessionSecret?: boolean
    Bot?: boolean | BotFindManyArgs
  }

  export type TwitchAuthInclude = {
    Bot?: boolean | BotFindManyArgs
  }

  export type TwitchAuthGetPayload<
    S extends boolean | null | undefined | TwitchAuthArgs,
    U = keyof S
      > = S extends true
        ? TwitchAuth
    : S extends undefined
    ? never
    : S extends TwitchAuthArgs | TwitchAuthFindManyArgs
    ?'include' extends U
    ? TwitchAuth  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Bot'
        ? Array < BotGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TwitchAuth ?TwitchAuth [P]
  : 
          P extends 'Bot'
        ? Array < BotGetPayload<S['select'][P]>>  : never
  } 
    : TwitchAuth
  : TwitchAuth


  type TwitchAuthCountArgs = Merge<
    Omit<TwitchAuthFindManyArgs, 'select' | 'include'> & {
      select?: TwitchAuthCountAggregateInputType | true
    }
  >

  export interface TwitchAuthDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TwitchAuth that matches the filter.
     * @param {TwitchAuthFindUniqueArgs} args - Arguments to find a TwitchAuth
     * @example
     * // Get one TwitchAuth
     * const twitchAuth = await prisma.twitchAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitchAuthFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitchAuthFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitchAuth'> extends True ? CheckSelect<T, Prisma__TwitchAuthClient<TwitchAuth>, Prisma__TwitchAuthClient<TwitchAuthGetPayload<T>>> : CheckSelect<T, Prisma__TwitchAuthClient<TwitchAuth | null >, Prisma__TwitchAuthClient<TwitchAuthGetPayload<T> | null >>

    /**
     * Find the first TwitchAuth that matches the filter.
     * @param {TwitchAuthFindFirstArgs} args - Arguments to find a TwitchAuth
     * @example
     * // Get one TwitchAuth
     * const twitchAuth = await prisma.twitchAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitchAuthFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitchAuthFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitchAuth'> extends True ? CheckSelect<T, Prisma__TwitchAuthClient<TwitchAuth>, Prisma__TwitchAuthClient<TwitchAuthGetPayload<T>>> : CheckSelect<T, Prisma__TwitchAuthClient<TwitchAuth | null >, Prisma__TwitchAuthClient<TwitchAuthGetPayload<T> | null >>

    /**
     * Find zero or more TwitchAuths that matches the filter.
     * @param {TwitchAuthFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitchAuths
     * const twitchAuths = await prisma.twitchAuth.findMany()
     * 
     * // Get first 10 TwitchAuths
     * const twitchAuths = await prisma.twitchAuth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitchAuthWithIdOnly = await prisma.twitchAuth.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitchAuthFindManyArgs>(
      args?: SelectSubset<T, TwitchAuthFindManyArgs>
    ): CheckSelect<T, Promise<Array<TwitchAuth>>, Promise<Array<TwitchAuthGetPayload<T>>>>

    /**
     * Create a TwitchAuth.
     * @param {TwitchAuthCreateArgs} args - Arguments to create a TwitchAuth.
     * @example
     * // Create one TwitchAuth
     * const TwitchAuth = await prisma.twitchAuth.create({
     *   data: {
     *     // ... data to create a TwitchAuth
     *   }
     * })
     * 
    **/
    create<T extends TwitchAuthCreateArgs>(
      args: SelectSubset<T, TwitchAuthCreateArgs>
    ): CheckSelect<T, Prisma__TwitchAuthClient<TwitchAuth>, Prisma__TwitchAuthClient<TwitchAuthGetPayload<T>>>

    /**
     * Delete a TwitchAuth.
     * @param {TwitchAuthDeleteArgs} args - Arguments to delete one TwitchAuth.
     * @example
     * // Delete one TwitchAuth
     * const TwitchAuth = await prisma.twitchAuth.delete({
     *   where: {
     *     // ... filter to delete one TwitchAuth
     *   }
     * })
     * 
    **/
    delete<T extends TwitchAuthDeleteArgs>(
      args: SelectSubset<T, TwitchAuthDeleteArgs>
    ): CheckSelect<T, Prisma__TwitchAuthClient<TwitchAuth>, Prisma__TwitchAuthClient<TwitchAuthGetPayload<T>>>

    /**
     * Update one TwitchAuth.
     * @param {TwitchAuthUpdateArgs} args - Arguments to update one TwitchAuth.
     * @example
     * // Update one TwitchAuth
     * const twitchAuth = await prisma.twitchAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitchAuthUpdateArgs>(
      args: SelectSubset<T, TwitchAuthUpdateArgs>
    ): CheckSelect<T, Prisma__TwitchAuthClient<TwitchAuth>, Prisma__TwitchAuthClient<TwitchAuthGetPayload<T>>>

    /**
     * Delete zero or more TwitchAuths.
     * @param {TwitchAuthDeleteManyArgs} args - Arguments to filter TwitchAuths to delete.
     * @example
     * // Delete a few TwitchAuths
     * const { count } = await prisma.twitchAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitchAuthDeleteManyArgs>(
      args?: SelectSubset<T, TwitchAuthDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more TwitchAuths.
     * @param {TwitchAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitchAuths
     * const twitchAuth = await prisma.twitchAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitchAuthUpdateManyArgs>(
      args: SelectSubset<T, TwitchAuthUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one TwitchAuth.
     * @param {TwitchAuthUpsertArgs} args - Arguments to update or create a TwitchAuth.
     * @example
     * // Update or create a TwitchAuth
     * const twitchAuth = await prisma.twitchAuth.upsert({
     *   create: {
     *     // ... data to create a TwitchAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitchAuth we want to update
     *   }
     * })
    **/
    upsert<T extends TwitchAuthUpsertArgs>(
      args: SelectSubset<T, TwitchAuthUpsertArgs>
    ): CheckSelect<T, Prisma__TwitchAuthClient<TwitchAuth>, Prisma__TwitchAuthClient<TwitchAuthGetPayload<T>>>

    /**
     * Count the number of TwitchAuths.
     * @param {TwitchAuthCountArgs} args - Arguments to filter TwitchAuths to count.
     * @example
     * // Count the number of TwitchAuths
     * const count = await prisma.twitchAuth.count({
     *   where: {
     *     // ... the filter for the TwitchAuths we want to count
     *   }
     * })
    **/
    count<T extends TwitchAuthCountArgs>(
      args?: Subset<T, TwitchAuthCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitchAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitchAuth.
     * @param {TwitchAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitchAuthAggregateArgs>(args: Subset<T, TwitchAuthAggregateArgs>): Promise<GetTwitchAuthAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitchAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitchAuthClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Bot<T extends BotFindManyArgs = {}>(args?: Subset<T, BotFindManyArgs>): CheckSelect<T, Promise<Array<Bot>>, Promise<Array<BotGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TwitchAuth findUnique
   */
  export type TwitchAuthFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TwitchAuth
    **/
    select?: TwitchAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitchAuthInclude | null
    /**
     * Throw an Error if a TwitchAuth can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TwitchAuth to fetch.
    **/
    where: TwitchAuthWhereUniqueInput
  }


  /**
   * TwitchAuth findFirst
   */
  export type TwitchAuthFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TwitchAuth
    **/
    select?: TwitchAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitchAuthInclude | null
    /**
     * Throw an Error if a TwitchAuth can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TwitchAuth to fetch.
    **/
    where?: TwitchAuthWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TwitchAuths to fetch.
    **/
    orderBy?: Enumerable<TwitchAuthOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitchAuths.
    **/
    cursor?: TwitchAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitchAuths from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitchAuths.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of TwitchAuths.
    **/
    distinct?: Enumerable<TwitchAuthScalarFieldEnum>
  }


  /**
   * TwitchAuth findMany
   */
  export type TwitchAuthFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitchAuth
    **/
    select?: TwitchAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitchAuthInclude | null
    /**
     * Filter, which TwitchAuths to fetch.
    **/
    where?: TwitchAuthWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TwitchAuths to fetch.
    **/
    orderBy?: Enumerable<TwitchAuthOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitchAuths.
    **/
    cursor?: TwitchAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitchAuths from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitchAuths.
    **/
    skip?: number
    distinct?: Enumerable<TwitchAuthScalarFieldEnum>
  }


  /**
   * TwitchAuth create
   */
  export type TwitchAuthCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitchAuth
    **/
    select?: TwitchAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitchAuthInclude | null
    /**
     * The data needed to create a TwitchAuth.
    **/
    data: XOR<TwitchAuthUncheckedCreateInput, TwitchAuthCreateInput>
  }


  /**
   * TwitchAuth update
   */
  export type TwitchAuthUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitchAuth
    **/
    select?: TwitchAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitchAuthInclude | null
    /**
     * The data needed to update a TwitchAuth.
    **/
    data: XOR<TwitchAuthUncheckedUpdateInput, TwitchAuthUpdateInput>
    /**
     * Choose, which TwitchAuth to update.
    **/
    where: TwitchAuthWhereUniqueInput
  }


  /**
   * TwitchAuth updateMany
   */
  export type TwitchAuthUpdateManyArgs = {
    data: XOR<TwitchAuthUncheckedUpdateManyInput, TwitchAuthUpdateManyMutationInput>
    where?: TwitchAuthWhereInput
  }


  /**
   * TwitchAuth upsert
   */
  export type TwitchAuthUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitchAuth
    **/
    select?: TwitchAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitchAuthInclude | null
    /**
     * The filter to search for the TwitchAuth to update in case it exists.
    **/
    where: TwitchAuthWhereUniqueInput
    /**
     * In case the TwitchAuth found by the `where` argument doesn't exist, create a new TwitchAuth with this data.
    **/
    create: XOR<TwitchAuthUncheckedCreateInput, TwitchAuthCreateInput>
    /**
     * In case the TwitchAuth was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<TwitchAuthUncheckedUpdateInput, TwitchAuthUpdateInput>
  }


  /**
   * TwitchAuth delete
   */
  export type TwitchAuthDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitchAuth
    **/
    select?: TwitchAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitchAuthInclude | null
    /**
     * Filter which TwitchAuth to delete.
    **/
    where: TwitchAuthWhereUniqueInput
  }


  /**
   * TwitchAuth deleteMany
   */
  export type TwitchAuthDeleteManyArgs = {
    where?: TwitchAuthWhereInput
  }


  /**
   * TwitchAuth without action
   */
  export type TwitchAuthArgs = {
    /**
     * Select specific fields to fetch from the TwitchAuth
    **/
    select?: TwitchAuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitchAuthInclude | null
  }



  /**
   * Model TwitterUser
   */


  export type AggregateTwitterUser = {
    count: TwitterUserCountAggregateOutputType | null
    avg: TwitterUserAvgAggregateOutputType | null
    sum: TwitterUserSumAggregateOutputType | null
    min: TwitterUserMinAggregateOutputType | null
    max: TwitterUserMaxAggregateOutputType | null
  }

  export type TwitterUserAvgAggregateOutputType = {
    discrim: number
  }

  export type TwitterUserSumAggregateOutputType = {
    discrim: number
  }

  export type TwitterUserMinAggregateOutputType = {
    id: string | null
    username: string | null
    discrim: number
    userId: string | null
  }

  export type TwitterUserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    discrim: number
    userId: string | null
  }

  export type TwitterUserCountAggregateOutputType = {
    id: number | null
    username: number | null
    discrim: number
    userId: number | null
    _all: number
  }


  export type TwitterUserAvgAggregateInputType = {
    discrim?: true
  }

  export type TwitterUserSumAggregateInputType = {
    discrim?: true
  }

  export type TwitterUserMinAggregateInputType = {
    id?: true
    username?: true
    discrim?: true
    userId?: true
  }

  export type TwitterUserMaxAggregateInputType = {
    id?: true
    username?: true
    discrim?: true
    userId?: true
  }

  export type TwitterUserCountAggregateInputType = {
    id?: true
    username?: true
    discrim?: true
    userId?: true
    _all?: true
  }

  export type TwitterUserAggregateArgs = {
    /**
     * Filter which TwitterUser to aggregate.
    **/
    where?: TwitterUserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TwitterUsers to fetch.
    **/
    orderBy?: Enumerable<TwitterUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: TwitterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUsers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUsers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterUsers
    **/
    count?: true | TwitterUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TwitterUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TwitterUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TwitterUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TwitterUserMaxAggregateInputType
  }

  export type GetTwitterUserAggregateType<T extends TwitterUserAggregateArgs> = {
    [P in keyof T & keyof AggregateTwitterUser]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterUser[P]>
      : GetScalarType<T[P], AggregateTwitterUser[P]>
  }



  export type TwitterUserSelect = {
    id?: boolean
    username?: boolean
    discrim?: boolean
    userId?: boolean
    user?: boolean | UserArgs
  }

  export type TwitterUserInclude = {
    user?: boolean | UserArgs
  }

  export type TwitterUserGetPayload<
    S extends boolean | null | undefined | TwitterUserArgs,
    U = keyof S
      > = S extends true
        ? TwitterUser
    : S extends undefined
    ? never
    : S extends TwitterUserArgs | TwitterUserFindManyArgs
    ?'include' extends U
    ? TwitterUser  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TwitterUser ?TwitterUser [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> | null : never
  } 
    : TwitterUser
  : TwitterUser


  type TwitterUserCountArgs = Merge<
    Omit<TwitterUserFindManyArgs, 'select' | 'include'> & {
      select?: TwitterUserCountAggregateInputType | true
    }
  >

  export interface TwitterUserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TwitterUser that matches the filter.
     * @param {TwitterUserFindUniqueArgs} args - Arguments to find a TwitterUser
     * @example
     * // Get one TwitterUser
     * const twitterUser = await prisma.twitterUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterUser'> extends True ? CheckSelect<T, Prisma__TwitterUserClient<TwitterUser>, Prisma__TwitterUserClient<TwitterUserGetPayload<T>>> : CheckSelect<T, Prisma__TwitterUserClient<TwitterUser | null >, Prisma__TwitterUserClient<TwitterUserGetPayload<T> | null >>

    /**
     * Find the first TwitterUser that matches the filter.
     * @param {TwitterUserFindFirstArgs} args - Arguments to find a TwitterUser
     * @example
     * // Get one TwitterUser
     * const twitterUser = await prisma.twitterUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterUser'> extends True ? CheckSelect<T, Prisma__TwitterUserClient<TwitterUser>, Prisma__TwitterUserClient<TwitterUserGetPayload<T>>> : CheckSelect<T, Prisma__TwitterUserClient<TwitterUser | null >, Prisma__TwitterUserClient<TwitterUserGetPayload<T> | null >>

    /**
     * Find zero or more TwitterUsers that matches the filter.
     * @param {TwitterUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterUsers
     * const twitterUsers = await prisma.twitterUser.findMany()
     * 
     * // Get first 10 TwitterUsers
     * const twitterUsers = await prisma.twitterUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterUserWithIdOnly = await prisma.twitterUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterUserFindManyArgs>(
      args?: SelectSubset<T, TwitterUserFindManyArgs>
    ): CheckSelect<T, Promise<Array<TwitterUser>>, Promise<Array<TwitterUserGetPayload<T>>>>

    /**
     * Create a TwitterUser.
     * @param {TwitterUserCreateArgs} args - Arguments to create a TwitterUser.
     * @example
     * // Create one TwitterUser
     * const TwitterUser = await prisma.twitterUser.create({
     *   data: {
     *     // ... data to create a TwitterUser
     *   }
     * })
     * 
    **/
    create<T extends TwitterUserCreateArgs>(
      args: SelectSubset<T, TwitterUserCreateArgs>
    ): CheckSelect<T, Prisma__TwitterUserClient<TwitterUser>, Prisma__TwitterUserClient<TwitterUserGetPayload<T>>>

    /**
     * Delete a TwitterUser.
     * @param {TwitterUserDeleteArgs} args - Arguments to delete one TwitterUser.
     * @example
     * // Delete one TwitterUser
     * const TwitterUser = await prisma.twitterUser.delete({
     *   where: {
     *     // ... filter to delete one TwitterUser
     *   }
     * })
     * 
    **/
    delete<T extends TwitterUserDeleteArgs>(
      args: SelectSubset<T, TwitterUserDeleteArgs>
    ): CheckSelect<T, Prisma__TwitterUserClient<TwitterUser>, Prisma__TwitterUserClient<TwitterUserGetPayload<T>>>

    /**
     * Update one TwitterUser.
     * @param {TwitterUserUpdateArgs} args - Arguments to update one TwitterUser.
     * @example
     * // Update one TwitterUser
     * const twitterUser = await prisma.twitterUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterUserUpdateArgs>(
      args: SelectSubset<T, TwitterUserUpdateArgs>
    ): CheckSelect<T, Prisma__TwitterUserClient<TwitterUser>, Prisma__TwitterUserClient<TwitterUserGetPayload<T>>>

    /**
     * Delete zero or more TwitterUsers.
     * @param {TwitterUserDeleteManyArgs} args - Arguments to filter TwitterUsers to delete.
     * @example
     * // Delete a few TwitterUsers
     * const { count } = await prisma.twitterUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterUserDeleteManyArgs>(
      args?: SelectSubset<T, TwitterUserDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more TwitterUsers.
     * @param {TwitterUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterUsers
     * const twitterUser = await prisma.twitterUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterUserUpdateManyArgs>(
      args: SelectSubset<T, TwitterUserUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one TwitterUser.
     * @param {TwitterUserUpsertArgs} args - Arguments to update or create a TwitterUser.
     * @example
     * // Update or create a TwitterUser
     * const twitterUser = await prisma.twitterUser.upsert({
     *   create: {
     *     // ... data to create a TwitterUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterUser we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterUserUpsertArgs>(
      args: SelectSubset<T, TwitterUserUpsertArgs>
    ): CheckSelect<T, Prisma__TwitterUserClient<TwitterUser>, Prisma__TwitterUserClient<TwitterUserGetPayload<T>>>

    /**
     * Count the number of TwitterUsers.
     * @param {TwitterUserCountArgs} args - Arguments to filter TwitterUsers to count.
     * @example
     * // Count the number of TwitterUsers
     * const count = await prisma.twitterUser.count({
     *   where: {
     *     // ... the filter for the TwitterUsers we want to count
     *   }
     * })
    **/
    count<T extends TwitterUserCountArgs>(
      args?: Subset<T, TwitterUserCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterUser.
     * @param {TwitterUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterUserAggregateArgs>(args: Subset<T, TwitterUserAggregateArgs>): Promise<GetTwitterUserAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterUserClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TwitterUser findUnique
   */
  export type TwitterUserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
    **/
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitterUserInclude | null
    /**
     * Throw an Error if a TwitterUser can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TwitterUser to fetch.
    **/
    where: TwitterUserWhereUniqueInput
  }


  /**
   * TwitterUser findFirst
   */
  export type TwitterUserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
    **/
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitterUserInclude | null
    /**
     * Throw an Error if a TwitterUser can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TwitterUser to fetch.
    **/
    where?: TwitterUserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TwitterUsers to fetch.
    **/
    orderBy?: Enumerable<TwitterUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterUsers.
    **/
    cursor?: TwitterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUsers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUsers.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of TwitterUsers.
    **/
    distinct?: Enumerable<TwitterUserScalarFieldEnum>
  }


  /**
   * TwitterUser findMany
   */
  export type TwitterUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
    **/
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitterUserInclude | null
    /**
     * Filter, which TwitterUsers to fetch.
    **/
    where?: TwitterUserWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of TwitterUsers to fetch.
    **/
    orderBy?: Enumerable<TwitterUserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterUsers.
    **/
    cursor?: TwitterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUsers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUsers.
    **/
    skip?: number
    distinct?: Enumerable<TwitterUserScalarFieldEnum>
  }


  /**
   * TwitterUser create
   */
  export type TwitterUserCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
    **/
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitterUserInclude | null
    /**
     * The data needed to create a TwitterUser.
    **/
    data: XOR<TwitterUserUncheckedCreateInput, TwitterUserCreateInput>
  }


  /**
   * TwitterUser update
   */
  export type TwitterUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
    **/
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitterUserInclude | null
    /**
     * The data needed to update a TwitterUser.
    **/
    data: XOR<TwitterUserUncheckedUpdateInput, TwitterUserUpdateInput>
    /**
     * Choose, which TwitterUser to update.
    **/
    where: TwitterUserWhereUniqueInput
  }


  /**
   * TwitterUser updateMany
   */
  export type TwitterUserUpdateManyArgs = {
    data: XOR<TwitterUserUncheckedUpdateManyInput, TwitterUserUpdateManyMutationInput>
    where?: TwitterUserWhereInput
  }


  /**
   * TwitterUser upsert
   */
  export type TwitterUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
    **/
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitterUserInclude | null
    /**
     * The filter to search for the TwitterUser to update in case it exists.
    **/
    where: TwitterUserWhereUniqueInput
    /**
     * In case the TwitterUser found by the `where` argument doesn't exist, create a new TwitterUser with this data.
    **/
    create: XOR<TwitterUserUncheckedCreateInput, TwitterUserCreateInput>
    /**
     * In case the TwitterUser was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<TwitterUserUncheckedUpdateInput, TwitterUserUpdateInput>
  }


  /**
   * TwitterUser delete
   */
  export type TwitterUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
    **/
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitterUserInclude | null
    /**
     * Filter which TwitterUser to delete.
    **/
    where: TwitterUserWhereUniqueInput
  }


  /**
   * TwitterUser deleteMany
   */
  export type TwitterUserDeleteManyArgs = {
    where?: TwitterUserWhereInput
  }


  /**
   * TwitterUser without action
   */
  export type TwitterUserArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
    **/
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TwitterUserInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ManagerScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    ownerId: 'ownerId',
    ip: 'ip',
    url: 'url',
    port: 'port',
    type: 'type',
    restartSchedule: 'restartSchedule',
    downtimeHistory: 'downtimeHistory',
    tasksCompleted: 'tasksCompleted',
    parentID: 'parentID'
  };

  export type ManagerScalarFieldEnum = (typeof ManagerScalarFieldEnum)[keyof typeof ManagerScalarFieldEnum]


  export const HostScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    ownerId: 'ownerId',
    ip: 'ip',
    url: 'url',
    port: 'port',
    shardLimit: 'shardLimit'
  };

  export type HostScalarFieldEnum = (typeof HostScalarFieldEnum)[keyof typeof HostScalarFieldEnum]


  export const BotScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ownerId: 'ownerId',
    hostsId: 'hostsId',
    priorityHostId: 'priorityHostId',
    discordToken: 'discordToken',
    twitterToken: 'twitterToken',
    twitchAuthId: 'twitchAuthId',
    recommendedShards: 'recommendedShards',
    currentShards: 'currentShards'
  };

  export type BotScalarFieldEnum = (typeof BotScalarFieldEnum)[keyof typeof BotScalarFieldEnum]


  export const ShardScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    lanchedAt: 'lanchedAt',
    hostId: 'hostId',
    botId: 'botId',
    status: 'status',
    shardID: 'shardID'
  };

  export type ShardScalarFieldEnum = (typeof ShardScalarFieldEnum)[keyof typeof ShardScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    isAdmin: 'isAdmin'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PATScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type PATScalarFieldEnum = (typeof PATScalarFieldEnum)[keyof typeof PATScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    completedAt: 'completedAt',
    managerId: 'managerId',
    patId: 'patId',
    suspicious: 'suspicious',
    fraudulent: 'fraudulent',
    reversedAt: 'reversedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const DiscordUserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    discrim: 'discrim',
    userId: 'userId'
  };

  export type DiscordUserScalarFieldEnum = (typeof DiscordUserScalarFieldEnum)[keyof typeof DiscordUserScalarFieldEnum]


  export const GuildScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type GuildScalarFieldEnum = (typeof GuildScalarFieldEnum)[keyof typeof GuildScalarFieldEnum]


  export const UsersOnGuildsScalarFieldEnum: {
    userId: 'userId',
    guildId: 'guildId',
    createdAt: 'createdAt'
  };

  export type UsersOnGuildsScalarFieldEnum = (typeof UsersOnGuildsScalarFieldEnum)[keyof typeof UsersOnGuildsScalarFieldEnum]


  export const AdminOnGuildsScalarFieldEnum: {
    userId: 'userId',
    guildId: 'guildId',
    createdAt: 'createdAt'
  };

  export type AdminOnGuildsScalarFieldEnum = (typeof AdminOnGuildsScalarFieldEnum)[keyof typeof AdminOnGuildsScalarFieldEnum]


  export const CommandScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    registeredAt: 'registeredAt',
    version: 'version',
    usage: 'usage',
    cost: 'cost',
    type: 'type',
    url: 'url'
  };

  export type CommandScalarFieldEnum = (typeof CommandScalarFieldEnum)[keyof typeof CommandScalarFieldEnum]


  export const ActionScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    registeredAt: 'registeredAt',
    version: 'version',
    usage: 'usage',
    cost: 'cost',
    type: 'type',
    url: 'url'
  };

  export type ActionScalarFieldEnum = (typeof ActionScalarFieldEnum)[keyof typeof ActionScalarFieldEnum]


  export const TwitchUserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    userId: 'userId'
  };

  export type TwitchUserScalarFieldEnum = (typeof TwitchUserScalarFieldEnum)[keyof typeof TwitchUserScalarFieldEnum]


  export const TwitchAuthScalarFieldEnum: {
    id: 'id',
    clientID: 'clientID',
    twitchSecret: 'twitchSecret',
    sessionSecret: 'sessionSecret'
  };

  export type TwitchAuthScalarFieldEnum = (typeof TwitchAuthScalarFieldEnum)[keyof typeof TwitchAuthScalarFieldEnum]


  export const TwitterUserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    discrim: 'discrim',
    userId: 'userId'
  };

  export type TwitterUserScalarFieldEnum = (typeof TwitterUserScalarFieldEnum)[keyof typeof TwitterUserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type ManagerWhereInput = {
    AND?: Enumerable<ManagerWhereInput>
    OR?: Enumerable<ManagerWhereInput>
    NOT?: Enumerable<ManagerWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    ownerId?: StringFilter | string
    ip?: StringFilter | string
    url?: StringFilter | string
    port?: IntFilter | number
    type?: EnumManagerLevelsFilter | ManagerLevels
    restartSchedule?: StringFilter | string
    downtimeHistory?: JsonNullableListFilter
    tasksCompleted?: IntFilter | number
    parentID?: StringNullableFilter | string | null
    owner?: XOR<UserWhereInput, UserRelationFilter>
    parentManager?: XOR<ManagerWhereInput, ManagerRelationFilter> | null
    childManagers?: ManagerListRelationFilter
    transaction?: TransactionListRelationFilter
    Manager_B?: ManagerListRelationFilter
    Manager_A?: ManagerListRelationFilter
  }

  export type ManagerOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    ownerId?: SortOrder
    ip?: SortOrder
    url?: SortOrder
    port?: SortOrder
    type?: SortOrder
    restartSchedule?: SortOrder
    downtimeHistory?: SortOrder
    tasksCompleted?: SortOrder
    parentID?: SortOrder
    owner?: UserOrderByInput
    parentManager?: ManagerOrderByInput
  }

  export type ManagerWhereUniqueInput = {
    id?: string
  }

  export type HostWhereInput = {
    AND?: Enumerable<HostWhereInput>
    OR?: Enumerable<HostWhereInput>
    NOT?: Enumerable<HostWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    ownerId?: StringFilter | string
    ip?: StringFilter | string
    url?: StringFilter | string
    port?: IntFilter | number
    shardLimit?: IntFilter | number
    owner?: XOR<UserWhereInput, UserRelationFilter>
    bots?: BotListRelationFilter
    priorityBot?: BotListRelationFilter
    shards?: ShardListRelationFilter
  }

  export type HostOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    ownerId?: SortOrder
    ip?: SortOrder
    url?: SortOrder
    port?: SortOrder
    shardLimit?: SortOrder
    owner?: UserOrderByInput
  }

  export type HostWhereUniqueInput = {
    id?: number
  }

  export type BotWhereInput = {
    AND?: Enumerable<BotWhereInput>
    OR?: Enumerable<BotWhereInput>
    NOT?: Enumerable<BotWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    ownerId?: StringFilter | string
    hostsId?: IntFilter | number
    priorityHostId?: IntNullableFilter | number | null
    discordToken?: StringNullableFilter | string | null
    twitterToken?: StringNullableFilter | string | null
    twitchAuthId?: IntFilter | number
    recommendedShards?: IntFilter | number
    currentShards?: IntFilter | number
    hosts?: XOR<HostWhereInput, HostRelationFilter>
    owner?: XOR<UserWhereInput, UserRelationFilter>
    priorityHost?: XOR<HostWhereInput, HostRelationFilter> | null
    twitchAuth?: XOR<TwitchAuthWhereInput, TwitchAuthRelationFilter>
    shards?: ShardListRelationFilter
  }

  export type BotOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    hostsId?: SortOrder
    priorityHostId?: SortOrder
    discordToken?: SortOrder
    twitterToken?: SortOrder
    twitchAuthId?: SortOrder
    recommendedShards?: SortOrder
    currentShards?: SortOrder
    hosts?: HostOrderByInput
    owner?: UserOrderByInput
    priorityHost?: HostOrderByInput
    twitchAuth?: TwitchAuthOrderByInput
  }

  export type BotWhereUniqueInput = {
    id?: number
    discordToken?: string
    twitterToken?: string
  }

  export type ShardWhereInput = {
    AND?: Enumerable<ShardWhereInput>
    OR?: Enumerable<ShardWhereInput>
    NOT?: Enumerable<ShardWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    lanchedAt?: DateTimeNullableFilter | Date | string | null
    hostId?: IntFilter | number
    botId?: IntFilter | number
    status?: EnumShardStatusFilter | ShardStatus
    shardID?: IntFilter | number
    bot?: XOR<BotWhereInput, BotRelationFilter>
    Host?: XOR<HostWhereInput, HostRelationFilter>
  }

  export type ShardOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    lanchedAt?: SortOrder
    hostId?: SortOrder
    botId?: SortOrder
    status?: SortOrder
    shardID?: SortOrder
    bot?: BotOrderByInput
    Host?: HostOrderByInput
  }

  export type ShardWhereUniqueInput = {
    id?: string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    firstName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    email?: StringFilter | string
    password?: StringFilter | string
    isAdmin?: BoolFilter | boolean
    actions?: ActionListRelationFilter
    Bot?: BotListRelationFilter
    commands?: CommandListRelationFilter
    discord?: XOR<DiscordUserWhereInput, DiscordUserRelationFilter> | null
    Hosts?: HostListRelationFilter
    Manager?: ManagerListRelationFilter
    pat?: PATListRelationFilter
    twitch?: XOR<TwitchUserWhereInput, TwitchUserRelationFilter> | null
    TwitterUser?: TwitterUserListRelationFilter
  }

  export type UserOrderByInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    discord?: DiscordUserOrderByInput
    twitch?: TwitchUserOrderByInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type PATWhereInput = {
    AND?: Enumerable<PATWhereInput>
    OR?: Enumerable<PATWhereInput>
    NOT?: Enumerable<PATWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    status?: EnumPATStatusFilter | PATStatus
    user?: XOR<UserWhereInput, UserRelationFilter>
    transaction?: TransactionListRelationFilter
  }

  export type PATOrderByInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    user?: UserOrderByInput
  }

  export type PATWhereUniqueInput = {
    id?: string
  }

  export type transactionWhereInput = {
    AND?: Enumerable<transactionWhereInput>
    OR?: Enumerable<transactionWhereInput>
    NOT?: Enumerable<transactionWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    completedAt?: DateTimeNullableFilter | Date | string | null
    managerId?: StringFilter | string
    patId?: StringNullableFilter | string | null
    suspicious?: BoolFilter | boolean
    fraudulent?: BoolFilter | boolean
    reversedAt?: DateTimeNullableFilter | Date | string | null
    responsibleManager?: XOR<ManagerWhereInput, ManagerRelationFilter>
    pat?: XOR<PATWhereInput, PATRelationFilter> | null
  }

  export type transactionOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    managerId?: SortOrder
    patId?: SortOrder
    suspicious?: SortOrder
    fraudulent?: SortOrder
    reversedAt?: SortOrder
    responsibleManager?: ManagerOrderByInput
    pat?: PATOrderByInput
  }

  export type transactionWhereUniqueInput = {
    id?: string
  }

  export type DiscordUserWhereInput = {
    AND?: Enumerable<DiscordUserWhereInput>
    OR?: Enumerable<DiscordUserWhereInput>
    NOT?: Enumerable<DiscordUserWhereInput>
    id?: StringFilter | string
    username?: StringFilter | string
    discrim?: IntFilter | number
    userId?: StringNullableFilter | string | null
    user?: XOR<UserWhereInput, UserRelationFilter> | null
    administates?: AdminOnGuildsListRelationFilter
    UsersOnGuilds?: UsersOnGuildsListRelationFilter
  }

  export type DiscordUserOrderByInput = {
    id?: SortOrder
    username?: SortOrder
    discrim?: SortOrder
    userId?: SortOrder
  }

  export type DiscordUserWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type guildWhereInput = {
    AND?: Enumerable<guildWhereInput>
    OR?: Enumerable<guildWhereInput>
    NOT?: Enumerable<guildWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    admins?: AdminOnGuildsListRelationFilter
    members?: UsersOnGuildsListRelationFilter
  }

  export type guildOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type guildWhereUniqueInput = {
    id?: number
  }

  export type UsersOnGuildsWhereInput = {
    AND?: Enumerable<UsersOnGuildsWhereInput>
    OR?: Enumerable<UsersOnGuildsWhereInput>
    NOT?: Enumerable<UsersOnGuildsWhereInput>
    userId?: StringFilter | string
    guildId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    guild?: XOR<guildWhereInput, GuildRelationFilter>
    user?: XOR<DiscordUserWhereInput, DiscordUserRelationFilter>
  }

  export type UsersOnGuildsOrderByInput = {
    userId?: SortOrder
    guildId?: SortOrder
    createdAt?: SortOrder
    guild?: guildOrderByInput
    user?: DiscordUserOrderByInput
  }

  export type UsersOnGuildsWhereUniqueInput = {
    userId_guildId?: UsersOnGuildsUserIdGuildIdCompoundUniqueInput
  }

  export type AdminOnGuildsWhereInput = {
    AND?: Enumerable<AdminOnGuildsWhereInput>
    OR?: Enumerable<AdminOnGuildsWhereInput>
    NOT?: Enumerable<AdminOnGuildsWhereInput>
    userId?: StringFilter | string
    guildId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    guild?: XOR<guildWhereInput, GuildRelationFilter>
    user?: XOR<DiscordUserWhereInput, DiscordUserRelationFilter>
  }

  export type AdminOnGuildsOrderByInput = {
    userId?: SortOrder
    guildId?: SortOrder
    createdAt?: SortOrder
    guild?: guildOrderByInput
    user?: DiscordUserOrderByInput
  }

  export type AdminOnGuildsWhereUniqueInput = {
    userId_guildId?: AdminOnGuildsUserIdGuildIdCompoundUniqueInput
  }

  export type CommandWhereInput = {
    AND?: Enumerable<CommandWhereInput>
    OR?: Enumerable<CommandWhereInput>
    NOT?: Enumerable<CommandWhereInput>
    id?: StringFilter | string
    ownerId?: StringFilter | string
    registeredAt?: DateTimeFilter | Date | string
    version?: IntFilter | number
    usage?: IntFilter | number
    cost?: IntFilter | number
    type?: EnumDiscordExecutionTypeFilter | DiscordExecutionType
    url?: StringFilter | string
    owner?: XOR<UserWhereInput, UserRelationFilter>
  }

  export type CommandOrderByInput = {
    id?: SortOrder
    ownerId?: SortOrder
    registeredAt?: SortOrder
    version?: SortOrder
    usage?: SortOrder
    cost?: SortOrder
    type?: SortOrder
    url?: SortOrder
    owner?: UserOrderByInput
  }

  export type CommandWhereUniqueInput = {
    id?: string
  }

  export type ActionWhereInput = {
    AND?: Enumerable<ActionWhereInput>
    OR?: Enumerable<ActionWhereInput>
    NOT?: Enumerable<ActionWhereInput>
    id?: IntFilter | number
    ownerId?: StringFilter | string
    registeredAt?: DateTimeFilter | Date | string
    version?: IntFilter | number
    usage?: IntFilter | number
    cost?: IntFilter | number
    type?: EnumDiscordExecutionTypeFilter | DiscordExecutionType
    url?: StringFilter | string
    owner?: XOR<UserWhereInput, UserRelationFilter>
  }

  export type ActionOrderByInput = {
    id?: SortOrder
    ownerId?: SortOrder
    registeredAt?: SortOrder
    version?: SortOrder
    usage?: SortOrder
    cost?: SortOrder
    type?: SortOrder
    url?: SortOrder
    owner?: UserOrderByInput
  }

  export type ActionWhereUniqueInput = {
    id?: number
  }

  export type TwitchUserWhereInput = {
    AND?: Enumerable<TwitchUserWhereInput>
    OR?: Enumerable<TwitchUserWhereInput>
    NOT?: Enumerable<TwitchUserWhereInput>
    id?: IntFilter | number
    username?: StringFilter | string
    accessToken?: StringFilter | string
    refreshToken?: StringFilter | string
    userId?: StringNullableFilter | string | null
    user?: XOR<UserWhereInput, UserRelationFilter> | null
  }

  export type TwitchUserOrderByInput = {
    id?: SortOrder
    username?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
  }

  export type TwitchUserWhereUniqueInput = {
    id?: number
    userId?: string
  }

  export type TwitchAuthWhereInput = {
    AND?: Enumerable<TwitchAuthWhereInput>
    OR?: Enumerable<TwitchAuthWhereInput>
    NOT?: Enumerable<TwitchAuthWhereInput>
    id?: IntFilter | number
    clientID?: StringFilter | string
    twitchSecret?: StringFilter | string
    sessionSecret?: StringFilter | string
    Bot?: BotListRelationFilter
  }

  export type TwitchAuthOrderByInput = {
    id?: SortOrder
    clientID?: SortOrder
    twitchSecret?: SortOrder
    sessionSecret?: SortOrder
  }

  export type TwitchAuthWhereUniqueInput = {
    id?: number
    clientID?: string
  }

  export type TwitterUserWhereInput = {
    AND?: Enumerable<TwitterUserWhereInput>
    OR?: Enumerable<TwitterUserWhereInput>
    NOT?: Enumerable<TwitterUserWhereInput>
    id?: StringFilter | string
    username?: StringFilter | string
    discrim?: IntFilter | number
    userId?: StringNullableFilter | string | null
    user?: XOR<UserWhereInput, UserRelationFilter> | null
  }

  export type TwitterUserOrderByInput = {
    id?: SortOrder
    username?: SortOrder
    discrim?: SortOrder
    userId?: SortOrder
    user?: UserOrderByInput
  }

  export type TwitterUserWhereUniqueInput = {
    id?: string
  }

  export type ManagerCreateInput = {
    id?: string
    createdAt?: Date | string
    ip: string
    url: string
    port?: number
    type?: ManagerLevels
    restartSchedule: string
    tasksCompleted?: number
    downtimeHistory?: ManagerCreatedowntimeHistoryInput | Enumerable<InputJsonValue>
    owner: UserCreateNestedOneWithoutManagerInput
    parentManager?: ManagerCreateNestedOneWithoutChildManagersInput
    childManagers?: ManagerCreateNestedManyWithoutParentManagerInput
    transaction?: transactionCreateNestedManyWithoutResponsibleManagerInput
    Manager_B?: ManagerCreateNestedManyWithoutManager_AInput
    Manager_A?: ManagerCreateNestedManyWithoutManager_BInput
  }

  export type ManagerUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    ownerId: string
    ip: string
    url: string
    port?: number
    type?: ManagerLevels
    restartSchedule: string
    tasksCompleted?: number
    parentID?: string | null
    downtimeHistory?: ManagerCreatedowntimeHistoryInput | Enumerable<InputJsonValue>
    childManagers?: ManagerUncheckedCreateNestedManyWithoutParentManagerInput
    transaction?: transactionUncheckedCreateNestedManyWithoutResponsibleManagerInput
  }

  export type ManagerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
    owner?: UserUpdateOneRequiredWithoutManagerInput
    parentManager?: ManagerUpdateOneWithoutChildManagersInput
    childManagers?: ManagerUpdateManyWithoutParentManagerInput
    transaction?: transactionUpdateManyWithoutResponsibleManagerInput
    Manager_B?: ManagerUpdateManyWithoutManager_AInput
    Manager_A?: ManagerUpdateManyWithoutManager_BInput
  }

  export type ManagerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    parentID?: NullableStringFieldUpdateOperationsInput | string | null
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
    childManagers?: ManagerUncheckedUpdateManyWithoutParentManagerInput
    transaction?: transactionUncheckedUpdateManyWithoutResponsibleManagerInput
  }

  export type ManagerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
  }

  export type ManagerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    parentID?: NullableStringFieldUpdateOperationsInput | string | null
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
  }

  export type HostCreateInput = {
    createdAt?: Date | string
    ip: string
    url: string
    port?: number
    shardLimit?: number
    owner: UserCreateNestedOneWithoutHostsInput
    bots?: BotCreateNestedManyWithoutHostsInput
    priorityBot?: BotCreateNestedManyWithoutPriorityHostInput
    shards?: ShardCreateNestedManyWithoutHostInput
  }

  export type HostUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    ownerId: string
    ip: string
    url: string
    port?: number
    shardLimit?: number
    bots?: BotUncheckedCreateNestedManyWithoutHostsInput
    priorityBot?: BotUncheckedCreateNestedManyWithoutPriorityHostInput
    shards?: ShardUncheckedCreateNestedManyWithoutHostInput
  }

  export type HostUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    shardLimit?: IntFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutHostsInput
    bots?: BotUpdateManyWithoutHostsInput
    priorityBot?: BotUpdateManyWithoutPriorityHostInput
    shards?: ShardUpdateManyWithoutHostInput
  }

  export type HostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    shardLimit?: IntFieldUpdateOperationsInput | number
    bots?: BotUncheckedUpdateManyWithoutHostsInput
    priorityBot?: BotUncheckedUpdateManyWithoutPriorityHostInput
    shards?: ShardUncheckedUpdateManyWithoutHostInput
  }

  export type HostUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    shardLimit?: IntFieldUpdateOperationsInput | number
  }

  export type HostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    shardLimit?: IntFieldUpdateOperationsInput | number
  }

  export type BotCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    discordToken?: string | null
    twitterToken?: string | null
    recommendedShards?: number
    currentShards?: number
    hosts: HostCreateNestedOneWithoutBotsInput
    owner: UserCreateNestedOneWithoutBotInput
    priorityHost?: HostCreateNestedOneWithoutPriorityBotInput
    twitchAuth: TwitchAuthCreateNestedOneWithoutBotInput
    shards?: ShardCreateNestedManyWithoutBotInput
  }

  export type BotUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    hostsId: number
    priorityHostId?: number | null
    discordToken?: string | null
    twitterToken?: string | null
    twitchAuthId: number
    recommendedShards?: number
    currentShards?: number
    shards?: ShardUncheckedCreateNestedManyWithoutBotInput
  }

  export type BotUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discordToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitterToken?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedShards?: IntFieldUpdateOperationsInput | number
    currentShards?: IntFieldUpdateOperationsInput | number
    hosts?: HostUpdateOneRequiredWithoutBotsInput
    owner?: UserUpdateOneRequiredWithoutBotInput
    priorityHost?: HostUpdateOneWithoutPriorityBotInput
    twitchAuth?: TwitchAuthUpdateOneRequiredWithoutBotInput
    shards?: ShardUpdateManyWithoutBotInput
  }

  export type BotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    hostsId?: IntFieldUpdateOperationsInput | number
    priorityHostId?: NullableIntFieldUpdateOperationsInput | number | null
    discordToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitterToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitchAuthId?: IntFieldUpdateOperationsInput | number
    recommendedShards?: IntFieldUpdateOperationsInput | number
    currentShards?: IntFieldUpdateOperationsInput | number
    shards?: ShardUncheckedUpdateManyWithoutBotInput
  }

  export type BotUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discordToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitterToken?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedShards?: IntFieldUpdateOperationsInput | number
    currentShards?: IntFieldUpdateOperationsInput | number
  }

  export type BotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    hostsId?: IntFieldUpdateOperationsInput | number
    priorityHostId?: NullableIntFieldUpdateOperationsInput | number | null
    discordToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitterToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitchAuthId?: IntFieldUpdateOperationsInput | number
    recommendedShards?: IntFieldUpdateOperationsInput | number
    currentShards?: IntFieldUpdateOperationsInput | number
  }

  export type ShardCreateInput = {
    id?: string
    createdAt?: Date | string
    lanchedAt?: Date | string | null
    status?: ShardStatus
    shardID: number
    bot: BotCreateNestedOneWithoutShardsInput
    Host: HostCreateNestedOneWithoutShardsInput
  }

  export type ShardUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    lanchedAt?: Date | string | null
    hostId: number
    botId: number
    status?: ShardStatus
    shardID: number
  }

  export type ShardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lanchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShardStatusFieldUpdateOperationsInput | ShardStatus
    shardID?: IntFieldUpdateOperationsInput | number
    bot?: BotUpdateOneRequiredWithoutShardsInput
    Host?: HostUpdateOneRequiredWithoutShardsInput
  }

  export type ShardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lanchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hostId?: IntFieldUpdateOperationsInput | number
    botId?: IntFieldUpdateOperationsInput | number
    status?: EnumShardStatusFieldUpdateOperationsInput | ShardStatus
    shardID?: IntFieldUpdateOperationsInput | number
  }

  export type ShardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lanchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShardStatusFieldUpdateOperationsInput | ShardStatus
    shardID?: IntFieldUpdateOperationsInput | number
  }

  export type ShardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lanchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hostId?: IntFieldUpdateOperationsInput | number
    botId?: IntFieldUpdateOperationsInput | number
    status?: EnumShardStatusFieldUpdateOperationsInput | ShardStatus
    shardID?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionCreateNestedManyWithoutOwnerInput
    Bot?: BotCreateNestedManyWithoutOwnerInput
    commands?: CommandCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserCreateNestedOneWithoutUserInput
    Hosts?: HostCreateNestedManyWithoutOwnerInput
    Manager?: ManagerCreateNestedManyWithoutOwnerInput
    pat?: PATCreateNestedManyWithoutUserInput
    twitch?: TwitchUserCreateNestedOneWithoutUserInput
    TwitterUser?: TwitterUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionUncheckedCreateNestedManyWithoutOwnerInput
    Bot?: BotUncheckedCreateNestedManyWithoutOwnerInput
    commands?: CommandUncheckedCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserUncheckedCreateNestedOneWithoutUserInput
    Hosts?: HostUncheckedCreateNestedManyWithoutOwnerInput
    Manager?: ManagerUncheckedCreateNestedManyWithoutOwnerInput
    pat?: PATUncheckedCreateNestedManyWithoutUserInput
    twitch?: TwitchUserUncheckedCreateNestedOneWithoutUserInput
    TwitterUser?: TwitterUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUpdateManyWithoutOwnerInput
    Bot?: BotUpdateManyWithoutOwnerInput
    commands?: CommandUpdateManyWithoutOwnerInput
    discord?: DiscordUserUpdateOneWithoutUserInput
    Hosts?: HostUpdateManyWithoutOwnerInput
    Manager?: ManagerUpdateManyWithoutOwnerInput
    pat?: PATUpdateManyWithoutUserInput
    twitch?: TwitchUserUpdateOneWithoutUserInput
    TwitterUser?: TwitterUserUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUncheckedUpdateManyWithoutOwnerInput
    Bot?: BotUncheckedUpdateManyWithoutOwnerInput
    commands?: CommandUncheckedUpdateManyWithoutOwnerInput
    discord?: DiscordUserUncheckedUpdateOneWithoutUserInput
    Hosts?: HostUncheckedUpdateManyWithoutOwnerInput
    Manager?: ManagerUncheckedUpdateManyWithoutOwnerInput
    pat?: PATUncheckedUpdateManyWithoutUserInput
    twitch?: TwitchUserUncheckedUpdateOneWithoutUserInput
    TwitterUser?: TwitterUserUncheckedUpdateManyWithoutUserInput
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PATCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: PATStatus
    user: UserCreateNestedOneWithoutPatInput
    transaction?: transactionCreateNestedManyWithoutPatInput
  }

  export type PATUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: PATStatus
    transaction?: transactionUncheckedCreateNestedManyWithoutPatInput
  }

  export type PATUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPATStatusFieldUpdateOperationsInput | PATStatus
    user?: UserUpdateOneRequiredWithoutPatInput
    transaction?: transactionUpdateManyWithoutPatInput
  }

  export type PATUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPATStatusFieldUpdateOperationsInput | PATStatus
    transaction?: transactionUncheckedUpdateManyWithoutPatInput
  }

  export type PATUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPATStatusFieldUpdateOperationsInput | PATStatus
  }

  export type PATUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPATStatusFieldUpdateOperationsInput | PATStatus
  }

  export type transactionCreateInput = {
    id?: string
    createdAt?: Date | string
    completedAt?: Date | string | null
    suspicious?: boolean
    fraudulent?: boolean
    reversedAt?: Date | string | null
    responsibleManager: ManagerCreateNestedOneWithoutTransactionInput
    pat?: PATCreateNestedOneWithoutTransactionInput
  }

  export type transactionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    completedAt?: Date | string | null
    managerId: string
    patId?: string | null
    suspicious?: boolean
    fraudulent?: boolean
    reversedAt?: Date | string | null
  }

  export type transactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspicious?: BoolFieldUpdateOperationsInput | boolean
    fraudulent?: BoolFieldUpdateOperationsInput | boolean
    reversedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsibleManager?: ManagerUpdateOneRequiredWithoutTransactionInput
    pat?: PATUpdateOneWithoutTransactionInput
  }

  export type transactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: StringFieldUpdateOperationsInput | string
    patId?: NullableStringFieldUpdateOperationsInput | string | null
    suspicious?: BoolFieldUpdateOperationsInput | boolean
    fraudulent?: BoolFieldUpdateOperationsInput | boolean
    reversedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspicious?: BoolFieldUpdateOperationsInput | boolean
    fraudulent?: BoolFieldUpdateOperationsInput | boolean
    reversedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: StringFieldUpdateOperationsInput | string
    patId?: NullableStringFieldUpdateOperationsInput | string | null
    suspicious?: BoolFieldUpdateOperationsInput | boolean
    fraudulent?: BoolFieldUpdateOperationsInput | boolean
    reversedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiscordUserCreateInput = {
    id: string
    username: string
    discrim: number
    user?: UserCreateNestedOneWithoutDiscordInput
    administates?: AdminOnGuildsCreateNestedManyWithoutUserInput
    UsersOnGuilds?: UsersOnGuildsCreateNestedManyWithoutUserInput
  }

  export type DiscordUserUncheckedCreateInput = {
    id: string
    username: string
    discrim: number
    userId?: string | null
    administates?: AdminOnGuildsUncheckedCreateNestedManyWithoutUserInput
    UsersOnGuilds?: UsersOnGuildsUncheckedCreateNestedManyWithoutUserInput
  }

  export type DiscordUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discrim?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutDiscordInput
    administates?: AdminOnGuildsUpdateManyWithoutUserInput
    UsersOnGuilds?: UsersOnGuildsUpdateManyWithoutUserInput
  }

  export type DiscordUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discrim?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    administates?: AdminOnGuildsUncheckedUpdateManyWithoutUserInput
    UsersOnGuilds?: UsersOnGuildsUncheckedUpdateManyWithoutUserInput
  }

  export type DiscordUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discrim?: IntFieldUpdateOperationsInput | number
  }

  export type DiscordUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discrim?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type guildCreateInput = {
    id: number
    name: string
    admins?: AdminOnGuildsCreateNestedManyWithoutGuildInput
    members?: UsersOnGuildsCreateNestedManyWithoutGuildInput
  }

  export type guildUncheckedCreateInput = {
    id: number
    name: string
    admins?: AdminOnGuildsUncheckedCreateNestedManyWithoutGuildInput
    members?: UsersOnGuildsUncheckedCreateNestedManyWithoutGuildInput
  }

  export type guildUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    admins?: AdminOnGuildsUpdateManyWithoutGuildInput
    members?: UsersOnGuildsUpdateManyWithoutGuildInput
  }

  export type guildUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    admins?: AdminOnGuildsUncheckedUpdateManyWithoutGuildInput
    members?: UsersOnGuildsUncheckedUpdateManyWithoutGuildInput
  }

  export type guildUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type guildUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UsersOnGuildsCreateInput = {
    createdAt?: Date | string
    guild: guildCreateNestedOneWithoutMembersInput
    user: DiscordUserCreateNestedOneWithoutUsersOnGuildsInput
  }

  export type UsersOnGuildsUncheckedCreateInput = {
    userId: string
    guildId: number
    createdAt?: Date | string
  }

  export type UsersOnGuildsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guild?: guildUpdateOneRequiredWithoutMembersInput
    user?: DiscordUserUpdateOneRequiredWithoutUsersOnGuildsInput
  }

  export type UsersOnGuildsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    guildId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersOnGuildsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersOnGuildsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    guildId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminOnGuildsCreateInput = {
    createdAt?: Date | string
    guild: guildCreateNestedOneWithoutAdminsInput
    user: DiscordUserCreateNestedOneWithoutAdministatesInput
  }

  export type AdminOnGuildsUncheckedCreateInput = {
    userId: string
    guildId: number
    createdAt?: Date | string
  }

  export type AdminOnGuildsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guild?: guildUpdateOneRequiredWithoutAdminsInput
    user?: DiscordUserUpdateOneRequiredWithoutAdministatesInput
  }

  export type AdminOnGuildsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    guildId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminOnGuildsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminOnGuildsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    guildId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandCreateInput = {
    id?: string
    registeredAt?: Date | string
    version: number
    usage?: number
    cost?: number
    type: DiscordExecutionType
    url: string
    owner: UserCreateNestedOneWithoutCommandsInput
  }

  export type CommandUncheckedCreateInput = {
    id?: string
    ownerId: string
    registeredAt?: Date | string
    version: number
    usage?: number
    cost?: number
    type: DiscordExecutionType
    url: string
  }

  export type CommandUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    usage?: IntFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    type?: EnumDiscordExecutionTypeFieldUpdateOperationsInput | DiscordExecutionType
    url?: StringFieldUpdateOperationsInput | string
    owner?: UserUpdateOneRequiredWithoutCommandsInput
  }

  export type CommandUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    usage?: IntFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    type?: EnumDiscordExecutionTypeFieldUpdateOperationsInput | DiscordExecutionType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type CommandUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    usage?: IntFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    type?: EnumDiscordExecutionTypeFieldUpdateOperationsInput | DiscordExecutionType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type CommandUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    usage?: IntFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    type?: EnumDiscordExecutionTypeFieldUpdateOperationsInput | DiscordExecutionType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ActionCreateInput = {
    registeredAt?: Date | string
    version: number
    usage?: number
    cost?: number
    type: DiscordExecutionType
    url: string
    owner: UserCreateNestedOneWithoutActionsInput
  }

  export type ActionUncheckedCreateInput = {
    id?: number
    ownerId: string
    registeredAt?: Date | string
    version: number
    usage?: number
    cost?: number
    type: DiscordExecutionType
    url: string
  }

  export type ActionUpdateInput = {
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    usage?: IntFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    type?: EnumDiscordExecutionTypeFieldUpdateOperationsInput | DiscordExecutionType
    url?: StringFieldUpdateOperationsInput | string
    owner?: UserUpdateOneRequiredWithoutActionsInput
  }

  export type ActionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    usage?: IntFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    type?: EnumDiscordExecutionTypeFieldUpdateOperationsInput | DiscordExecutionType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ActionUpdateManyMutationInput = {
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    usage?: IntFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    type?: EnumDiscordExecutionTypeFieldUpdateOperationsInput | DiscordExecutionType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ActionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    usage?: IntFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    type?: EnumDiscordExecutionTypeFieldUpdateOperationsInput | DiscordExecutionType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type TwitchUserCreateInput = {
    username: string
    accessToken: string
    refreshToken: string
    user?: UserCreateNestedOneWithoutTwitchInput
  }

  export type TwitchUserUncheckedCreateInput = {
    id?: number
    username: string
    accessToken: string
    refreshToken: string
    userId?: string | null
  }

  export type TwitchUserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutTwitchInput
  }

  export type TwitchUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TwitchUserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
  }

  export type TwitchUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TwitchAuthCreateInput = {
    clientID: string
    twitchSecret: string
    sessionSecret: string
    Bot?: BotCreateNestedManyWithoutTwitchAuthInput
  }

  export type TwitchAuthUncheckedCreateInput = {
    id?: number
    clientID: string
    twitchSecret: string
    sessionSecret: string
    Bot?: BotUncheckedCreateNestedManyWithoutTwitchAuthInput
  }

  export type TwitchAuthUpdateInput = {
    clientID?: StringFieldUpdateOperationsInput | string
    twitchSecret?: StringFieldUpdateOperationsInput | string
    sessionSecret?: StringFieldUpdateOperationsInput | string
    Bot?: BotUpdateManyWithoutTwitchAuthInput
  }

  export type TwitchAuthUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientID?: StringFieldUpdateOperationsInput | string
    twitchSecret?: StringFieldUpdateOperationsInput | string
    sessionSecret?: StringFieldUpdateOperationsInput | string
    Bot?: BotUncheckedUpdateManyWithoutTwitchAuthInput
  }

  export type TwitchAuthUpdateManyMutationInput = {
    clientID?: StringFieldUpdateOperationsInput | string
    twitchSecret?: StringFieldUpdateOperationsInput | string
    sessionSecret?: StringFieldUpdateOperationsInput | string
  }

  export type TwitchAuthUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientID?: StringFieldUpdateOperationsInput | string
    twitchSecret?: StringFieldUpdateOperationsInput | string
    sessionSecret?: StringFieldUpdateOperationsInput | string
  }

  export type TwitterUserCreateInput = {
    id: string
    username: string
    discrim: number
    user?: UserCreateNestedOneWithoutTwitterUserInput
  }

  export type TwitterUserUncheckedCreateInput = {
    id: string
    username: string
    discrim: number
    userId?: string | null
  }

  export type TwitterUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discrim?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutTwitterUserInput
  }

  export type TwitterUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discrim?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TwitterUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discrim?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discrim?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type EnumManagerLevelsFilter = {
    equals?: ManagerLevels
    in?: Enumerable<ManagerLevels>
    notIn?: Enumerable<ManagerLevels>
    not?: NestedEnumManagerLevelsFilter | ManagerLevels
  }

  export type JsonNullableListFilter = {
    equals?: Enumerable<InputJsonValue> | null
    has?: InputJsonValue | null
    hasEvery?: Enumerable<InputJsonValue>
    hasSome?: Enumerable<InputJsonValue>
    isEmpty?: boolean
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ManagerRelationFilter = {
    is?: ManagerWhereInput
    isNot?: ManagerWhereInput
  }

  export type ManagerListRelationFilter = {
    every?: ManagerWhereInput
    some?: ManagerWhereInput
    none?: ManagerWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: transactionWhereInput
    some?: transactionWhereInput
    none?: transactionWhereInput
  }

  export type BotListRelationFilter = {
    every?: BotWhereInput
    some?: BotWhereInput
    none?: BotWhereInput
  }

  export type ShardListRelationFilter = {
    every?: ShardWhereInput
    some?: ShardWhereInput
    none?: ShardWhereInput
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type HostRelationFilter = {
    is?: HostWhereInput
    isNot?: HostWhereInput
  }

  export type TwitchAuthRelationFilter = {
    is?: TwitchAuthWhereInput
    isNot?: TwitchAuthWhereInput
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type EnumShardStatusFilter = {
    equals?: ShardStatus
    in?: Enumerable<ShardStatus>
    notIn?: Enumerable<ShardStatus>
    not?: NestedEnumShardStatusFilter | ShardStatus
  }

  export type BotRelationFilter = {
    is?: BotWhereInput
    isNot?: BotWhereInput
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type ActionListRelationFilter = {
    every?: ActionWhereInput
    some?: ActionWhereInput
    none?: ActionWhereInput
  }

  export type CommandListRelationFilter = {
    every?: CommandWhereInput
    some?: CommandWhereInput
    none?: CommandWhereInput
  }

  export type DiscordUserRelationFilter = {
    is?: DiscordUserWhereInput
    isNot?: DiscordUserWhereInput
  }

  export type HostListRelationFilter = {
    every?: HostWhereInput
    some?: HostWhereInput
    none?: HostWhereInput
  }

  export type PATListRelationFilter = {
    every?: PATWhereInput
    some?: PATWhereInput
    none?: PATWhereInput
  }

  export type TwitchUserRelationFilter = {
    is?: TwitchUserWhereInput | null
    isNot?: TwitchUserWhereInput | null
  }

  export type TwitterUserListRelationFilter = {
    every?: TwitterUserWhereInput
    some?: TwitterUserWhereInput
    none?: TwitterUserWhereInput
  }

  export type EnumPATStatusFilter = {
    equals?: PATStatus
    in?: Enumerable<PATStatus>
    notIn?: Enumerable<PATStatus>
    not?: NestedEnumPATStatusFilter | PATStatus
  }

  export type PATRelationFilter = {
    is?: PATWhereInput | null
    isNot?: PATWhereInput | null
  }

  export type AdminOnGuildsListRelationFilter = {
    every?: AdminOnGuildsWhereInput
    some?: AdminOnGuildsWhereInput
    none?: AdminOnGuildsWhereInput
  }

  export type UsersOnGuildsListRelationFilter = {
    every?: UsersOnGuildsWhereInput
    some?: UsersOnGuildsWhereInput
    none?: UsersOnGuildsWhereInput
  }

  export type GuildRelationFilter = {
    is?: guildWhereInput
    isNot?: guildWhereInput
  }

  export type UsersOnGuildsUserIdGuildIdCompoundUniqueInput = {
    userId: string
    guildId: number
  }

  export type AdminOnGuildsUserIdGuildIdCompoundUniqueInput = {
    userId: string
    guildId: number
  }

  export type EnumDiscordExecutionTypeFilter = {
    equals?: DiscordExecutionType
    in?: Enumerable<DiscordExecutionType>
    notIn?: Enumerable<DiscordExecutionType>
    not?: NestedEnumDiscordExecutionTypeFilter | DiscordExecutionType
  }

  export type ManagerCreatedowntimeHistoryInput = {
    set: Enumerable<InputJsonValue>
  }

  export type UserCreateNestedOneWithoutManagerInput = {
    create?: XOR<UserUncheckedCreateWithoutManagerInput, UserCreateWithoutManagerInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput
    connect?: UserWhereUniqueInput
  }

  export type ManagerCreateNestedOneWithoutChildManagersInput = {
    create?: XOR<ManagerUncheckedCreateWithoutChildManagersInput, ManagerCreateWithoutChildManagersInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutchildManagersInput
    connect?: ManagerWhereUniqueInput
  }

  export type ManagerCreateNestedManyWithoutParentManagerInput = {
    create?: XOR<Enumerable<ManagerUncheckedCreateWithoutParentManagerInput>, Enumerable<ManagerCreateWithoutParentManagerInput>>
    connectOrCreate?: Enumerable<ManagerCreateOrConnectWithoutparentManagerInput>
    connect?: Enumerable<ManagerWhereUniqueInput>
  }

  export type transactionCreateNestedManyWithoutResponsibleManagerInput = {
    create?: XOR<Enumerable<transactionUncheckedCreateWithoutResponsibleManagerInput>, Enumerable<transactionCreateWithoutResponsibleManagerInput>>
    connectOrCreate?: Enumerable<transactionCreateOrConnectWithoutresponsibleManagerInput>
    connect?: Enumerable<transactionWhereUniqueInput>
  }

  export type ManagerCreateNestedManyWithoutManager_AInput = {
    create?: XOR<Enumerable<ManagerUncheckedCreateWithoutManager_AInput>, Enumerable<ManagerCreateWithoutManager_AInput>>
    connectOrCreate?: Enumerable<ManagerCreateOrConnectWithoutManager_AInput>
    connect?: Enumerable<ManagerWhereUniqueInput>
  }

  export type ManagerCreateNestedManyWithoutManager_BInput = {
    create?: XOR<Enumerable<ManagerUncheckedCreateWithoutManager_BInput>, Enumerable<ManagerCreateWithoutManager_BInput>>
    connectOrCreate?: Enumerable<ManagerCreateOrConnectWithoutManager_BInput>
    connect?: Enumerable<ManagerWhereUniqueInput>
  }

  export type ManagerUncheckedCreateNestedManyWithoutParentManagerInput = {
    create?: XOR<Enumerable<ManagerUncheckedCreateWithoutParentManagerInput>, Enumerable<ManagerCreateWithoutParentManagerInput>>
    connectOrCreate?: Enumerable<ManagerCreateOrConnectWithoutparentManagerInput>
    connect?: Enumerable<ManagerWhereUniqueInput>
  }

  export type transactionUncheckedCreateNestedManyWithoutResponsibleManagerInput = {
    create?: XOR<Enumerable<transactionUncheckedCreateWithoutResponsibleManagerInput>, Enumerable<transactionCreateWithoutResponsibleManagerInput>>
    connectOrCreate?: Enumerable<transactionCreateOrConnectWithoutresponsibleManagerInput>
    connect?: Enumerable<transactionWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumManagerLevelsFieldUpdateOperationsInput = {
    set?: ManagerLevels
  }

  export type ManagerUpdatedowntimeHistoryInput = {
    set: Enumerable<InputJsonValue>
  }

  export type UserUpdateOneRequiredWithoutManagerInput = {
    create?: XOR<UserUncheckedCreateWithoutManagerInput, UserCreateWithoutManagerInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput
    upsert?: UserUpsertWithoutManagerInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutManagerInput, UserUpdateWithoutManagerInput>
  }

  export type ManagerUpdateOneWithoutChildManagersInput = {
    create?: XOR<ManagerUncheckedCreateWithoutChildManagersInput, ManagerCreateWithoutChildManagersInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutchildManagersInput
    upsert?: ManagerUpsertWithoutChildManagersInput
    connect?: ManagerWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ManagerUncheckedUpdateWithoutChildManagersInput, ManagerUpdateWithoutChildManagersInput>
  }

  export type ManagerUpdateManyWithoutParentManagerInput = {
    create?: XOR<Enumerable<ManagerUncheckedCreateWithoutParentManagerInput>, Enumerable<ManagerCreateWithoutParentManagerInput>>
    connectOrCreate?: Enumerable<ManagerCreateOrConnectWithoutparentManagerInput>
    upsert?: Enumerable<ManagerUpsertWithWhereUniqueWithoutParentManagerInput>
    connect?: Enumerable<ManagerWhereUniqueInput>
    set?: Enumerable<ManagerWhereUniqueInput>
    disconnect?: Enumerable<ManagerWhereUniqueInput>
    delete?: Enumerable<ManagerWhereUniqueInput>
    update?: Enumerable<ManagerUpdateWithWhereUniqueWithoutParentManagerInput>
    updateMany?: Enumerable<ManagerUpdateManyWithWhereWithoutParentManagerInput>
    deleteMany?: Enumerable<ManagerScalarWhereInput>
  }

  export type transactionUpdateManyWithoutResponsibleManagerInput = {
    create?: XOR<Enumerable<transactionUncheckedCreateWithoutResponsibleManagerInput>, Enumerable<transactionCreateWithoutResponsibleManagerInput>>
    connectOrCreate?: Enumerable<transactionCreateOrConnectWithoutresponsibleManagerInput>
    upsert?: Enumerable<transactionUpsertWithWhereUniqueWithoutResponsibleManagerInput>
    connect?: Enumerable<transactionWhereUniqueInput>
    set?: Enumerable<transactionWhereUniqueInput>
    disconnect?: Enumerable<transactionWhereUniqueInput>
    delete?: Enumerable<transactionWhereUniqueInput>
    update?: Enumerable<transactionUpdateWithWhereUniqueWithoutResponsibleManagerInput>
    updateMany?: Enumerable<transactionUpdateManyWithWhereWithoutResponsibleManagerInput>
    deleteMany?: Enumerable<transactionScalarWhereInput>
  }

  export type ManagerUpdateManyWithoutManager_AInput = {
    create?: XOR<Enumerable<ManagerUncheckedCreateWithoutManager_AInput>, Enumerable<ManagerCreateWithoutManager_AInput>>
    connectOrCreate?: Enumerable<ManagerCreateOrConnectWithoutManager_AInput>
    upsert?: Enumerable<ManagerUpsertWithWhereUniqueWithoutManager_AInput>
    connect?: Enumerable<ManagerWhereUniqueInput>
    set?: Enumerable<ManagerWhereUniqueInput>
    disconnect?: Enumerable<ManagerWhereUniqueInput>
    delete?: Enumerable<ManagerWhereUniqueInput>
    update?: Enumerable<ManagerUpdateWithWhereUniqueWithoutManager_AInput>
    updateMany?: Enumerable<ManagerUpdateManyWithWhereWithoutManager_AInput>
    deleteMany?: Enumerable<ManagerScalarWhereInput>
  }

  export type ManagerUpdateManyWithoutManager_BInput = {
    create?: XOR<Enumerable<ManagerUncheckedCreateWithoutManager_BInput>, Enumerable<ManagerCreateWithoutManager_BInput>>
    connectOrCreate?: Enumerable<ManagerCreateOrConnectWithoutManager_BInput>
    upsert?: Enumerable<ManagerUpsertWithWhereUniqueWithoutManager_BInput>
    connect?: Enumerable<ManagerWhereUniqueInput>
    set?: Enumerable<ManagerWhereUniqueInput>
    disconnect?: Enumerable<ManagerWhereUniqueInput>
    delete?: Enumerable<ManagerWhereUniqueInput>
    update?: Enumerable<ManagerUpdateWithWhereUniqueWithoutManager_BInput>
    updateMany?: Enumerable<ManagerUpdateManyWithWhereWithoutManager_BInput>
    deleteMany?: Enumerable<ManagerScalarWhereInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ManagerUncheckedUpdateManyWithoutParentManagerInput = {
    create?: XOR<Enumerable<ManagerUncheckedCreateWithoutParentManagerInput>, Enumerable<ManagerCreateWithoutParentManagerInput>>
    connectOrCreate?: Enumerable<ManagerCreateOrConnectWithoutparentManagerInput>
    upsert?: Enumerable<ManagerUpsertWithWhereUniqueWithoutParentManagerInput>
    connect?: Enumerable<ManagerWhereUniqueInput>
    set?: Enumerable<ManagerWhereUniqueInput>
    disconnect?: Enumerable<ManagerWhereUniqueInput>
    delete?: Enumerable<ManagerWhereUniqueInput>
    update?: Enumerable<ManagerUpdateWithWhereUniqueWithoutParentManagerInput>
    updateMany?: Enumerable<ManagerUpdateManyWithWhereWithoutParentManagerInput>
    deleteMany?: Enumerable<ManagerScalarWhereInput>
  }

  export type transactionUncheckedUpdateManyWithoutResponsibleManagerInput = {
    create?: XOR<Enumerable<transactionUncheckedCreateWithoutResponsibleManagerInput>, Enumerable<transactionCreateWithoutResponsibleManagerInput>>
    connectOrCreate?: Enumerable<transactionCreateOrConnectWithoutresponsibleManagerInput>
    upsert?: Enumerable<transactionUpsertWithWhereUniqueWithoutResponsibleManagerInput>
    connect?: Enumerable<transactionWhereUniqueInput>
    set?: Enumerable<transactionWhereUniqueInput>
    disconnect?: Enumerable<transactionWhereUniqueInput>
    delete?: Enumerable<transactionWhereUniqueInput>
    update?: Enumerable<transactionUpdateWithWhereUniqueWithoutResponsibleManagerInput>
    updateMany?: Enumerable<transactionUpdateManyWithWhereWithoutResponsibleManagerInput>
    deleteMany?: Enumerable<transactionScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutHostsInput = {
    create?: XOR<UserUncheckedCreateWithoutHostsInput, UserCreateWithoutHostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHostsInput
    connect?: UserWhereUniqueInput
  }

  export type BotCreateNestedManyWithoutHostsInput = {
    create?: XOR<Enumerable<BotUncheckedCreateWithoutHostsInput>, Enumerable<BotCreateWithoutHostsInput>>
    connectOrCreate?: Enumerable<BotCreateOrConnectWithouthostsInput>
    connect?: Enumerable<BotWhereUniqueInput>
  }

  export type BotCreateNestedManyWithoutPriorityHostInput = {
    create?: XOR<Enumerable<BotUncheckedCreateWithoutPriorityHostInput>, Enumerable<BotCreateWithoutPriorityHostInput>>
    connectOrCreate?: Enumerable<BotCreateOrConnectWithoutpriorityHostInput>
    connect?: Enumerable<BotWhereUniqueInput>
  }

  export type ShardCreateNestedManyWithoutHostInput = {
    create?: XOR<Enumerable<ShardUncheckedCreateWithoutHostInput>, Enumerable<ShardCreateWithoutHostInput>>
    connectOrCreate?: Enumerable<ShardCreateOrConnectWithoutHostInput>
    connect?: Enumerable<ShardWhereUniqueInput>
  }

  export type BotUncheckedCreateNestedManyWithoutHostsInput = {
    create?: XOR<Enumerable<BotUncheckedCreateWithoutHostsInput>, Enumerable<BotCreateWithoutHostsInput>>
    connectOrCreate?: Enumerable<BotCreateOrConnectWithouthostsInput>
    connect?: Enumerable<BotWhereUniqueInput>
  }

  export type BotUncheckedCreateNestedManyWithoutPriorityHostInput = {
    create?: XOR<Enumerable<BotUncheckedCreateWithoutPriorityHostInput>, Enumerable<BotCreateWithoutPriorityHostInput>>
    connectOrCreate?: Enumerable<BotCreateOrConnectWithoutpriorityHostInput>
    connect?: Enumerable<BotWhereUniqueInput>
  }

  export type ShardUncheckedCreateNestedManyWithoutHostInput = {
    create?: XOR<Enumerable<ShardUncheckedCreateWithoutHostInput>, Enumerable<ShardCreateWithoutHostInput>>
    connectOrCreate?: Enumerable<ShardCreateOrConnectWithoutHostInput>
    connect?: Enumerable<ShardWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutHostsInput = {
    create?: XOR<UserUncheckedCreateWithoutHostsInput, UserCreateWithoutHostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHostsInput
    upsert?: UserUpsertWithoutHostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutHostsInput, UserUpdateWithoutHostsInput>
  }

  export type BotUpdateManyWithoutHostsInput = {
    create?: XOR<Enumerable<BotUncheckedCreateWithoutHostsInput>, Enumerable<BotCreateWithoutHostsInput>>
    connectOrCreate?: Enumerable<BotCreateOrConnectWithouthostsInput>
    upsert?: Enumerable<BotUpsertWithWhereUniqueWithoutHostsInput>
    connect?: Enumerable<BotWhereUniqueInput>
    set?: Enumerable<BotWhereUniqueInput>
    disconnect?: Enumerable<BotWhereUniqueInput>
    delete?: Enumerable<BotWhereUniqueInput>
    update?: Enumerable<BotUpdateWithWhereUniqueWithoutHostsInput>
    updateMany?: Enumerable<BotUpdateManyWithWhereWithoutHostsInput>
    deleteMany?: Enumerable<BotScalarWhereInput>
  }

  export type BotUpdateManyWithoutPriorityHostInput = {
    create?: XOR<Enumerable<BotUncheckedCreateWithoutPriorityHostInput>, Enumerable<BotCreateWithoutPriorityHostInput>>
    connectOrCreate?: Enumerable<BotCreateOrConnectWithoutpriorityHostInput>
    upsert?: Enumerable<BotUpsertWithWhereUniqueWithoutPriorityHostInput>
    connect?: Enumerable<BotWhereUniqueInput>
    set?: Enumerable<BotWhereUniqueInput>
    disconnect?: Enumerable<BotWhereUniqueInput>
    delete?: Enumerable<BotWhereUniqueInput>
    update?: Enumerable<BotUpdateWithWhereUniqueWithoutPriorityHostInput>
    updateMany?: Enumerable<BotUpdateManyWithWhereWithoutPriorityHostInput>
    deleteMany?: Enumerable<BotScalarWhereInput>
  }

  export type ShardUpdateManyWithoutHostInput = {
    create?: XOR<Enumerable<ShardUncheckedCreateWithoutHostInput>, Enumerable<ShardCreateWithoutHostInput>>
    connectOrCreate?: Enumerable<ShardCreateOrConnectWithoutHostInput>
    upsert?: Enumerable<ShardUpsertWithWhereUniqueWithoutHostInput>
    connect?: Enumerable<ShardWhereUniqueInput>
    set?: Enumerable<ShardWhereUniqueInput>
    disconnect?: Enumerable<ShardWhereUniqueInput>
    delete?: Enumerable<ShardWhereUniqueInput>
    update?: Enumerable<ShardUpdateWithWhereUniqueWithoutHostInput>
    updateMany?: Enumerable<ShardUpdateManyWithWhereWithoutHostInput>
    deleteMany?: Enumerable<ShardScalarWhereInput>
  }

  export type BotUncheckedUpdateManyWithoutHostsInput = {
    create?: XOR<Enumerable<BotUncheckedCreateWithoutHostsInput>, Enumerable<BotCreateWithoutHostsInput>>
    connectOrCreate?: Enumerable<BotCreateOrConnectWithouthostsInput>
    upsert?: Enumerable<BotUpsertWithWhereUniqueWithoutHostsInput>
    connect?: Enumerable<BotWhereUniqueInput>
    set?: Enumerable<BotWhereUniqueInput>
    disconnect?: Enumerable<BotWhereUniqueInput>
    delete?: Enumerable<BotWhereUniqueInput>
    update?: Enumerable<BotUpdateWithWhereUniqueWithoutHostsInput>
    updateMany?: Enumerable<BotUpdateManyWithWhereWithoutHostsInput>
    deleteMany?: Enumerable<BotScalarWhereInput>
  }

  export type BotUncheckedUpdateManyWithoutPriorityHostInput = {
    create?: XOR<Enumerable<BotUncheckedCreateWithoutPriorityHostInput>, Enumerable<BotCreateWithoutPriorityHostInput>>
    connectOrCreate?: Enumerable<BotCreateOrConnectWithoutpriorityHostInput>
    upsert?: Enumerable<BotUpsertWithWhereUniqueWithoutPriorityHostInput>
    connect?: Enumerable<BotWhereUniqueInput>
    set?: Enumerable<BotWhereUniqueInput>
    disconnect?: Enumerable<BotWhereUniqueInput>
    delete?: Enumerable<BotWhereUniqueInput>
    update?: Enumerable<BotUpdateWithWhereUniqueWithoutPriorityHostInput>
    updateMany?: Enumerable<BotUpdateManyWithWhereWithoutPriorityHostInput>
    deleteMany?: Enumerable<BotScalarWhereInput>
  }

  export type ShardUncheckedUpdateManyWithoutHostInput = {
    create?: XOR<Enumerable<ShardUncheckedCreateWithoutHostInput>, Enumerable<ShardCreateWithoutHostInput>>
    connectOrCreate?: Enumerable<ShardCreateOrConnectWithoutHostInput>
    upsert?: Enumerable<ShardUpsertWithWhereUniqueWithoutHostInput>
    connect?: Enumerable<ShardWhereUniqueInput>
    set?: Enumerable<ShardWhereUniqueInput>
    disconnect?: Enumerable<ShardWhereUniqueInput>
    delete?: Enumerable<ShardWhereUniqueInput>
    update?: Enumerable<ShardUpdateWithWhereUniqueWithoutHostInput>
    updateMany?: Enumerable<ShardUpdateManyWithWhereWithoutHostInput>
    deleteMany?: Enumerable<ShardScalarWhereInput>
  }

  export type HostCreateNestedOneWithoutBotsInput = {
    create?: XOR<HostUncheckedCreateWithoutBotsInput, HostCreateWithoutBotsInput>
    connectOrCreate?: HostCreateOrConnectWithoutbotsInput
    connect?: HostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBotInput = {
    create?: XOR<UserUncheckedCreateWithoutBotInput, UserCreateWithoutBotInput>
    connectOrCreate?: UserCreateOrConnectWithoutBotInput
    connect?: UserWhereUniqueInput
  }

  export type HostCreateNestedOneWithoutPriorityBotInput = {
    create?: XOR<HostUncheckedCreateWithoutPriorityBotInput, HostCreateWithoutPriorityBotInput>
    connectOrCreate?: HostCreateOrConnectWithoutpriorityBotInput
    connect?: HostWhereUniqueInput
  }

  export type TwitchAuthCreateNestedOneWithoutBotInput = {
    create?: XOR<TwitchAuthUncheckedCreateWithoutBotInput, TwitchAuthCreateWithoutBotInput>
    connectOrCreate?: TwitchAuthCreateOrConnectWithoutBotInput
    connect?: TwitchAuthWhereUniqueInput
  }

  export type ShardCreateNestedManyWithoutBotInput = {
    create?: XOR<Enumerable<ShardUncheckedCreateWithoutBotInput>, Enumerable<ShardCreateWithoutBotInput>>
    connectOrCreate?: Enumerable<ShardCreateOrConnectWithoutbotInput>
    connect?: Enumerable<ShardWhereUniqueInput>
  }

  export type ShardUncheckedCreateNestedManyWithoutBotInput = {
    create?: XOR<Enumerable<ShardUncheckedCreateWithoutBotInput>, Enumerable<ShardCreateWithoutBotInput>>
    connectOrCreate?: Enumerable<ShardCreateOrConnectWithoutbotInput>
    connect?: Enumerable<ShardWhereUniqueInput>
  }

  export type HostUpdateOneRequiredWithoutBotsInput = {
    create?: XOR<HostUncheckedCreateWithoutBotsInput, HostCreateWithoutBotsInput>
    connectOrCreate?: HostCreateOrConnectWithoutbotsInput
    upsert?: HostUpsertWithoutBotsInput
    connect?: HostWhereUniqueInput
    update?: XOR<HostUncheckedUpdateWithoutBotsInput, HostUpdateWithoutBotsInput>
  }

  export type UserUpdateOneRequiredWithoutBotInput = {
    create?: XOR<UserUncheckedCreateWithoutBotInput, UserCreateWithoutBotInput>
    connectOrCreate?: UserCreateOrConnectWithoutBotInput
    upsert?: UserUpsertWithoutBotInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutBotInput, UserUpdateWithoutBotInput>
  }

  export type HostUpdateOneWithoutPriorityBotInput = {
    create?: XOR<HostUncheckedCreateWithoutPriorityBotInput, HostCreateWithoutPriorityBotInput>
    connectOrCreate?: HostCreateOrConnectWithoutpriorityBotInput
    upsert?: HostUpsertWithoutPriorityBotInput
    connect?: HostWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<HostUncheckedUpdateWithoutPriorityBotInput, HostUpdateWithoutPriorityBotInput>
  }

  export type TwitchAuthUpdateOneRequiredWithoutBotInput = {
    create?: XOR<TwitchAuthUncheckedCreateWithoutBotInput, TwitchAuthCreateWithoutBotInput>
    connectOrCreate?: TwitchAuthCreateOrConnectWithoutBotInput
    upsert?: TwitchAuthUpsertWithoutBotInput
    connect?: TwitchAuthWhereUniqueInput
    update?: XOR<TwitchAuthUncheckedUpdateWithoutBotInput, TwitchAuthUpdateWithoutBotInput>
  }

  export type ShardUpdateManyWithoutBotInput = {
    create?: XOR<Enumerable<ShardUncheckedCreateWithoutBotInput>, Enumerable<ShardCreateWithoutBotInput>>
    connectOrCreate?: Enumerable<ShardCreateOrConnectWithoutbotInput>
    upsert?: Enumerable<ShardUpsertWithWhereUniqueWithoutBotInput>
    connect?: Enumerable<ShardWhereUniqueInput>
    set?: Enumerable<ShardWhereUniqueInput>
    disconnect?: Enumerable<ShardWhereUniqueInput>
    delete?: Enumerable<ShardWhereUniqueInput>
    update?: Enumerable<ShardUpdateWithWhereUniqueWithoutBotInput>
    updateMany?: Enumerable<ShardUpdateManyWithWhereWithoutBotInput>
    deleteMany?: Enumerable<ShardScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ShardUncheckedUpdateManyWithoutBotInput = {
    create?: XOR<Enumerable<ShardUncheckedCreateWithoutBotInput>, Enumerable<ShardCreateWithoutBotInput>>
    connectOrCreate?: Enumerable<ShardCreateOrConnectWithoutbotInput>
    upsert?: Enumerable<ShardUpsertWithWhereUniqueWithoutBotInput>
    connect?: Enumerable<ShardWhereUniqueInput>
    set?: Enumerable<ShardWhereUniqueInput>
    disconnect?: Enumerable<ShardWhereUniqueInput>
    delete?: Enumerable<ShardWhereUniqueInput>
    update?: Enumerable<ShardUpdateWithWhereUniqueWithoutBotInput>
    updateMany?: Enumerable<ShardUpdateManyWithWhereWithoutBotInput>
    deleteMany?: Enumerable<ShardScalarWhereInput>
  }

  export type BotCreateNestedOneWithoutShardsInput = {
    create?: XOR<BotUncheckedCreateWithoutShardsInput, BotCreateWithoutShardsInput>
    connectOrCreate?: BotCreateOrConnectWithoutshardsInput
    connect?: BotWhereUniqueInput
  }

  export type HostCreateNestedOneWithoutShardsInput = {
    create?: XOR<HostUncheckedCreateWithoutShardsInput, HostCreateWithoutShardsInput>
    connectOrCreate?: HostCreateOrConnectWithoutshardsInput
    connect?: HostWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumShardStatusFieldUpdateOperationsInput = {
    set?: ShardStatus
  }

  export type BotUpdateOneRequiredWithoutShardsInput = {
    create?: XOR<BotUncheckedCreateWithoutShardsInput, BotCreateWithoutShardsInput>
    connectOrCreate?: BotCreateOrConnectWithoutshardsInput
    upsert?: BotUpsertWithoutShardsInput
    connect?: BotWhereUniqueInput
    update?: XOR<BotUncheckedUpdateWithoutShardsInput, BotUpdateWithoutShardsInput>
  }

  export type HostUpdateOneRequiredWithoutShardsInput = {
    create?: XOR<HostUncheckedCreateWithoutShardsInput, HostCreateWithoutShardsInput>
    connectOrCreate?: HostCreateOrConnectWithoutshardsInput
    upsert?: HostUpsertWithoutShardsInput
    connect?: HostWhereUniqueInput
    update?: XOR<HostUncheckedUpdateWithoutShardsInput, HostUpdateWithoutShardsInput>
  }

  export type ActionCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<ActionUncheckedCreateWithoutOwnerInput>, Enumerable<ActionCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<ActionCreateOrConnectWithoutownerInput>
    connect?: Enumerable<ActionWhereUniqueInput>
  }

  export type BotCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<BotUncheckedCreateWithoutOwnerInput>, Enumerable<BotCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<BotCreateOrConnectWithoutownerInput>
    connect?: Enumerable<BotWhereUniqueInput>
  }

  export type CommandCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<CommandUncheckedCreateWithoutOwnerInput>, Enumerable<CommandCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<CommandCreateOrConnectWithoutownerInput>
    connect?: Enumerable<CommandWhereUniqueInput>
  }

  export type DiscordUserCreateNestedOneWithoutUserInput = {
    create?: XOR<DiscordUserUncheckedCreateWithoutUserInput, DiscordUserCreateWithoutUserInput>
    connectOrCreate?: DiscordUserCreateOrConnectWithoutuserInput
    connect?: DiscordUserWhereUniqueInput
  }

  export type HostCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<HostUncheckedCreateWithoutOwnerInput>, Enumerable<HostCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<HostCreateOrConnectWithoutownerInput>
    connect?: Enumerable<HostWhereUniqueInput>
  }

  export type ManagerCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<ManagerUncheckedCreateWithoutOwnerInput>, Enumerable<ManagerCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<ManagerCreateOrConnectWithoutownerInput>
    connect?: Enumerable<ManagerWhereUniqueInput>
  }

  export type PATCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PATUncheckedCreateWithoutUserInput>, Enumerable<PATCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PATCreateOrConnectWithoutuserInput>
    connect?: Enumerable<PATWhereUniqueInput>
  }

  export type TwitchUserCreateNestedOneWithoutUserInput = {
    create?: XOR<TwitchUserUncheckedCreateWithoutUserInput, TwitchUserCreateWithoutUserInput>
    connectOrCreate?: TwitchUserCreateOrConnectWithoutuserInput
    connect?: TwitchUserWhereUniqueInput
  }

  export type TwitterUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TwitterUserUncheckedCreateWithoutUserInput>, Enumerable<TwitterUserCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterUserCreateOrConnectWithoutuserInput>
    connect?: Enumerable<TwitterUserWhereUniqueInput>
  }

  export type ActionUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<ActionUncheckedCreateWithoutOwnerInput>, Enumerable<ActionCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<ActionCreateOrConnectWithoutownerInput>
    connect?: Enumerable<ActionWhereUniqueInput>
  }

  export type BotUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<BotUncheckedCreateWithoutOwnerInput>, Enumerable<BotCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<BotCreateOrConnectWithoutownerInput>
    connect?: Enumerable<BotWhereUniqueInput>
  }

  export type CommandUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<CommandUncheckedCreateWithoutOwnerInput>, Enumerable<CommandCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<CommandCreateOrConnectWithoutownerInput>
    connect?: Enumerable<CommandWhereUniqueInput>
  }

  export type DiscordUserUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DiscordUserUncheckedCreateWithoutUserInput, DiscordUserCreateWithoutUserInput>
    connectOrCreate?: DiscordUserCreateOrConnectWithoutuserInput
    connect?: DiscordUserWhereUniqueInput
  }

  export type HostUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<HostUncheckedCreateWithoutOwnerInput>, Enumerable<HostCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<HostCreateOrConnectWithoutownerInput>
    connect?: Enumerable<HostWhereUniqueInput>
  }

  export type ManagerUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<ManagerUncheckedCreateWithoutOwnerInput>, Enumerable<ManagerCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<ManagerCreateOrConnectWithoutownerInput>
    connect?: Enumerable<ManagerWhereUniqueInput>
  }

  export type PATUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PATUncheckedCreateWithoutUserInput>, Enumerable<PATCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PATCreateOrConnectWithoutuserInput>
    connect?: Enumerable<PATWhereUniqueInput>
  }

  export type TwitchUserUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TwitchUserUncheckedCreateWithoutUserInput, TwitchUserCreateWithoutUserInput>
    connectOrCreate?: TwitchUserCreateOrConnectWithoutuserInput
    connect?: TwitchUserWhereUniqueInput
  }

  export type TwitterUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TwitterUserUncheckedCreateWithoutUserInput>, Enumerable<TwitterUserCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterUserCreateOrConnectWithoutuserInput>
    connect?: Enumerable<TwitterUserWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ActionUpdateManyWithoutOwnerInput = {
    create?: XOR<Enumerable<ActionUncheckedCreateWithoutOwnerInput>, Enumerable<ActionCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<ActionCreateOrConnectWithoutownerInput>
    upsert?: Enumerable<ActionUpsertWithWhereUniqueWithoutOwnerInput>
    connect?: Enumerable<ActionWhereUniqueInput>
    set?: Enumerable<ActionWhereUniqueInput>
    disconnect?: Enumerable<ActionWhereUniqueInput>
    delete?: Enumerable<ActionWhereUniqueInput>
    update?: Enumerable<ActionUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<ActionUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<ActionScalarWhereInput>
  }

  export type BotUpdateManyWithoutOwnerInput = {
    create?: XOR<Enumerable<BotUncheckedCreateWithoutOwnerInput>, Enumerable<BotCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<BotCreateOrConnectWithoutownerInput>
    upsert?: Enumerable<BotUpsertWithWhereUniqueWithoutOwnerInput>
    connect?: Enumerable<BotWhereUniqueInput>
    set?: Enumerable<BotWhereUniqueInput>
    disconnect?: Enumerable<BotWhereUniqueInput>
    delete?: Enumerable<BotWhereUniqueInput>
    update?: Enumerable<BotUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<BotUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<BotScalarWhereInput>
  }

  export type CommandUpdateManyWithoutOwnerInput = {
    create?: XOR<Enumerable<CommandUncheckedCreateWithoutOwnerInput>, Enumerable<CommandCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<CommandCreateOrConnectWithoutownerInput>
    upsert?: Enumerable<CommandUpsertWithWhereUniqueWithoutOwnerInput>
    connect?: Enumerable<CommandWhereUniqueInput>
    set?: Enumerable<CommandWhereUniqueInput>
    disconnect?: Enumerable<CommandWhereUniqueInput>
    delete?: Enumerable<CommandWhereUniqueInput>
    update?: Enumerable<CommandUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<CommandUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<CommandScalarWhereInput>
  }

  export type DiscordUserUpdateOneWithoutUserInput = {
    create?: XOR<DiscordUserUncheckedCreateWithoutUserInput, DiscordUserCreateWithoutUserInput>
    connectOrCreate?: DiscordUserCreateOrConnectWithoutuserInput
    upsert?: DiscordUserUpsertWithoutUserInput
    connect?: DiscordUserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<DiscordUserUncheckedUpdateWithoutUserInput, DiscordUserUpdateWithoutUserInput>
  }

  export type HostUpdateManyWithoutOwnerInput = {
    create?: XOR<Enumerable<HostUncheckedCreateWithoutOwnerInput>, Enumerable<HostCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<HostCreateOrConnectWithoutownerInput>
    upsert?: Enumerable<HostUpsertWithWhereUniqueWithoutOwnerInput>
    connect?: Enumerable<HostWhereUniqueInput>
    set?: Enumerable<HostWhereUniqueInput>
    disconnect?: Enumerable<HostWhereUniqueInput>
    delete?: Enumerable<HostWhereUniqueInput>
    update?: Enumerable<HostUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<HostUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<HostScalarWhereInput>
  }

  export type ManagerUpdateManyWithoutOwnerInput = {
    create?: XOR<Enumerable<ManagerUncheckedCreateWithoutOwnerInput>, Enumerable<ManagerCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<ManagerCreateOrConnectWithoutownerInput>
    upsert?: Enumerable<ManagerUpsertWithWhereUniqueWithoutOwnerInput>
    connect?: Enumerable<ManagerWhereUniqueInput>
    set?: Enumerable<ManagerWhereUniqueInput>
    disconnect?: Enumerable<ManagerWhereUniqueInput>
    delete?: Enumerable<ManagerWhereUniqueInput>
    update?: Enumerable<ManagerUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<ManagerUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<ManagerScalarWhereInput>
  }

  export type PATUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<PATUncheckedCreateWithoutUserInput>, Enumerable<PATCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PATCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<PATUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<PATWhereUniqueInput>
    set?: Enumerable<PATWhereUniqueInput>
    disconnect?: Enumerable<PATWhereUniqueInput>
    delete?: Enumerable<PATWhereUniqueInput>
    update?: Enumerable<PATUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PATUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PATScalarWhereInput>
  }

  export type TwitchUserUpdateOneWithoutUserInput = {
    create?: XOR<TwitchUserUncheckedCreateWithoutUserInput, TwitchUserCreateWithoutUserInput>
    connectOrCreate?: TwitchUserCreateOrConnectWithoutuserInput
    upsert?: TwitchUserUpsertWithoutUserInput
    connect?: TwitchUserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<TwitchUserUncheckedUpdateWithoutUserInput, TwitchUserUpdateWithoutUserInput>
  }

  export type TwitterUserUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TwitterUserUncheckedCreateWithoutUserInput>, Enumerable<TwitterUserCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterUserCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<TwitterUserUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<TwitterUserWhereUniqueInput>
    set?: Enumerable<TwitterUserWhereUniqueInput>
    disconnect?: Enumerable<TwitterUserWhereUniqueInput>
    delete?: Enumerable<TwitterUserWhereUniqueInput>
    update?: Enumerable<TwitterUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TwitterUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TwitterUserScalarWhereInput>
  }

  export type ActionUncheckedUpdateManyWithoutOwnerInput = {
    create?: XOR<Enumerable<ActionUncheckedCreateWithoutOwnerInput>, Enumerable<ActionCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<ActionCreateOrConnectWithoutownerInput>
    upsert?: Enumerable<ActionUpsertWithWhereUniqueWithoutOwnerInput>
    connect?: Enumerable<ActionWhereUniqueInput>
    set?: Enumerable<ActionWhereUniqueInput>
    disconnect?: Enumerable<ActionWhereUniqueInput>
    delete?: Enumerable<ActionWhereUniqueInput>
    update?: Enumerable<ActionUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<ActionUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<ActionScalarWhereInput>
  }

  export type BotUncheckedUpdateManyWithoutOwnerInput = {
    create?: XOR<Enumerable<BotUncheckedCreateWithoutOwnerInput>, Enumerable<BotCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<BotCreateOrConnectWithoutownerInput>
    upsert?: Enumerable<BotUpsertWithWhereUniqueWithoutOwnerInput>
    connect?: Enumerable<BotWhereUniqueInput>
    set?: Enumerable<BotWhereUniqueInput>
    disconnect?: Enumerable<BotWhereUniqueInput>
    delete?: Enumerable<BotWhereUniqueInput>
    update?: Enumerable<BotUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<BotUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<BotScalarWhereInput>
  }

  export type CommandUncheckedUpdateManyWithoutOwnerInput = {
    create?: XOR<Enumerable<CommandUncheckedCreateWithoutOwnerInput>, Enumerable<CommandCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<CommandCreateOrConnectWithoutownerInput>
    upsert?: Enumerable<CommandUpsertWithWhereUniqueWithoutOwnerInput>
    connect?: Enumerable<CommandWhereUniqueInput>
    set?: Enumerable<CommandWhereUniqueInput>
    disconnect?: Enumerable<CommandWhereUniqueInput>
    delete?: Enumerable<CommandWhereUniqueInput>
    update?: Enumerable<CommandUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<CommandUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<CommandScalarWhereInput>
  }

  export type DiscordUserUncheckedUpdateOneWithoutUserInput = {
    create?: XOR<DiscordUserUncheckedCreateWithoutUserInput, DiscordUserCreateWithoutUserInput>
    connectOrCreate?: DiscordUserCreateOrConnectWithoutuserInput
    upsert?: DiscordUserUpsertWithoutUserInput
    connect?: DiscordUserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<DiscordUserUncheckedUpdateWithoutUserInput, DiscordUserUpdateWithoutUserInput>
  }

  export type HostUncheckedUpdateManyWithoutOwnerInput = {
    create?: XOR<Enumerable<HostUncheckedCreateWithoutOwnerInput>, Enumerable<HostCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<HostCreateOrConnectWithoutownerInput>
    upsert?: Enumerable<HostUpsertWithWhereUniqueWithoutOwnerInput>
    connect?: Enumerable<HostWhereUniqueInput>
    set?: Enumerable<HostWhereUniqueInput>
    disconnect?: Enumerable<HostWhereUniqueInput>
    delete?: Enumerable<HostWhereUniqueInput>
    update?: Enumerable<HostUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<HostUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<HostScalarWhereInput>
  }

  export type ManagerUncheckedUpdateManyWithoutOwnerInput = {
    create?: XOR<Enumerable<ManagerUncheckedCreateWithoutOwnerInput>, Enumerable<ManagerCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<ManagerCreateOrConnectWithoutownerInput>
    upsert?: Enumerable<ManagerUpsertWithWhereUniqueWithoutOwnerInput>
    connect?: Enumerable<ManagerWhereUniqueInput>
    set?: Enumerable<ManagerWhereUniqueInput>
    disconnect?: Enumerable<ManagerWhereUniqueInput>
    delete?: Enumerable<ManagerWhereUniqueInput>
    update?: Enumerable<ManagerUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<ManagerUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<ManagerScalarWhereInput>
  }

  export type PATUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<PATUncheckedCreateWithoutUserInput>, Enumerable<PATCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PATCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<PATUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<PATWhereUniqueInput>
    set?: Enumerable<PATWhereUniqueInput>
    disconnect?: Enumerable<PATWhereUniqueInput>
    delete?: Enumerable<PATWhereUniqueInput>
    update?: Enumerable<PATUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PATUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PATScalarWhereInput>
  }

  export type TwitchUserUncheckedUpdateOneWithoutUserInput = {
    create?: XOR<TwitchUserUncheckedCreateWithoutUserInput, TwitchUserCreateWithoutUserInput>
    connectOrCreate?: TwitchUserCreateOrConnectWithoutuserInput
    upsert?: TwitchUserUpsertWithoutUserInput
    connect?: TwitchUserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<TwitchUserUncheckedUpdateWithoutUserInput, TwitchUserUpdateWithoutUserInput>
  }

  export type TwitterUserUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TwitterUserUncheckedCreateWithoutUserInput>, Enumerable<TwitterUserCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterUserCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<TwitterUserUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<TwitterUserWhereUniqueInput>
    set?: Enumerable<TwitterUserWhereUniqueInput>
    disconnect?: Enumerable<TwitterUserWhereUniqueInput>
    delete?: Enumerable<TwitterUserWhereUniqueInput>
    update?: Enumerable<TwitterUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TwitterUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TwitterUserScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutPatInput = {
    create?: XOR<UserUncheckedCreateWithoutPatInput, UserCreateWithoutPatInput>
    connectOrCreate?: UserCreateOrConnectWithoutpatInput
    connect?: UserWhereUniqueInput
  }

  export type transactionCreateNestedManyWithoutPatInput = {
    create?: XOR<Enumerable<transactionUncheckedCreateWithoutPatInput>, Enumerable<transactionCreateWithoutPatInput>>
    connectOrCreate?: Enumerable<transactionCreateOrConnectWithoutpatInput>
    connect?: Enumerable<transactionWhereUniqueInput>
  }

  export type transactionUncheckedCreateNestedManyWithoutPatInput = {
    create?: XOR<Enumerable<transactionUncheckedCreateWithoutPatInput>, Enumerable<transactionCreateWithoutPatInput>>
    connectOrCreate?: Enumerable<transactionCreateOrConnectWithoutpatInput>
    connect?: Enumerable<transactionWhereUniqueInput>
  }

  export type EnumPATStatusFieldUpdateOperationsInput = {
    set?: PATStatus
  }

  export type UserUpdateOneRequiredWithoutPatInput = {
    create?: XOR<UserUncheckedCreateWithoutPatInput, UserCreateWithoutPatInput>
    connectOrCreate?: UserCreateOrConnectWithoutpatInput
    upsert?: UserUpsertWithoutPatInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutPatInput, UserUpdateWithoutPatInput>
  }

  export type transactionUpdateManyWithoutPatInput = {
    create?: XOR<Enumerable<transactionUncheckedCreateWithoutPatInput>, Enumerable<transactionCreateWithoutPatInput>>
    connectOrCreate?: Enumerable<transactionCreateOrConnectWithoutpatInput>
    upsert?: Enumerable<transactionUpsertWithWhereUniqueWithoutPatInput>
    connect?: Enumerable<transactionWhereUniqueInput>
    set?: Enumerable<transactionWhereUniqueInput>
    disconnect?: Enumerable<transactionWhereUniqueInput>
    delete?: Enumerable<transactionWhereUniqueInput>
    update?: Enumerable<transactionUpdateWithWhereUniqueWithoutPatInput>
    updateMany?: Enumerable<transactionUpdateManyWithWhereWithoutPatInput>
    deleteMany?: Enumerable<transactionScalarWhereInput>
  }

  export type transactionUncheckedUpdateManyWithoutPatInput = {
    create?: XOR<Enumerable<transactionUncheckedCreateWithoutPatInput>, Enumerable<transactionCreateWithoutPatInput>>
    connectOrCreate?: Enumerable<transactionCreateOrConnectWithoutpatInput>
    upsert?: Enumerable<transactionUpsertWithWhereUniqueWithoutPatInput>
    connect?: Enumerable<transactionWhereUniqueInput>
    set?: Enumerable<transactionWhereUniqueInput>
    disconnect?: Enumerable<transactionWhereUniqueInput>
    delete?: Enumerable<transactionWhereUniqueInput>
    update?: Enumerable<transactionUpdateWithWhereUniqueWithoutPatInput>
    updateMany?: Enumerable<transactionUpdateManyWithWhereWithoutPatInput>
    deleteMany?: Enumerable<transactionScalarWhereInput>
  }

  export type ManagerCreateNestedOneWithoutTransactionInput = {
    create?: XOR<ManagerUncheckedCreateWithoutTransactionInput, ManagerCreateWithoutTransactionInput>
    connectOrCreate?: ManagerCreateOrConnectWithouttransactionInput
    connect?: ManagerWhereUniqueInput
  }

  export type PATCreateNestedOneWithoutTransactionInput = {
    create?: XOR<PATUncheckedCreateWithoutTransactionInput, PATCreateWithoutTransactionInput>
    connectOrCreate?: PATCreateOrConnectWithouttransactionInput
    connect?: PATWhereUniqueInput
  }

  export type ManagerUpdateOneRequiredWithoutTransactionInput = {
    create?: XOR<ManagerUncheckedCreateWithoutTransactionInput, ManagerCreateWithoutTransactionInput>
    connectOrCreate?: ManagerCreateOrConnectWithouttransactionInput
    upsert?: ManagerUpsertWithoutTransactionInput
    connect?: ManagerWhereUniqueInput
    update?: XOR<ManagerUncheckedUpdateWithoutTransactionInput, ManagerUpdateWithoutTransactionInput>
  }

  export type PATUpdateOneWithoutTransactionInput = {
    create?: XOR<PATUncheckedCreateWithoutTransactionInput, PATCreateWithoutTransactionInput>
    connectOrCreate?: PATCreateOrConnectWithouttransactionInput
    upsert?: PATUpsertWithoutTransactionInput
    connect?: PATWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<PATUncheckedUpdateWithoutTransactionInput, PATUpdateWithoutTransactionInput>
  }

  export type UserCreateNestedOneWithoutDiscordInput = {
    create?: XOR<UserUncheckedCreateWithoutDiscordInput, UserCreateWithoutDiscordInput>
    connectOrCreate?: UserCreateOrConnectWithoutdiscordInput
    connect?: UserWhereUniqueInput
  }

  export type AdminOnGuildsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AdminOnGuildsUncheckedCreateWithoutUserInput>, Enumerable<AdminOnGuildsCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AdminOnGuildsCreateOrConnectWithoutuserInput>
    connect?: Enumerable<AdminOnGuildsWhereUniqueInput>
  }

  export type UsersOnGuildsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UsersOnGuildsUncheckedCreateWithoutUserInput>, Enumerable<UsersOnGuildsCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UsersOnGuildsCreateOrConnectWithoutuserInput>
    connect?: Enumerable<UsersOnGuildsWhereUniqueInput>
  }

  export type AdminOnGuildsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AdminOnGuildsUncheckedCreateWithoutUserInput>, Enumerable<AdminOnGuildsCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AdminOnGuildsCreateOrConnectWithoutuserInput>
    connect?: Enumerable<AdminOnGuildsWhereUniqueInput>
  }

  export type UsersOnGuildsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UsersOnGuildsUncheckedCreateWithoutUserInput>, Enumerable<UsersOnGuildsCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UsersOnGuildsCreateOrConnectWithoutuserInput>
    connect?: Enumerable<UsersOnGuildsWhereUniqueInput>
  }

  export type UserUpdateOneWithoutDiscordInput = {
    create?: XOR<UserUncheckedCreateWithoutDiscordInput, UserCreateWithoutDiscordInput>
    connectOrCreate?: UserCreateOrConnectWithoutdiscordInput
    upsert?: UserUpsertWithoutDiscordInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUncheckedUpdateWithoutDiscordInput, UserUpdateWithoutDiscordInput>
  }

  export type AdminOnGuildsUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<AdminOnGuildsUncheckedCreateWithoutUserInput>, Enumerable<AdminOnGuildsCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AdminOnGuildsCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<AdminOnGuildsUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<AdminOnGuildsWhereUniqueInput>
    set?: Enumerable<AdminOnGuildsWhereUniqueInput>
    disconnect?: Enumerable<AdminOnGuildsWhereUniqueInput>
    delete?: Enumerable<AdminOnGuildsWhereUniqueInput>
    update?: Enumerable<AdminOnGuildsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AdminOnGuildsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AdminOnGuildsScalarWhereInput>
  }

  export type UsersOnGuildsUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UsersOnGuildsUncheckedCreateWithoutUserInput>, Enumerable<UsersOnGuildsCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UsersOnGuildsCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<UsersOnGuildsUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<UsersOnGuildsWhereUniqueInput>
    set?: Enumerable<UsersOnGuildsWhereUniqueInput>
    disconnect?: Enumerable<UsersOnGuildsWhereUniqueInput>
    delete?: Enumerable<UsersOnGuildsWhereUniqueInput>
    update?: Enumerable<UsersOnGuildsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UsersOnGuildsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UsersOnGuildsScalarWhereInput>
  }

  export type AdminOnGuildsUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<AdminOnGuildsUncheckedCreateWithoutUserInput>, Enumerable<AdminOnGuildsCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AdminOnGuildsCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<AdminOnGuildsUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<AdminOnGuildsWhereUniqueInput>
    set?: Enumerable<AdminOnGuildsWhereUniqueInput>
    disconnect?: Enumerable<AdminOnGuildsWhereUniqueInput>
    delete?: Enumerable<AdminOnGuildsWhereUniqueInput>
    update?: Enumerable<AdminOnGuildsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AdminOnGuildsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AdminOnGuildsScalarWhereInput>
  }

  export type UsersOnGuildsUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UsersOnGuildsUncheckedCreateWithoutUserInput>, Enumerable<UsersOnGuildsCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UsersOnGuildsCreateOrConnectWithoutuserInput>
    upsert?: Enumerable<UsersOnGuildsUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<UsersOnGuildsWhereUniqueInput>
    set?: Enumerable<UsersOnGuildsWhereUniqueInput>
    disconnect?: Enumerable<UsersOnGuildsWhereUniqueInput>
    delete?: Enumerable<UsersOnGuildsWhereUniqueInput>
    update?: Enumerable<UsersOnGuildsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UsersOnGuildsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UsersOnGuildsScalarWhereInput>
  }

  export type AdminOnGuildsCreateNestedManyWithoutGuildInput = {
    create?: XOR<Enumerable<AdminOnGuildsUncheckedCreateWithoutGuildInput>, Enumerable<AdminOnGuildsCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<AdminOnGuildsCreateOrConnectWithoutguildInput>
    connect?: Enumerable<AdminOnGuildsWhereUniqueInput>
  }

  export type UsersOnGuildsCreateNestedManyWithoutGuildInput = {
    create?: XOR<Enumerable<UsersOnGuildsUncheckedCreateWithoutGuildInput>, Enumerable<UsersOnGuildsCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<UsersOnGuildsCreateOrConnectWithoutguildInput>
    connect?: Enumerable<UsersOnGuildsWhereUniqueInput>
  }

  export type AdminOnGuildsUncheckedCreateNestedManyWithoutGuildInput = {
    create?: XOR<Enumerable<AdminOnGuildsUncheckedCreateWithoutGuildInput>, Enumerable<AdminOnGuildsCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<AdminOnGuildsCreateOrConnectWithoutguildInput>
    connect?: Enumerable<AdminOnGuildsWhereUniqueInput>
  }

  export type UsersOnGuildsUncheckedCreateNestedManyWithoutGuildInput = {
    create?: XOR<Enumerable<UsersOnGuildsUncheckedCreateWithoutGuildInput>, Enumerable<UsersOnGuildsCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<UsersOnGuildsCreateOrConnectWithoutguildInput>
    connect?: Enumerable<UsersOnGuildsWhereUniqueInput>
  }

  export type AdminOnGuildsUpdateManyWithoutGuildInput = {
    create?: XOR<Enumerable<AdminOnGuildsUncheckedCreateWithoutGuildInput>, Enumerable<AdminOnGuildsCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<AdminOnGuildsCreateOrConnectWithoutguildInput>
    upsert?: Enumerable<AdminOnGuildsUpsertWithWhereUniqueWithoutGuildInput>
    connect?: Enumerable<AdminOnGuildsWhereUniqueInput>
    set?: Enumerable<AdminOnGuildsWhereUniqueInput>
    disconnect?: Enumerable<AdminOnGuildsWhereUniqueInput>
    delete?: Enumerable<AdminOnGuildsWhereUniqueInput>
    update?: Enumerable<AdminOnGuildsUpdateWithWhereUniqueWithoutGuildInput>
    updateMany?: Enumerable<AdminOnGuildsUpdateManyWithWhereWithoutGuildInput>
    deleteMany?: Enumerable<AdminOnGuildsScalarWhereInput>
  }

  export type UsersOnGuildsUpdateManyWithoutGuildInput = {
    create?: XOR<Enumerable<UsersOnGuildsUncheckedCreateWithoutGuildInput>, Enumerable<UsersOnGuildsCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<UsersOnGuildsCreateOrConnectWithoutguildInput>
    upsert?: Enumerable<UsersOnGuildsUpsertWithWhereUniqueWithoutGuildInput>
    connect?: Enumerable<UsersOnGuildsWhereUniqueInput>
    set?: Enumerable<UsersOnGuildsWhereUniqueInput>
    disconnect?: Enumerable<UsersOnGuildsWhereUniqueInput>
    delete?: Enumerable<UsersOnGuildsWhereUniqueInput>
    update?: Enumerable<UsersOnGuildsUpdateWithWhereUniqueWithoutGuildInput>
    updateMany?: Enumerable<UsersOnGuildsUpdateManyWithWhereWithoutGuildInput>
    deleteMany?: Enumerable<UsersOnGuildsScalarWhereInput>
  }

  export type AdminOnGuildsUncheckedUpdateManyWithoutGuildInput = {
    create?: XOR<Enumerable<AdminOnGuildsUncheckedCreateWithoutGuildInput>, Enumerable<AdminOnGuildsCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<AdminOnGuildsCreateOrConnectWithoutguildInput>
    upsert?: Enumerable<AdminOnGuildsUpsertWithWhereUniqueWithoutGuildInput>
    connect?: Enumerable<AdminOnGuildsWhereUniqueInput>
    set?: Enumerable<AdminOnGuildsWhereUniqueInput>
    disconnect?: Enumerable<AdminOnGuildsWhereUniqueInput>
    delete?: Enumerable<AdminOnGuildsWhereUniqueInput>
    update?: Enumerable<AdminOnGuildsUpdateWithWhereUniqueWithoutGuildInput>
    updateMany?: Enumerable<AdminOnGuildsUpdateManyWithWhereWithoutGuildInput>
    deleteMany?: Enumerable<AdminOnGuildsScalarWhereInput>
  }

  export type UsersOnGuildsUncheckedUpdateManyWithoutGuildInput = {
    create?: XOR<Enumerable<UsersOnGuildsUncheckedCreateWithoutGuildInput>, Enumerable<UsersOnGuildsCreateWithoutGuildInput>>
    connectOrCreate?: Enumerable<UsersOnGuildsCreateOrConnectWithoutguildInput>
    upsert?: Enumerable<UsersOnGuildsUpsertWithWhereUniqueWithoutGuildInput>
    connect?: Enumerable<UsersOnGuildsWhereUniqueInput>
    set?: Enumerable<UsersOnGuildsWhereUniqueInput>
    disconnect?: Enumerable<UsersOnGuildsWhereUniqueInput>
    delete?: Enumerable<UsersOnGuildsWhereUniqueInput>
    update?: Enumerable<UsersOnGuildsUpdateWithWhereUniqueWithoutGuildInput>
    updateMany?: Enumerable<UsersOnGuildsUpdateManyWithWhereWithoutGuildInput>
    deleteMany?: Enumerable<UsersOnGuildsScalarWhereInput>
  }

  export type guildCreateNestedOneWithoutMembersInput = {
    create?: XOR<guildUncheckedCreateWithoutMembersInput, guildCreateWithoutMembersInput>
    connectOrCreate?: guildCreateOrConnectWithoutmembersInput
    connect?: guildWhereUniqueInput
  }

  export type DiscordUserCreateNestedOneWithoutUsersOnGuildsInput = {
    create?: XOR<DiscordUserUncheckedCreateWithoutUsersOnGuildsInput, DiscordUserCreateWithoutUsersOnGuildsInput>
    connectOrCreate?: DiscordUserCreateOrConnectWithoutUsersOnGuildsInput
    connect?: DiscordUserWhereUniqueInput
  }

  export type guildUpdateOneRequiredWithoutMembersInput = {
    create?: XOR<guildUncheckedCreateWithoutMembersInput, guildCreateWithoutMembersInput>
    connectOrCreate?: guildCreateOrConnectWithoutmembersInput
    upsert?: guildUpsertWithoutMembersInput
    connect?: guildWhereUniqueInput
    update?: XOR<guildUncheckedUpdateWithoutMembersInput, guildUpdateWithoutMembersInput>
  }

  export type DiscordUserUpdateOneRequiredWithoutUsersOnGuildsInput = {
    create?: XOR<DiscordUserUncheckedCreateWithoutUsersOnGuildsInput, DiscordUserCreateWithoutUsersOnGuildsInput>
    connectOrCreate?: DiscordUserCreateOrConnectWithoutUsersOnGuildsInput
    upsert?: DiscordUserUpsertWithoutUsersOnGuildsInput
    connect?: DiscordUserWhereUniqueInput
    update?: XOR<DiscordUserUncheckedUpdateWithoutUsersOnGuildsInput, DiscordUserUpdateWithoutUsersOnGuildsInput>
  }

  export type guildCreateNestedOneWithoutAdminsInput = {
    create?: XOR<guildUncheckedCreateWithoutAdminsInput, guildCreateWithoutAdminsInput>
    connectOrCreate?: guildCreateOrConnectWithoutadminsInput
    connect?: guildWhereUniqueInput
  }

  export type DiscordUserCreateNestedOneWithoutAdministatesInput = {
    create?: XOR<DiscordUserUncheckedCreateWithoutAdministatesInput, DiscordUserCreateWithoutAdministatesInput>
    connectOrCreate?: DiscordUserCreateOrConnectWithoutadministatesInput
    connect?: DiscordUserWhereUniqueInput
  }

  export type guildUpdateOneRequiredWithoutAdminsInput = {
    create?: XOR<guildUncheckedCreateWithoutAdminsInput, guildCreateWithoutAdminsInput>
    connectOrCreate?: guildCreateOrConnectWithoutadminsInput
    upsert?: guildUpsertWithoutAdminsInput
    connect?: guildWhereUniqueInput
    update?: XOR<guildUncheckedUpdateWithoutAdminsInput, guildUpdateWithoutAdminsInput>
  }

  export type DiscordUserUpdateOneRequiredWithoutAdministatesInput = {
    create?: XOR<DiscordUserUncheckedCreateWithoutAdministatesInput, DiscordUserCreateWithoutAdministatesInput>
    connectOrCreate?: DiscordUserCreateOrConnectWithoutadministatesInput
    upsert?: DiscordUserUpsertWithoutAdministatesInput
    connect?: DiscordUserWhereUniqueInput
    update?: XOR<DiscordUserUncheckedUpdateWithoutAdministatesInput, DiscordUserUpdateWithoutAdministatesInput>
  }

  export type UserCreateNestedOneWithoutCommandsInput = {
    create?: XOR<UserUncheckedCreateWithoutCommandsInput, UserCreateWithoutCommandsInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommandsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDiscordExecutionTypeFieldUpdateOperationsInput = {
    set?: DiscordExecutionType
  }

  export type UserUpdateOneRequiredWithoutCommandsInput = {
    create?: XOR<UserUncheckedCreateWithoutCommandsInput, UserCreateWithoutCommandsInput>
    connectOrCreate?: UserCreateOrConnectWithoutcommandsInput
    upsert?: UserUpsertWithoutCommandsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutCommandsInput, UserUpdateWithoutCommandsInput>
  }

  export type UserCreateNestedOneWithoutActionsInput = {
    create?: XOR<UserUncheckedCreateWithoutActionsInput, UserCreateWithoutActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutactionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActionsInput = {
    create?: XOR<UserUncheckedCreateWithoutActionsInput, UserCreateWithoutActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutactionsInput
    upsert?: UserUpsertWithoutActionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUncheckedUpdateWithoutActionsInput, UserUpdateWithoutActionsInput>
  }

  export type UserCreateNestedOneWithoutTwitchInput = {
    create?: XOR<UserUncheckedCreateWithoutTwitchInput, UserCreateWithoutTwitchInput>
    connectOrCreate?: UserCreateOrConnectWithouttwitchInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutTwitchInput = {
    create?: XOR<UserUncheckedCreateWithoutTwitchInput, UserCreateWithoutTwitchInput>
    connectOrCreate?: UserCreateOrConnectWithouttwitchInput
    upsert?: UserUpsertWithoutTwitchInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUncheckedUpdateWithoutTwitchInput, UserUpdateWithoutTwitchInput>
  }

  export type BotCreateNestedManyWithoutTwitchAuthInput = {
    create?: XOR<Enumerable<BotUncheckedCreateWithoutTwitchAuthInput>, Enumerable<BotCreateWithoutTwitchAuthInput>>
    connectOrCreate?: Enumerable<BotCreateOrConnectWithouttwitchAuthInput>
    connect?: Enumerable<BotWhereUniqueInput>
  }

  export type BotUncheckedCreateNestedManyWithoutTwitchAuthInput = {
    create?: XOR<Enumerable<BotUncheckedCreateWithoutTwitchAuthInput>, Enumerable<BotCreateWithoutTwitchAuthInput>>
    connectOrCreate?: Enumerable<BotCreateOrConnectWithouttwitchAuthInput>
    connect?: Enumerable<BotWhereUniqueInput>
  }

  export type BotUpdateManyWithoutTwitchAuthInput = {
    create?: XOR<Enumerable<BotUncheckedCreateWithoutTwitchAuthInput>, Enumerable<BotCreateWithoutTwitchAuthInput>>
    connectOrCreate?: Enumerable<BotCreateOrConnectWithouttwitchAuthInput>
    upsert?: Enumerable<BotUpsertWithWhereUniqueWithoutTwitchAuthInput>
    connect?: Enumerable<BotWhereUniqueInput>
    set?: Enumerable<BotWhereUniqueInput>
    disconnect?: Enumerable<BotWhereUniqueInput>
    delete?: Enumerable<BotWhereUniqueInput>
    update?: Enumerable<BotUpdateWithWhereUniqueWithoutTwitchAuthInput>
    updateMany?: Enumerable<BotUpdateManyWithWhereWithoutTwitchAuthInput>
    deleteMany?: Enumerable<BotScalarWhereInput>
  }

  export type BotUncheckedUpdateManyWithoutTwitchAuthInput = {
    create?: XOR<Enumerable<BotUncheckedCreateWithoutTwitchAuthInput>, Enumerable<BotCreateWithoutTwitchAuthInput>>
    connectOrCreate?: Enumerable<BotCreateOrConnectWithouttwitchAuthInput>
    upsert?: Enumerable<BotUpsertWithWhereUniqueWithoutTwitchAuthInput>
    connect?: Enumerable<BotWhereUniqueInput>
    set?: Enumerable<BotWhereUniqueInput>
    disconnect?: Enumerable<BotWhereUniqueInput>
    delete?: Enumerable<BotWhereUniqueInput>
    update?: Enumerable<BotUpdateWithWhereUniqueWithoutTwitchAuthInput>
    updateMany?: Enumerable<BotUpdateManyWithWhereWithoutTwitchAuthInput>
    deleteMany?: Enumerable<BotScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutTwitterUserInput = {
    create?: XOR<UserUncheckedCreateWithoutTwitterUserInput, UserCreateWithoutTwitterUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwitterUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutTwitterUserInput = {
    create?: XOR<UserUncheckedCreateWithoutTwitterUserInput, UserCreateWithoutTwitterUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwitterUserInput
    upsert?: UserUpsertWithoutTwitterUserInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUncheckedUpdateWithoutTwitterUserInput, UserUpdateWithoutTwitterUserInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedEnumManagerLevelsFilter = {
    equals?: ManagerLevels
    in?: Enumerable<ManagerLevels>
    notIn?: Enumerable<ManagerLevels>
    not?: NestedEnumManagerLevelsFilter | ManagerLevels
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedEnumShardStatusFilter = {
    equals?: ShardStatus
    in?: Enumerable<ShardStatus>
    notIn?: Enumerable<ShardStatus>
    not?: NestedEnumShardStatusFilter | ShardStatus
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedEnumPATStatusFilter = {
    equals?: PATStatus
    in?: Enumerable<PATStatus>
    notIn?: Enumerable<PATStatus>
    not?: NestedEnumPATStatusFilter | PATStatus
  }

  export type NestedEnumDiscordExecutionTypeFilter = {
    equals?: DiscordExecutionType
    in?: Enumerable<DiscordExecutionType>
    notIn?: Enumerable<DiscordExecutionType>
    not?: NestedEnumDiscordExecutionTypeFilter | DiscordExecutionType
  }

  export type UserCreateWithoutManagerInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionCreateNestedManyWithoutOwnerInput
    Bot?: BotCreateNestedManyWithoutOwnerInput
    commands?: CommandCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserCreateNestedOneWithoutUserInput
    Hosts?: HostCreateNestedManyWithoutOwnerInput
    pat?: PATCreateNestedManyWithoutUserInput
    twitch?: TwitchUserCreateNestedOneWithoutUserInput
    TwitterUser?: TwitterUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutManagerInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionUncheckedCreateNestedManyWithoutOwnerInput
    Bot?: BotUncheckedCreateNestedManyWithoutOwnerInput
    commands?: CommandUncheckedCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserUncheckedCreateNestedOneWithoutUserInput
    Hosts?: HostUncheckedCreateNestedManyWithoutOwnerInput
    pat?: PATUncheckedCreateNestedManyWithoutUserInput
    twitch?: TwitchUserUncheckedCreateNestedOneWithoutUserInput
    TwitterUser?: TwitterUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutManagerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutManagerInput, UserCreateWithoutManagerInput>
  }

  export type ManagerCreateWithoutChildManagersInput = {
    id?: string
    createdAt?: Date | string
    ip: string
    url: string
    port?: number
    type?: ManagerLevels
    restartSchedule: string
    tasksCompleted?: number
    downtimeHistory?: ManagerCreatedowntimeHistoryInput | Enumerable<InputJsonValue>
    owner: UserCreateNestedOneWithoutManagerInput
    parentManager?: ManagerCreateNestedOneWithoutChildManagersInput
    transaction?: transactionCreateNestedManyWithoutResponsibleManagerInput
    Manager_B?: ManagerCreateNestedManyWithoutManager_AInput
    Manager_A?: ManagerCreateNestedManyWithoutManager_BInput
  }

  export type ManagerUncheckedCreateWithoutChildManagersInput = {
    id?: string
    createdAt?: Date | string
    ownerId: string
    ip: string
    url: string
    port?: number
    type?: ManagerLevels
    restartSchedule: string
    tasksCompleted?: number
    parentID?: string | null
    downtimeHistory?: ManagerCreatedowntimeHistoryInput | Enumerable<InputJsonValue>
    transaction?: transactionUncheckedCreateNestedManyWithoutResponsibleManagerInput
  }

  export type ManagerCreateOrConnectWithoutchildManagersInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerUncheckedCreateWithoutChildManagersInput, ManagerCreateWithoutChildManagersInput>
  }

  export type ManagerCreateWithoutParentManagerInput = {
    id?: string
    createdAt?: Date | string
    ip: string
    url: string
    port?: number
    type?: ManagerLevels
    restartSchedule: string
    tasksCompleted?: number
    downtimeHistory?: ManagerCreatedowntimeHistoryInput | Enumerable<InputJsonValue>
    owner: UserCreateNestedOneWithoutManagerInput
    childManagers?: ManagerCreateNestedManyWithoutParentManagerInput
    transaction?: transactionCreateNestedManyWithoutResponsibleManagerInput
    Manager_B?: ManagerCreateNestedManyWithoutManager_AInput
    Manager_A?: ManagerCreateNestedManyWithoutManager_BInput
  }

  export type ManagerUncheckedCreateWithoutParentManagerInput = {
    id?: string
    createdAt?: Date | string
    ownerId: string
    ip: string
    url: string
    port?: number
    type?: ManagerLevels
    restartSchedule: string
    tasksCompleted?: number
    downtimeHistory?: ManagerCreatedowntimeHistoryInput | Enumerable<InputJsonValue>
    childManagers?: ManagerUncheckedCreateNestedManyWithoutParentManagerInput
    transaction?: transactionUncheckedCreateNestedManyWithoutResponsibleManagerInput
  }

  export type ManagerCreateOrConnectWithoutparentManagerInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerUncheckedCreateWithoutParentManagerInput, ManagerCreateWithoutParentManagerInput>
  }

  export type transactionCreateWithoutResponsibleManagerInput = {
    id?: string
    createdAt?: Date | string
    completedAt?: Date | string | null
    suspicious?: boolean
    fraudulent?: boolean
    reversedAt?: Date | string | null
    pat?: PATCreateNestedOneWithoutTransactionInput
  }

  export type transactionUncheckedCreateWithoutResponsibleManagerInput = {
    id?: string
    createdAt?: Date | string
    completedAt?: Date | string | null
    patId?: string | null
    suspicious?: boolean
    fraudulent?: boolean
    reversedAt?: Date | string | null
  }

  export type transactionCreateOrConnectWithoutresponsibleManagerInput = {
    where: transactionWhereUniqueInput
    create: XOR<transactionUncheckedCreateWithoutResponsibleManagerInput, transactionCreateWithoutResponsibleManagerInput>
  }

  export type ManagerCreateWithoutManager_AInput = {
    id?: string
    createdAt?: Date | string
    ip: string
    url: string
    port?: number
    type?: ManagerLevels
    restartSchedule: string
    tasksCompleted?: number
    downtimeHistory?: ManagerCreatedowntimeHistoryInput | Enumerable<InputJsonValue>
    owner: UserCreateNestedOneWithoutManagerInput
    parentManager?: ManagerCreateNestedOneWithoutChildManagersInput
    childManagers?: ManagerCreateNestedManyWithoutParentManagerInput
    transaction?: transactionCreateNestedManyWithoutResponsibleManagerInput
    Manager_B?: ManagerCreateNestedManyWithoutManager_AInput
  }

  export type ManagerUncheckedCreateWithoutManager_AInput = {
    id?: string
    createdAt?: Date | string
    ownerId: string
    ip: string
    url: string
    port?: number
    type?: ManagerLevels
    restartSchedule: string
    tasksCompleted?: number
    parentID?: string | null
    downtimeHistory?: ManagerCreatedowntimeHistoryInput | Enumerable<InputJsonValue>
    childManagers?: ManagerUncheckedCreateNestedManyWithoutParentManagerInput
    transaction?: transactionUncheckedCreateNestedManyWithoutResponsibleManagerInput
  }

  export type ManagerCreateOrConnectWithoutManager_AInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerUncheckedCreateWithoutManager_AInput, ManagerCreateWithoutManager_AInput>
  }

  export type ManagerCreateWithoutManager_BInput = {
    id?: string
    createdAt?: Date | string
    ip: string
    url: string
    port?: number
    type?: ManagerLevels
    restartSchedule: string
    tasksCompleted?: number
    downtimeHistory?: ManagerCreatedowntimeHistoryInput | Enumerable<InputJsonValue>
    owner: UserCreateNestedOneWithoutManagerInput
    parentManager?: ManagerCreateNestedOneWithoutChildManagersInput
    childManagers?: ManagerCreateNestedManyWithoutParentManagerInput
    transaction?: transactionCreateNestedManyWithoutResponsibleManagerInput
    Manager_A?: ManagerCreateNestedManyWithoutManager_BInput
  }

  export type ManagerUncheckedCreateWithoutManager_BInput = {
    id?: string
    createdAt?: Date | string
    ownerId: string
    ip: string
    url: string
    port?: number
    type?: ManagerLevels
    restartSchedule: string
    tasksCompleted?: number
    parentID?: string | null
    downtimeHistory?: ManagerCreatedowntimeHistoryInput | Enumerable<InputJsonValue>
    childManagers?: ManagerUncheckedCreateNestedManyWithoutParentManagerInput
    transaction?: transactionUncheckedCreateNestedManyWithoutResponsibleManagerInput
  }

  export type ManagerCreateOrConnectWithoutManager_BInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerUncheckedCreateWithoutManager_BInput, ManagerCreateWithoutManager_BInput>
  }

  export type UserUpsertWithoutManagerInput = {
    update: XOR<UserUncheckedUpdateWithoutManagerInput, UserUpdateWithoutManagerInput>
    create: XOR<UserUncheckedCreateWithoutManagerInput, UserCreateWithoutManagerInput>
  }

  export type UserUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUpdateManyWithoutOwnerInput
    Bot?: BotUpdateManyWithoutOwnerInput
    commands?: CommandUpdateManyWithoutOwnerInput
    discord?: DiscordUserUpdateOneWithoutUserInput
    Hosts?: HostUpdateManyWithoutOwnerInput
    pat?: PATUpdateManyWithoutUserInput
    twitch?: TwitchUserUpdateOneWithoutUserInput
    TwitterUser?: TwitterUserUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUncheckedUpdateManyWithoutOwnerInput
    Bot?: BotUncheckedUpdateManyWithoutOwnerInput
    commands?: CommandUncheckedUpdateManyWithoutOwnerInput
    discord?: DiscordUserUncheckedUpdateOneWithoutUserInput
    Hosts?: HostUncheckedUpdateManyWithoutOwnerInput
    pat?: PATUncheckedUpdateManyWithoutUserInput
    twitch?: TwitchUserUncheckedUpdateOneWithoutUserInput
    TwitterUser?: TwitterUserUncheckedUpdateManyWithoutUserInput
  }

  export type ManagerUpsertWithoutChildManagersInput = {
    update: XOR<ManagerUncheckedUpdateWithoutChildManagersInput, ManagerUpdateWithoutChildManagersInput>
    create: XOR<ManagerUncheckedCreateWithoutChildManagersInput, ManagerCreateWithoutChildManagersInput>
  }

  export type ManagerUpdateWithoutChildManagersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
    owner?: UserUpdateOneRequiredWithoutManagerInput
    parentManager?: ManagerUpdateOneWithoutChildManagersInput
    transaction?: transactionUpdateManyWithoutResponsibleManagerInput
    Manager_B?: ManagerUpdateManyWithoutManager_AInput
    Manager_A?: ManagerUpdateManyWithoutManager_BInput
  }

  export type ManagerUncheckedUpdateWithoutChildManagersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    parentID?: NullableStringFieldUpdateOperationsInput | string | null
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
    transaction?: transactionUncheckedUpdateManyWithoutResponsibleManagerInput
  }

  export type ManagerUpsertWithWhereUniqueWithoutParentManagerInput = {
    where: ManagerWhereUniqueInput
    update: XOR<ManagerUncheckedUpdateWithoutParentManagerInput, ManagerUpdateWithoutParentManagerInput>
    create: XOR<ManagerUncheckedCreateWithoutParentManagerInput, ManagerCreateWithoutParentManagerInput>
  }

  export type ManagerUpdateWithWhereUniqueWithoutParentManagerInput = {
    where: ManagerWhereUniqueInput
    data: XOR<ManagerUncheckedUpdateWithoutParentManagerInput, ManagerUpdateWithoutParentManagerInput>
  }

  export type ManagerUpdateManyWithWhereWithoutParentManagerInput = {
    where: ManagerScalarWhereInput
    data: XOR<ManagerUncheckedUpdateManyWithoutChildManagersInput, ManagerUpdateManyMutationInput>
  }

  export type ManagerScalarWhereInput = {
    AND?: Enumerable<ManagerScalarWhereInput>
    OR?: Enumerable<ManagerScalarWhereInput>
    NOT?: Enumerable<ManagerScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    ownerId?: StringFilter | string
    ip?: StringFilter | string
    url?: StringFilter | string
    port?: IntFilter | number
    type?: EnumManagerLevelsFilter | ManagerLevels
    restartSchedule?: StringFilter | string
    downtimeHistory?: JsonNullableListFilter
    tasksCompleted?: IntFilter | number
    parentID?: StringNullableFilter | string | null
  }

  export type transactionUpsertWithWhereUniqueWithoutResponsibleManagerInput = {
    where: transactionWhereUniqueInput
    update: XOR<transactionUncheckedUpdateWithoutResponsibleManagerInput, transactionUpdateWithoutResponsibleManagerInput>
    create: XOR<transactionUncheckedCreateWithoutResponsibleManagerInput, transactionCreateWithoutResponsibleManagerInput>
  }

  export type transactionUpdateWithWhereUniqueWithoutResponsibleManagerInput = {
    where: transactionWhereUniqueInput
    data: XOR<transactionUncheckedUpdateWithoutResponsibleManagerInput, transactionUpdateWithoutResponsibleManagerInput>
  }

  export type transactionUpdateManyWithWhereWithoutResponsibleManagerInput = {
    where: transactionScalarWhereInput
    data: XOR<transactionUncheckedUpdateManyWithoutTransactionInput, transactionUpdateManyMutationInput>
  }

  export type transactionScalarWhereInput = {
    AND?: Enumerable<transactionScalarWhereInput>
    OR?: Enumerable<transactionScalarWhereInput>
    NOT?: Enumerable<transactionScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    completedAt?: DateTimeNullableFilter | Date | string | null
    managerId?: StringFilter | string
    patId?: StringNullableFilter | string | null
    suspicious?: BoolFilter | boolean
    fraudulent?: BoolFilter | boolean
    reversedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ManagerUpsertWithWhereUniqueWithoutManager_AInput = {
    where: ManagerWhereUniqueInput
    update: XOR<ManagerUncheckedUpdateWithoutManager_AInput, ManagerUpdateWithoutManager_AInput>
    create: XOR<ManagerUncheckedCreateWithoutManager_AInput, ManagerCreateWithoutManager_AInput>
  }

  export type ManagerUpdateWithWhereUniqueWithoutManager_AInput = {
    where: ManagerWhereUniqueInput
    data: XOR<ManagerUncheckedUpdateWithoutManager_AInput, ManagerUpdateWithoutManager_AInput>
  }

  export type ManagerUpdateManyWithWhereWithoutManager_AInput = {
    where: ManagerScalarWhereInput
    data: XOR<ManagerUncheckedUpdateManyWithoutManager_BInput, ManagerUpdateManyMutationInput>
  }

  export type ManagerUpsertWithWhereUniqueWithoutManager_BInput = {
    where: ManagerWhereUniqueInput
    update: XOR<ManagerUncheckedUpdateWithoutManager_BInput, ManagerUpdateWithoutManager_BInput>
    create: XOR<ManagerUncheckedCreateWithoutManager_BInput, ManagerCreateWithoutManager_BInput>
  }

  export type ManagerUpdateWithWhereUniqueWithoutManager_BInput = {
    where: ManagerWhereUniqueInput
    data: XOR<ManagerUncheckedUpdateWithoutManager_BInput, ManagerUpdateWithoutManager_BInput>
  }

  export type ManagerUpdateManyWithWhereWithoutManager_BInput = {
    where: ManagerScalarWhereInput
    data: XOR<ManagerUncheckedUpdateManyWithoutManager_AInput, ManagerUpdateManyMutationInput>
  }

  export type UserCreateWithoutHostsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionCreateNestedManyWithoutOwnerInput
    Bot?: BotCreateNestedManyWithoutOwnerInput
    commands?: CommandCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserCreateNestedOneWithoutUserInput
    Manager?: ManagerCreateNestedManyWithoutOwnerInput
    pat?: PATCreateNestedManyWithoutUserInput
    twitch?: TwitchUserCreateNestedOneWithoutUserInput
    TwitterUser?: TwitterUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHostsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionUncheckedCreateNestedManyWithoutOwnerInput
    Bot?: BotUncheckedCreateNestedManyWithoutOwnerInput
    commands?: CommandUncheckedCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserUncheckedCreateNestedOneWithoutUserInput
    Manager?: ManagerUncheckedCreateNestedManyWithoutOwnerInput
    pat?: PATUncheckedCreateNestedManyWithoutUserInput
    twitch?: TwitchUserUncheckedCreateNestedOneWithoutUserInput
    TwitterUser?: TwitterUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutHostsInput, UserCreateWithoutHostsInput>
  }

  export type BotCreateWithoutHostsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    discordToken?: string | null
    twitterToken?: string | null
    recommendedShards?: number
    currentShards?: number
    owner: UserCreateNestedOneWithoutBotInput
    priorityHost?: HostCreateNestedOneWithoutPriorityBotInput
    twitchAuth: TwitchAuthCreateNestedOneWithoutBotInput
    shards?: ShardCreateNestedManyWithoutBotInput
  }

  export type BotUncheckedCreateWithoutHostsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    priorityHostId?: number | null
    discordToken?: string | null
    twitterToken?: string | null
    twitchAuthId: number
    recommendedShards?: number
    currentShards?: number
    shards?: ShardUncheckedCreateNestedManyWithoutBotInput
  }

  export type BotCreateOrConnectWithouthostsInput = {
    where: BotWhereUniqueInput
    create: XOR<BotUncheckedCreateWithoutHostsInput, BotCreateWithoutHostsInput>
  }

  export type BotCreateWithoutPriorityHostInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    discordToken?: string | null
    twitterToken?: string | null
    recommendedShards?: number
    currentShards?: number
    hosts: HostCreateNestedOneWithoutBotsInput
    owner: UserCreateNestedOneWithoutBotInput
    twitchAuth: TwitchAuthCreateNestedOneWithoutBotInput
    shards?: ShardCreateNestedManyWithoutBotInput
  }

  export type BotUncheckedCreateWithoutPriorityHostInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    hostsId: number
    discordToken?: string | null
    twitterToken?: string | null
    twitchAuthId: number
    recommendedShards?: number
    currentShards?: number
    shards?: ShardUncheckedCreateNestedManyWithoutBotInput
  }

  export type BotCreateOrConnectWithoutpriorityHostInput = {
    where: BotWhereUniqueInput
    create: XOR<BotUncheckedCreateWithoutPriorityHostInput, BotCreateWithoutPriorityHostInput>
  }

  export type ShardCreateWithoutHostInput = {
    id?: string
    createdAt?: Date | string
    lanchedAt?: Date | string | null
    status?: ShardStatus
    shardID: number
    bot: BotCreateNestedOneWithoutShardsInput
  }

  export type ShardUncheckedCreateWithoutHostInput = {
    id?: string
    createdAt?: Date | string
    lanchedAt?: Date | string | null
    botId: number
    status?: ShardStatus
    shardID: number
  }

  export type ShardCreateOrConnectWithoutHostInput = {
    where: ShardWhereUniqueInput
    create: XOR<ShardUncheckedCreateWithoutHostInput, ShardCreateWithoutHostInput>
  }

  export type UserUpsertWithoutHostsInput = {
    update: XOR<UserUncheckedUpdateWithoutHostsInput, UserUpdateWithoutHostsInput>
    create: XOR<UserUncheckedCreateWithoutHostsInput, UserCreateWithoutHostsInput>
  }

  export type UserUpdateWithoutHostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUpdateManyWithoutOwnerInput
    Bot?: BotUpdateManyWithoutOwnerInput
    commands?: CommandUpdateManyWithoutOwnerInput
    discord?: DiscordUserUpdateOneWithoutUserInput
    Manager?: ManagerUpdateManyWithoutOwnerInput
    pat?: PATUpdateManyWithoutUserInput
    twitch?: TwitchUserUpdateOneWithoutUserInput
    TwitterUser?: TwitterUserUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutHostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUncheckedUpdateManyWithoutOwnerInput
    Bot?: BotUncheckedUpdateManyWithoutOwnerInput
    commands?: CommandUncheckedUpdateManyWithoutOwnerInput
    discord?: DiscordUserUncheckedUpdateOneWithoutUserInput
    Manager?: ManagerUncheckedUpdateManyWithoutOwnerInput
    pat?: PATUncheckedUpdateManyWithoutUserInput
    twitch?: TwitchUserUncheckedUpdateOneWithoutUserInput
    TwitterUser?: TwitterUserUncheckedUpdateManyWithoutUserInput
  }

  export type BotUpsertWithWhereUniqueWithoutHostsInput = {
    where: BotWhereUniqueInput
    update: XOR<BotUncheckedUpdateWithoutHostsInput, BotUpdateWithoutHostsInput>
    create: XOR<BotUncheckedCreateWithoutHostsInput, BotCreateWithoutHostsInput>
  }

  export type BotUpdateWithWhereUniqueWithoutHostsInput = {
    where: BotWhereUniqueInput
    data: XOR<BotUncheckedUpdateWithoutHostsInput, BotUpdateWithoutHostsInput>
  }

  export type BotUpdateManyWithWhereWithoutHostsInput = {
    where: BotScalarWhereInput
    data: XOR<BotUncheckedUpdateManyWithoutBotsInput, BotUpdateManyMutationInput>
  }

  export type BotScalarWhereInput = {
    AND?: Enumerable<BotScalarWhereInput>
    OR?: Enumerable<BotScalarWhereInput>
    NOT?: Enumerable<BotScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    ownerId?: StringFilter | string
    hostsId?: IntFilter | number
    priorityHostId?: IntNullableFilter | number | null
    discordToken?: StringNullableFilter | string | null
    twitterToken?: StringNullableFilter | string | null
    twitchAuthId?: IntFilter | number
    recommendedShards?: IntFilter | number
    currentShards?: IntFilter | number
  }

  export type BotUpsertWithWhereUniqueWithoutPriorityHostInput = {
    where: BotWhereUniqueInput
    update: XOR<BotUncheckedUpdateWithoutPriorityHostInput, BotUpdateWithoutPriorityHostInput>
    create: XOR<BotUncheckedCreateWithoutPriorityHostInput, BotCreateWithoutPriorityHostInput>
  }

  export type BotUpdateWithWhereUniqueWithoutPriorityHostInput = {
    where: BotWhereUniqueInput
    data: XOR<BotUncheckedUpdateWithoutPriorityHostInput, BotUpdateWithoutPriorityHostInput>
  }

  export type BotUpdateManyWithWhereWithoutPriorityHostInput = {
    where: BotScalarWhereInput
    data: XOR<BotUncheckedUpdateManyWithoutPriorityBotInput, BotUpdateManyMutationInput>
  }

  export type ShardUpsertWithWhereUniqueWithoutHostInput = {
    where: ShardWhereUniqueInput
    update: XOR<ShardUncheckedUpdateWithoutHostInput, ShardUpdateWithoutHostInput>
    create: XOR<ShardUncheckedCreateWithoutHostInput, ShardCreateWithoutHostInput>
  }

  export type ShardUpdateWithWhereUniqueWithoutHostInput = {
    where: ShardWhereUniqueInput
    data: XOR<ShardUncheckedUpdateWithoutHostInput, ShardUpdateWithoutHostInput>
  }

  export type ShardUpdateManyWithWhereWithoutHostInput = {
    where: ShardScalarWhereInput
    data: XOR<ShardUncheckedUpdateManyWithoutShardsInput, ShardUpdateManyMutationInput>
  }

  export type ShardScalarWhereInput = {
    AND?: Enumerable<ShardScalarWhereInput>
    OR?: Enumerable<ShardScalarWhereInput>
    NOT?: Enumerable<ShardScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    lanchedAt?: DateTimeNullableFilter | Date | string | null
    hostId?: IntFilter | number
    botId?: IntFilter | number
    status?: EnumShardStatusFilter | ShardStatus
    shardID?: IntFilter | number
  }

  export type HostCreateWithoutBotsInput = {
    createdAt?: Date | string
    ip: string
    url: string
    port?: number
    shardLimit?: number
    owner: UserCreateNestedOneWithoutHostsInput
    priorityBot?: BotCreateNestedManyWithoutPriorityHostInput
    shards?: ShardCreateNestedManyWithoutHostInput
  }

  export type HostUncheckedCreateWithoutBotsInput = {
    id?: number
    createdAt?: Date | string
    ownerId: string
    ip: string
    url: string
    port?: number
    shardLimit?: number
    priorityBot?: BotUncheckedCreateNestedManyWithoutPriorityHostInput
    shards?: ShardUncheckedCreateNestedManyWithoutHostInput
  }

  export type HostCreateOrConnectWithoutbotsInput = {
    where: HostWhereUniqueInput
    create: XOR<HostUncheckedCreateWithoutBotsInput, HostCreateWithoutBotsInput>
  }

  export type UserCreateWithoutBotInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionCreateNestedManyWithoutOwnerInput
    commands?: CommandCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserCreateNestedOneWithoutUserInput
    Hosts?: HostCreateNestedManyWithoutOwnerInput
    Manager?: ManagerCreateNestedManyWithoutOwnerInput
    pat?: PATCreateNestedManyWithoutUserInput
    twitch?: TwitchUserCreateNestedOneWithoutUserInput
    TwitterUser?: TwitterUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBotInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionUncheckedCreateNestedManyWithoutOwnerInput
    commands?: CommandUncheckedCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserUncheckedCreateNestedOneWithoutUserInput
    Hosts?: HostUncheckedCreateNestedManyWithoutOwnerInput
    Manager?: ManagerUncheckedCreateNestedManyWithoutOwnerInput
    pat?: PATUncheckedCreateNestedManyWithoutUserInput
    twitch?: TwitchUserUncheckedCreateNestedOneWithoutUserInput
    TwitterUser?: TwitterUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBotInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutBotInput, UserCreateWithoutBotInput>
  }

  export type HostCreateWithoutPriorityBotInput = {
    createdAt?: Date | string
    ip: string
    url: string
    port?: number
    shardLimit?: number
    owner: UserCreateNestedOneWithoutHostsInput
    bots?: BotCreateNestedManyWithoutHostsInput
    shards?: ShardCreateNestedManyWithoutHostInput
  }

  export type HostUncheckedCreateWithoutPriorityBotInput = {
    id?: number
    createdAt?: Date | string
    ownerId: string
    ip: string
    url: string
    port?: number
    shardLimit?: number
    bots?: BotUncheckedCreateNestedManyWithoutHostsInput
    shards?: ShardUncheckedCreateNestedManyWithoutHostInput
  }

  export type HostCreateOrConnectWithoutpriorityBotInput = {
    where: HostWhereUniqueInput
    create: XOR<HostUncheckedCreateWithoutPriorityBotInput, HostCreateWithoutPriorityBotInput>
  }

  export type TwitchAuthCreateWithoutBotInput = {
    clientID: string
    twitchSecret: string
    sessionSecret: string
  }

  export type TwitchAuthUncheckedCreateWithoutBotInput = {
    id?: number
    clientID: string
    twitchSecret: string
    sessionSecret: string
  }

  export type TwitchAuthCreateOrConnectWithoutBotInput = {
    where: TwitchAuthWhereUniqueInput
    create: XOR<TwitchAuthUncheckedCreateWithoutBotInput, TwitchAuthCreateWithoutBotInput>
  }

  export type ShardCreateWithoutBotInput = {
    id?: string
    createdAt?: Date | string
    lanchedAt?: Date | string | null
    status?: ShardStatus
    shardID: number
    Host: HostCreateNestedOneWithoutShardsInput
  }

  export type ShardUncheckedCreateWithoutBotInput = {
    id?: string
    createdAt?: Date | string
    lanchedAt?: Date | string | null
    hostId: number
    status?: ShardStatus
    shardID: number
  }

  export type ShardCreateOrConnectWithoutbotInput = {
    where: ShardWhereUniqueInput
    create: XOR<ShardUncheckedCreateWithoutBotInput, ShardCreateWithoutBotInput>
  }

  export type HostUpsertWithoutBotsInput = {
    update: XOR<HostUncheckedUpdateWithoutBotsInput, HostUpdateWithoutBotsInput>
    create: XOR<HostUncheckedCreateWithoutBotsInput, HostCreateWithoutBotsInput>
  }

  export type HostUpdateWithoutBotsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    shardLimit?: IntFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutHostsInput
    priorityBot?: BotUpdateManyWithoutPriorityHostInput
    shards?: ShardUpdateManyWithoutHostInput
  }

  export type HostUncheckedUpdateWithoutBotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    shardLimit?: IntFieldUpdateOperationsInput | number
    priorityBot?: BotUncheckedUpdateManyWithoutPriorityHostInput
    shards?: ShardUncheckedUpdateManyWithoutHostInput
  }

  export type UserUpsertWithoutBotInput = {
    update: XOR<UserUncheckedUpdateWithoutBotInput, UserUpdateWithoutBotInput>
    create: XOR<UserUncheckedCreateWithoutBotInput, UserCreateWithoutBotInput>
  }

  export type UserUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUpdateManyWithoutOwnerInput
    commands?: CommandUpdateManyWithoutOwnerInput
    discord?: DiscordUserUpdateOneWithoutUserInput
    Hosts?: HostUpdateManyWithoutOwnerInput
    Manager?: ManagerUpdateManyWithoutOwnerInput
    pat?: PATUpdateManyWithoutUserInput
    twitch?: TwitchUserUpdateOneWithoutUserInput
    TwitterUser?: TwitterUserUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUncheckedUpdateManyWithoutOwnerInput
    commands?: CommandUncheckedUpdateManyWithoutOwnerInput
    discord?: DiscordUserUncheckedUpdateOneWithoutUserInput
    Hosts?: HostUncheckedUpdateManyWithoutOwnerInput
    Manager?: ManagerUncheckedUpdateManyWithoutOwnerInput
    pat?: PATUncheckedUpdateManyWithoutUserInput
    twitch?: TwitchUserUncheckedUpdateOneWithoutUserInput
    TwitterUser?: TwitterUserUncheckedUpdateManyWithoutUserInput
  }

  export type HostUpsertWithoutPriorityBotInput = {
    update: XOR<HostUncheckedUpdateWithoutPriorityBotInput, HostUpdateWithoutPriorityBotInput>
    create: XOR<HostUncheckedCreateWithoutPriorityBotInput, HostCreateWithoutPriorityBotInput>
  }

  export type HostUpdateWithoutPriorityBotInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    shardLimit?: IntFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutHostsInput
    bots?: BotUpdateManyWithoutHostsInput
    shards?: ShardUpdateManyWithoutHostInput
  }

  export type HostUncheckedUpdateWithoutPriorityBotInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    shardLimit?: IntFieldUpdateOperationsInput | number
    bots?: BotUncheckedUpdateManyWithoutHostsInput
    shards?: ShardUncheckedUpdateManyWithoutHostInput
  }

  export type TwitchAuthUpsertWithoutBotInput = {
    update: XOR<TwitchAuthUncheckedUpdateWithoutBotInput, TwitchAuthUpdateWithoutBotInput>
    create: XOR<TwitchAuthUncheckedCreateWithoutBotInput, TwitchAuthCreateWithoutBotInput>
  }

  export type TwitchAuthUpdateWithoutBotInput = {
    clientID?: StringFieldUpdateOperationsInput | string
    twitchSecret?: StringFieldUpdateOperationsInput | string
    sessionSecret?: StringFieldUpdateOperationsInput | string
  }

  export type TwitchAuthUncheckedUpdateWithoutBotInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientID?: StringFieldUpdateOperationsInput | string
    twitchSecret?: StringFieldUpdateOperationsInput | string
    sessionSecret?: StringFieldUpdateOperationsInput | string
  }

  export type ShardUpsertWithWhereUniqueWithoutBotInput = {
    where: ShardWhereUniqueInput
    update: XOR<ShardUncheckedUpdateWithoutBotInput, ShardUpdateWithoutBotInput>
    create: XOR<ShardUncheckedCreateWithoutBotInput, ShardCreateWithoutBotInput>
  }

  export type ShardUpdateWithWhereUniqueWithoutBotInput = {
    where: ShardWhereUniqueInput
    data: XOR<ShardUncheckedUpdateWithoutBotInput, ShardUpdateWithoutBotInput>
  }

  export type ShardUpdateManyWithWhereWithoutBotInput = {
    where: ShardScalarWhereInput
    data: XOR<ShardUncheckedUpdateManyWithoutShardsInput, ShardUpdateManyMutationInput>
  }

  export type BotCreateWithoutShardsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    discordToken?: string | null
    twitterToken?: string | null
    recommendedShards?: number
    currentShards?: number
    hosts: HostCreateNestedOneWithoutBotsInput
    owner: UserCreateNestedOneWithoutBotInput
    priorityHost?: HostCreateNestedOneWithoutPriorityBotInput
    twitchAuth: TwitchAuthCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateWithoutShardsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    hostsId: number
    priorityHostId?: number | null
    discordToken?: string | null
    twitterToken?: string | null
    twitchAuthId: number
    recommendedShards?: number
    currentShards?: number
  }

  export type BotCreateOrConnectWithoutshardsInput = {
    where: BotWhereUniqueInput
    create: XOR<BotUncheckedCreateWithoutShardsInput, BotCreateWithoutShardsInput>
  }

  export type HostCreateWithoutShardsInput = {
    createdAt?: Date | string
    ip: string
    url: string
    port?: number
    shardLimit?: number
    owner: UserCreateNestedOneWithoutHostsInput
    bots?: BotCreateNestedManyWithoutHostsInput
    priorityBot?: BotCreateNestedManyWithoutPriorityHostInput
  }

  export type HostUncheckedCreateWithoutShardsInput = {
    id?: number
    createdAt?: Date | string
    ownerId: string
    ip: string
    url: string
    port?: number
    shardLimit?: number
    bots?: BotUncheckedCreateNestedManyWithoutHostsInput
    priorityBot?: BotUncheckedCreateNestedManyWithoutPriorityHostInput
  }

  export type HostCreateOrConnectWithoutshardsInput = {
    where: HostWhereUniqueInput
    create: XOR<HostUncheckedCreateWithoutShardsInput, HostCreateWithoutShardsInput>
  }

  export type BotUpsertWithoutShardsInput = {
    update: XOR<BotUncheckedUpdateWithoutShardsInput, BotUpdateWithoutShardsInput>
    create: XOR<BotUncheckedCreateWithoutShardsInput, BotCreateWithoutShardsInput>
  }

  export type BotUpdateWithoutShardsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discordToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitterToken?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedShards?: IntFieldUpdateOperationsInput | number
    currentShards?: IntFieldUpdateOperationsInput | number
    hosts?: HostUpdateOneRequiredWithoutBotsInput
    owner?: UserUpdateOneRequiredWithoutBotInput
    priorityHost?: HostUpdateOneWithoutPriorityBotInput
    twitchAuth?: TwitchAuthUpdateOneRequiredWithoutBotInput
  }

  export type BotUncheckedUpdateWithoutShardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    hostsId?: IntFieldUpdateOperationsInput | number
    priorityHostId?: NullableIntFieldUpdateOperationsInput | number | null
    discordToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitterToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitchAuthId?: IntFieldUpdateOperationsInput | number
    recommendedShards?: IntFieldUpdateOperationsInput | number
    currentShards?: IntFieldUpdateOperationsInput | number
  }

  export type HostUpsertWithoutShardsInput = {
    update: XOR<HostUncheckedUpdateWithoutShardsInput, HostUpdateWithoutShardsInput>
    create: XOR<HostUncheckedCreateWithoutShardsInput, HostCreateWithoutShardsInput>
  }

  export type HostUpdateWithoutShardsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    shardLimit?: IntFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutHostsInput
    bots?: BotUpdateManyWithoutHostsInput
    priorityBot?: BotUpdateManyWithoutPriorityHostInput
  }

  export type HostUncheckedUpdateWithoutShardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    shardLimit?: IntFieldUpdateOperationsInput | number
    bots?: BotUncheckedUpdateManyWithoutHostsInput
    priorityBot?: BotUncheckedUpdateManyWithoutPriorityHostInput
  }

  export type ActionCreateWithoutOwnerInput = {
    registeredAt?: Date | string
    version: number
    usage?: number
    cost?: number
    type: DiscordExecutionType
    url: string
  }

  export type ActionUncheckedCreateWithoutOwnerInput = {
    id?: number
    registeredAt?: Date | string
    version: number
    usage?: number
    cost?: number
    type: DiscordExecutionType
    url: string
  }

  export type ActionCreateOrConnectWithoutownerInput = {
    where: ActionWhereUniqueInput
    create: XOR<ActionUncheckedCreateWithoutOwnerInput, ActionCreateWithoutOwnerInput>
  }

  export type BotCreateWithoutOwnerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    discordToken?: string | null
    twitterToken?: string | null
    recommendedShards?: number
    currentShards?: number
    hosts: HostCreateNestedOneWithoutBotsInput
    priorityHost?: HostCreateNestedOneWithoutPriorityBotInput
    twitchAuth: TwitchAuthCreateNestedOneWithoutBotInput
    shards?: ShardCreateNestedManyWithoutBotInput
  }

  export type BotUncheckedCreateWithoutOwnerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hostsId: number
    priorityHostId?: number | null
    discordToken?: string | null
    twitterToken?: string | null
    twitchAuthId: number
    recommendedShards?: number
    currentShards?: number
    shards?: ShardUncheckedCreateNestedManyWithoutBotInput
  }

  export type BotCreateOrConnectWithoutownerInput = {
    where: BotWhereUniqueInput
    create: XOR<BotUncheckedCreateWithoutOwnerInput, BotCreateWithoutOwnerInput>
  }

  export type CommandCreateWithoutOwnerInput = {
    id?: string
    registeredAt?: Date | string
    version: number
    usage?: number
    cost?: number
    type: DiscordExecutionType
    url: string
  }

  export type CommandUncheckedCreateWithoutOwnerInput = {
    id?: string
    registeredAt?: Date | string
    version: number
    usage?: number
    cost?: number
    type: DiscordExecutionType
    url: string
  }

  export type CommandCreateOrConnectWithoutownerInput = {
    where: CommandWhereUniqueInput
    create: XOR<CommandUncheckedCreateWithoutOwnerInput, CommandCreateWithoutOwnerInput>
  }

  export type DiscordUserCreateWithoutUserInput = {
    id: string
    username: string
    discrim: number
    administates?: AdminOnGuildsCreateNestedManyWithoutUserInput
    UsersOnGuilds?: UsersOnGuildsCreateNestedManyWithoutUserInput
  }

  export type DiscordUserUncheckedCreateWithoutUserInput = {
    id: string
    username: string
    discrim: number
    administates?: AdminOnGuildsUncheckedCreateNestedManyWithoutUserInput
    UsersOnGuilds?: UsersOnGuildsUncheckedCreateNestedManyWithoutUserInput
  }

  export type DiscordUserCreateOrConnectWithoutuserInput = {
    where: DiscordUserWhereUniqueInput
    create: XOR<DiscordUserUncheckedCreateWithoutUserInput, DiscordUserCreateWithoutUserInput>
  }

  export type HostCreateWithoutOwnerInput = {
    createdAt?: Date | string
    ip: string
    url: string
    port?: number
    shardLimit?: number
    bots?: BotCreateNestedManyWithoutHostsInput
    priorityBot?: BotCreateNestedManyWithoutPriorityHostInput
    shards?: ShardCreateNestedManyWithoutHostInput
  }

  export type HostUncheckedCreateWithoutOwnerInput = {
    id?: number
    createdAt?: Date | string
    ip: string
    url: string
    port?: number
    shardLimit?: number
    bots?: BotUncheckedCreateNestedManyWithoutHostsInput
    priorityBot?: BotUncheckedCreateNestedManyWithoutPriorityHostInput
    shards?: ShardUncheckedCreateNestedManyWithoutHostInput
  }

  export type HostCreateOrConnectWithoutownerInput = {
    where: HostWhereUniqueInput
    create: XOR<HostUncheckedCreateWithoutOwnerInput, HostCreateWithoutOwnerInput>
  }

  export type ManagerCreateWithoutOwnerInput = {
    id?: string
    createdAt?: Date | string
    ip: string
    url: string
    port?: number
    type?: ManagerLevels
    restartSchedule: string
    tasksCompleted?: number
    downtimeHistory?: ManagerCreatedowntimeHistoryInput | Enumerable<InputJsonValue>
    parentManager?: ManagerCreateNestedOneWithoutChildManagersInput
    childManagers?: ManagerCreateNestedManyWithoutParentManagerInput
    transaction?: transactionCreateNestedManyWithoutResponsibleManagerInput
    Manager_B?: ManagerCreateNestedManyWithoutManager_AInput
    Manager_A?: ManagerCreateNestedManyWithoutManager_BInput
  }

  export type ManagerUncheckedCreateWithoutOwnerInput = {
    id?: string
    createdAt?: Date | string
    ip: string
    url: string
    port?: number
    type?: ManagerLevels
    restartSchedule: string
    tasksCompleted?: number
    parentID?: string | null
    downtimeHistory?: ManagerCreatedowntimeHistoryInput | Enumerable<InputJsonValue>
    childManagers?: ManagerUncheckedCreateNestedManyWithoutParentManagerInput
    transaction?: transactionUncheckedCreateNestedManyWithoutResponsibleManagerInput
  }

  export type ManagerCreateOrConnectWithoutownerInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerUncheckedCreateWithoutOwnerInput, ManagerCreateWithoutOwnerInput>
  }

  export type PATCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: PATStatus
    transaction?: transactionCreateNestedManyWithoutPatInput
  }

  export type PATUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: PATStatus
    transaction?: transactionUncheckedCreateNestedManyWithoutPatInput
  }

  export type PATCreateOrConnectWithoutuserInput = {
    where: PATWhereUniqueInput
    create: XOR<PATUncheckedCreateWithoutUserInput, PATCreateWithoutUserInput>
  }

  export type TwitchUserCreateWithoutUserInput = {
    username: string
    accessToken: string
    refreshToken: string
  }

  export type TwitchUserUncheckedCreateWithoutUserInput = {
    id?: number
    username: string
    accessToken: string
    refreshToken: string
  }

  export type TwitchUserCreateOrConnectWithoutuserInput = {
    where: TwitchUserWhereUniqueInput
    create: XOR<TwitchUserUncheckedCreateWithoutUserInput, TwitchUserCreateWithoutUserInput>
  }

  export type TwitterUserCreateWithoutUserInput = {
    id: string
    username: string
    discrim: number
  }

  export type TwitterUserUncheckedCreateWithoutUserInput = {
    id: string
    username: string
    discrim: number
  }

  export type TwitterUserCreateOrConnectWithoutuserInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserUncheckedCreateWithoutUserInput, TwitterUserCreateWithoutUserInput>
  }

  export type ActionUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ActionWhereUniqueInput
    update: XOR<ActionUncheckedUpdateWithoutOwnerInput, ActionUpdateWithoutOwnerInput>
    create: XOR<ActionUncheckedCreateWithoutOwnerInput, ActionCreateWithoutOwnerInput>
  }

  export type ActionUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ActionWhereUniqueInput
    data: XOR<ActionUncheckedUpdateWithoutOwnerInput, ActionUpdateWithoutOwnerInput>
  }

  export type ActionUpdateManyWithWhereWithoutOwnerInput = {
    where: ActionScalarWhereInput
    data: XOR<ActionUncheckedUpdateManyWithoutActionsInput, ActionUpdateManyMutationInput>
  }

  export type ActionScalarWhereInput = {
    AND?: Enumerable<ActionScalarWhereInput>
    OR?: Enumerable<ActionScalarWhereInput>
    NOT?: Enumerable<ActionScalarWhereInput>
    id?: IntFilter | number
    ownerId?: StringFilter | string
    registeredAt?: DateTimeFilter | Date | string
    version?: IntFilter | number
    usage?: IntFilter | number
    cost?: IntFilter | number
    type?: EnumDiscordExecutionTypeFilter | DiscordExecutionType
    url?: StringFilter | string
  }

  export type BotUpsertWithWhereUniqueWithoutOwnerInput = {
    where: BotWhereUniqueInput
    update: XOR<BotUncheckedUpdateWithoutOwnerInput, BotUpdateWithoutOwnerInput>
    create: XOR<BotUncheckedCreateWithoutOwnerInput, BotCreateWithoutOwnerInput>
  }

  export type BotUpdateWithWhereUniqueWithoutOwnerInput = {
    where: BotWhereUniqueInput
    data: XOR<BotUncheckedUpdateWithoutOwnerInput, BotUpdateWithoutOwnerInput>
  }

  export type BotUpdateManyWithWhereWithoutOwnerInput = {
    where: BotScalarWhereInput
    data: XOR<BotUncheckedUpdateManyWithoutBotInput, BotUpdateManyMutationInput>
  }

  export type CommandUpsertWithWhereUniqueWithoutOwnerInput = {
    where: CommandWhereUniqueInput
    update: XOR<CommandUncheckedUpdateWithoutOwnerInput, CommandUpdateWithoutOwnerInput>
    create: XOR<CommandUncheckedCreateWithoutOwnerInput, CommandCreateWithoutOwnerInput>
  }

  export type CommandUpdateWithWhereUniqueWithoutOwnerInput = {
    where: CommandWhereUniqueInput
    data: XOR<CommandUncheckedUpdateWithoutOwnerInput, CommandUpdateWithoutOwnerInput>
  }

  export type CommandUpdateManyWithWhereWithoutOwnerInput = {
    where: CommandScalarWhereInput
    data: XOR<CommandUncheckedUpdateManyWithoutCommandsInput, CommandUpdateManyMutationInput>
  }

  export type CommandScalarWhereInput = {
    AND?: Enumerable<CommandScalarWhereInput>
    OR?: Enumerable<CommandScalarWhereInput>
    NOT?: Enumerable<CommandScalarWhereInput>
    id?: StringFilter | string
    ownerId?: StringFilter | string
    registeredAt?: DateTimeFilter | Date | string
    version?: IntFilter | number
    usage?: IntFilter | number
    cost?: IntFilter | number
    type?: EnumDiscordExecutionTypeFilter | DiscordExecutionType
    url?: StringFilter | string
  }

  export type DiscordUserUpsertWithoutUserInput = {
    update: XOR<DiscordUserUncheckedUpdateWithoutUserInput, DiscordUserUpdateWithoutUserInput>
    create: XOR<DiscordUserUncheckedCreateWithoutUserInput, DiscordUserCreateWithoutUserInput>
  }

  export type DiscordUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discrim?: IntFieldUpdateOperationsInput | number
    administates?: AdminOnGuildsUpdateManyWithoutUserInput
    UsersOnGuilds?: UsersOnGuildsUpdateManyWithoutUserInput
  }

  export type DiscordUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discrim?: IntFieldUpdateOperationsInput | number
    administates?: AdminOnGuildsUncheckedUpdateManyWithoutUserInput
    UsersOnGuilds?: UsersOnGuildsUncheckedUpdateManyWithoutUserInput
  }

  export type HostUpsertWithWhereUniqueWithoutOwnerInput = {
    where: HostWhereUniqueInput
    update: XOR<HostUncheckedUpdateWithoutOwnerInput, HostUpdateWithoutOwnerInput>
    create: XOR<HostUncheckedCreateWithoutOwnerInput, HostCreateWithoutOwnerInput>
  }

  export type HostUpdateWithWhereUniqueWithoutOwnerInput = {
    where: HostWhereUniqueInput
    data: XOR<HostUncheckedUpdateWithoutOwnerInput, HostUpdateWithoutOwnerInput>
  }

  export type HostUpdateManyWithWhereWithoutOwnerInput = {
    where: HostScalarWhereInput
    data: XOR<HostUncheckedUpdateManyWithoutHostsInput, HostUpdateManyMutationInput>
  }

  export type HostScalarWhereInput = {
    AND?: Enumerable<HostScalarWhereInput>
    OR?: Enumerable<HostScalarWhereInput>
    NOT?: Enumerable<HostScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    ownerId?: StringFilter | string
    ip?: StringFilter | string
    url?: StringFilter | string
    port?: IntFilter | number
    shardLimit?: IntFilter | number
  }

  export type ManagerUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ManagerWhereUniqueInput
    update: XOR<ManagerUncheckedUpdateWithoutOwnerInput, ManagerUpdateWithoutOwnerInput>
    create: XOR<ManagerUncheckedCreateWithoutOwnerInput, ManagerCreateWithoutOwnerInput>
  }

  export type ManagerUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ManagerWhereUniqueInput
    data: XOR<ManagerUncheckedUpdateWithoutOwnerInput, ManagerUpdateWithoutOwnerInput>
  }

  export type ManagerUpdateManyWithWhereWithoutOwnerInput = {
    where: ManagerScalarWhereInput
    data: XOR<ManagerUncheckedUpdateManyWithoutManagerInput, ManagerUpdateManyMutationInput>
  }

  export type PATUpsertWithWhereUniqueWithoutUserInput = {
    where: PATWhereUniqueInput
    update: XOR<PATUncheckedUpdateWithoutUserInput, PATUpdateWithoutUserInput>
    create: XOR<PATUncheckedCreateWithoutUserInput, PATCreateWithoutUserInput>
  }

  export type PATUpdateWithWhereUniqueWithoutUserInput = {
    where: PATWhereUniqueInput
    data: XOR<PATUncheckedUpdateWithoutUserInput, PATUpdateWithoutUserInput>
  }

  export type PATUpdateManyWithWhereWithoutUserInput = {
    where: PATScalarWhereInput
    data: XOR<PATUncheckedUpdateManyWithoutPatInput, PATUpdateManyMutationInput>
  }

  export type PATScalarWhereInput = {
    AND?: Enumerable<PATScalarWhereInput>
    OR?: Enumerable<PATScalarWhereInput>
    NOT?: Enumerable<PATScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    status?: EnumPATStatusFilter | PATStatus
  }

  export type TwitchUserUpsertWithoutUserInput = {
    update: XOR<TwitchUserUncheckedUpdateWithoutUserInput, TwitchUserUpdateWithoutUserInput>
    create: XOR<TwitchUserUncheckedCreateWithoutUserInput, TwitchUserCreateWithoutUserInput>
  }

  export type TwitchUserUpdateWithoutUserInput = {
    username?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
  }

  export type TwitchUserUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
  }

  export type TwitterUserUpsertWithWhereUniqueWithoutUserInput = {
    where: TwitterUserWhereUniqueInput
    update: XOR<TwitterUserUncheckedUpdateWithoutUserInput, TwitterUserUpdateWithoutUserInput>
    create: XOR<TwitterUserUncheckedCreateWithoutUserInput, TwitterUserCreateWithoutUserInput>
  }

  export type TwitterUserUpdateWithWhereUniqueWithoutUserInput = {
    where: TwitterUserWhereUniqueInput
    data: XOR<TwitterUserUncheckedUpdateWithoutUserInput, TwitterUserUpdateWithoutUserInput>
  }

  export type TwitterUserUpdateManyWithWhereWithoutUserInput = {
    where: TwitterUserScalarWhereInput
    data: XOR<TwitterUserUncheckedUpdateManyWithoutTwitterUserInput, TwitterUserUpdateManyMutationInput>
  }

  export type TwitterUserScalarWhereInput = {
    AND?: Enumerable<TwitterUserScalarWhereInput>
    OR?: Enumerable<TwitterUserScalarWhereInput>
    NOT?: Enumerable<TwitterUserScalarWhereInput>
    id?: StringFilter | string
    username?: StringFilter | string
    discrim?: IntFilter | number
    userId?: StringNullableFilter | string | null
  }

  export type UserCreateWithoutPatInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionCreateNestedManyWithoutOwnerInput
    Bot?: BotCreateNestedManyWithoutOwnerInput
    commands?: CommandCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserCreateNestedOneWithoutUserInput
    Hosts?: HostCreateNestedManyWithoutOwnerInput
    Manager?: ManagerCreateNestedManyWithoutOwnerInput
    twitch?: TwitchUserCreateNestedOneWithoutUserInput
    TwitterUser?: TwitterUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPatInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionUncheckedCreateNestedManyWithoutOwnerInput
    Bot?: BotUncheckedCreateNestedManyWithoutOwnerInput
    commands?: CommandUncheckedCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserUncheckedCreateNestedOneWithoutUserInput
    Hosts?: HostUncheckedCreateNestedManyWithoutOwnerInput
    Manager?: ManagerUncheckedCreateNestedManyWithoutOwnerInput
    twitch?: TwitchUserUncheckedCreateNestedOneWithoutUserInput
    TwitterUser?: TwitterUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutpatInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutPatInput, UserCreateWithoutPatInput>
  }

  export type transactionCreateWithoutPatInput = {
    id?: string
    createdAt?: Date | string
    completedAt?: Date | string | null
    suspicious?: boolean
    fraudulent?: boolean
    reversedAt?: Date | string | null
    responsibleManager: ManagerCreateNestedOneWithoutTransactionInput
  }

  export type transactionUncheckedCreateWithoutPatInput = {
    id?: string
    createdAt?: Date | string
    completedAt?: Date | string | null
    managerId: string
    suspicious?: boolean
    fraudulent?: boolean
    reversedAt?: Date | string | null
  }

  export type transactionCreateOrConnectWithoutpatInput = {
    where: transactionWhereUniqueInput
    create: XOR<transactionUncheckedCreateWithoutPatInput, transactionCreateWithoutPatInput>
  }

  export type UserUpsertWithoutPatInput = {
    update: XOR<UserUncheckedUpdateWithoutPatInput, UserUpdateWithoutPatInput>
    create: XOR<UserUncheckedCreateWithoutPatInput, UserCreateWithoutPatInput>
  }

  export type UserUpdateWithoutPatInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUpdateManyWithoutOwnerInput
    Bot?: BotUpdateManyWithoutOwnerInput
    commands?: CommandUpdateManyWithoutOwnerInput
    discord?: DiscordUserUpdateOneWithoutUserInput
    Hosts?: HostUpdateManyWithoutOwnerInput
    Manager?: ManagerUpdateManyWithoutOwnerInput
    twitch?: TwitchUserUpdateOneWithoutUserInput
    TwitterUser?: TwitterUserUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutPatInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUncheckedUpdateManyWithoutOwnerInput
    Bot?: BotUncheckedUpdateManyWithoutOwnerInput
    commands?: CommandUncheckedUpdateManyWithoutOwnerInput
    discord?: DiscordUserUncheckedUpdateOneWithoutUserInput
    Hosts?: HostUncheckedUpdateManyWithoutOwnerInput
    Manager?: ManagerUncheckedUpdateManyWithoutOwnerInput
    twitch?: TwitchUserUncheckedUpdateOneWithoutUserInput
    TwitterUser?: TwitterUserUncheckedUpdateManyWithoutUserInput
  }

  export type transactionUpsertWithWhereUniqueWithoutPatInput = {
    where: transactionWhereUniqueInput
    update: XOR<transactionUncheckedUpdateWithoutPatInput, transactionUpdateWithoutPatInput>
    create: XOR<transactionUncheckedCreateWithoutPatInput, transactionCreateWithoutPatInput>
  }

  export type transactionUpdateWithWhereUniqueWithoutPatInput = {
    where: transactionWhereUniqueInput
    data: XOR<transactionUncheckedUpdateWithoutPatInput, transactionUpdateWithoutPatInput>
  }

  export type transactionUpdateManyWithWhereWithoutPatInput = {
    where: transactionScalarWhereInput
    data: XOR<transactionUncheckedUpdateManyWithoutTransactionInput, transactionUpdateManyMutationInput>
  }

  export type ManagerCreateWithoutTransactionInput = {
    id?: string
    createdAt?: Date | string
    ip: string
    url: string
    port?: number
    type?: ManagerLevels
    restartSchedule: string
    tasksCompleted?: number
    downtimeHistory?: ManagerCreatedowntimeHistoryInput | Enumerable<InputJsonValue>
    owner: UserCreateNestedOneWithoutManagerInput
    parentManager?: ManagerCreateNestedOneWithoutChildManagersInput
    childManagers?: ManagerCreateNestedManyWithoutParentManagerInput
    Manager_B?: ManagerCreateNestedManyWithoutManager_AInput
    Manager_A?: ManagerCreateNestedManyWithoutManager_BInput
  }

  export type ManagerUncheckedCreateWithoutTransactionInput = {
    id?: string
    createdAt?: Date | string
    ownerId: string
    ip: string
    url: string
    port?: number
    type?: ManagerLevels
    restartSchedule: string
    tasksCompleted?: number
    parentID?: string | null
    downtimeHistory?: ManagerCreatedowntimeHistoryInput | Enumerable<InputJsonValue>
    childManagers?: ManagerUncheckedCreateNestedManyWithoutParentManagerInput
  }

  export type ManagerCreateOrConnectWithouttransactionInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerUncheckedCreateWithoutTransactionInput, ManagerCreateWithoutTransactionInput>
  }

  export type PATCreateWithoutTransactionInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: PATStatus
    user: UserCreateNestedOneWithoutPatInput
  }

  export type PATUncheckedCreateWithoutTransactionInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: PATStatus
  }

  export type PATCreateOrConnectWithouttransactionInput = {
    where: PATWhereUniqueInput
    create: XOR<PATUncheckedCreateWithoutTransactionInput, PATCreateWithoutTransactionInput>
  }

  export type ManagerUpsertWithoutTransactionInput = {
    update: XOR<ManagerUncheckedUpdateWithoutTransactionInput, ManagerUpdateWithoutTransactionInput>
    create: XOR<ManagerUncheckedCreateWithoutTransactionInput, ManagerCreateWithoutTransactionInput>
  }

  export type ManagerUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
    owner?: UserUpdateOneRequiredWithoutManagerInput
    parentManager?: ManagerUpdateOneWithoutChildManagersInput
    childManagers?: ManagerUpdateManyWithoutParentManagerInput
    Manager_B?: ManagerUpdateManyWithoutManager_AInput
    Manager_A?: ManagerUpdateManyWithoutManager_BInput
  }

  export type ManagerUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    parentID?: NullableStringFieldUpdateOperationsInput | string | null
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
    childManagers?: ManagerUncheckedUpdateManyWithoutParentManagerInput
  }

  export type PATUpsertWithoutTransactionInput = {
    update: XOR<PATUncheckedUpdateWithoutTransactionInput, PATUpdateWithoutTransactionInput>
    create: XOR<PATUncheckedCreateWithoutTransactionInput, PATCreateWithoutTransactionInput>
  }

  export type PATUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPATStatusFieldUpdateOperationsInput | PATStatus
    user?: UserUpdateOneRequiredWithoutPatInput
  }

  export type PATUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPATStatusFieldUpdateOperationsInput | PATStatus
  }

  export type UserCreateWithoutDiscordInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionCreateNestedManyWithoutOwnerInput
    Bot?: BotCreateNestedManyWithoutOwnerInput
    commands?: CommandCreateNestedManyWithoutOwnerInput
    Hosts?: HostCreateNestedManyWithoutOwnerInput
    Manager?: ManagerCreateNestedManyWithoutOwnerInput
    pat?: PATCreateNestedManyWithoutUserInput
    twitch?: TwitchUserCreateNestedOneWithoutUserInput
    TwitterUser?: TwitterUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDiscordInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionUncheckedCreateNestedManyWithoutOwnerInput
    Bot?: BotUncheckedCreateNestedManyWithoutOwnerInput
    commands?: CommandUncheckedCreateNestedManyWithoutOwnerInput
    Hosts?: HostUncheckedCreateNestedManyWithoutOwnerInput
    Manager?: ManagerUncheckedCreateNestedManyWithoutOwnerInput
    pat?: PATUncheckedCreateNestedManyWithoutUserInput
    twitch?: TwitchUserUncheckedCreateNestedOneWithoutUserInput
    TwitterUser?: TwitterUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutdiscordInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutDiscordInput, UserCreateWithoutDiscordInput>
  }

  export type AdminOnGuildsCreateWithoutUserInput = {
    createdAt?: Date | string
    guild: guildCreateNestedOneWithoutAdminsInput
  }

  export type AdminOnGuildsUncheckedCreateWithoutUserInput = {
    guildId: number
    createdAt?: Date | string
  }

  export type AdminOnGuildsCreateOrConnectWithoutuserInput = {
    where: AdminOnGuildsWhereUniqueInput
    create: XOR<AdminOnGuildsUncheckedCreateWithoutUserInput, AdminOnGuildsCreateWithoutUserInput>
  }

  export type UsersOnGuildsCreateWithoutUserInput = {
    createdAt?: Date | string
    guild: guildCreateNestedOneWithoutMembersInput
  }

  export type UsersOnGuildsUncheckedCreateWithoutUserInput = {
    guildId: number
    createdAt?: Date | string
  }

  export type UsersOnGuildsCreateOrConnectWithoutuserInput = {
    where: UsersOnGuildsWhereUniqueInput
    create: XOR<UsersOnGuildsUncheckedCreateWithoutUserInput, UsersOnGuildsCreateWithoutUserInput>
  }

  export type UserUpsertWithoutDiscordInput = {
    update: XOR<UserUncheckedUpdateWithoutDiscordInput, UserUpdateWithoutDiscordInput>
    create: XOR<UserUncheckedCreateWithoutDiscordInput, UserCreateWithoutDiscordInput>
  }

  export type UserUpdateWithoutDiscordInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUpdateManyWithoutOwnerInput
    Bot?: BotUpdateManyWithoutOwnerInput
    commands?: CommandUpdateManyWithoutOwnerInput
    Hosts?: HostUpdateManyWithoutOwnerInput
    Manager?: ManagerUpdateManyWithoutOwnerInput
    pat?: PATUpdateManyWithoutUserInput
    twitch?: TwitchUserUpdateOneWithoutUserInput
    TwitterUser?: TwitterUserUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutDiscordInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUncheckedUpdateManyWithoutOwnerInput
    Bot?: BotUncheckedUpdateManyWithoutOwnerInput
    commands?: CommandUncheckedUpdateManyWithoutOwnerInput
    Hosts?: HostUncheckedUpdateManyWithoutOwnerInput
    Manager?: ManagerUncheckedUpdateManyWithoutOwnerInput
    pat?: PATUncheckedUpdateManyWithoutUserInput
    twitch?: TwitchUserUncheckedUpdateOneWithoutUserInput
    TwitterUser?: TwitterUserUncheckedUpdateManyWithoutUserInput
  }

  export type AdminOnGuildsUpsertWithWhereUniqueWithoutUserInput = {
    where: AdminOnGuildsWhereUniqueInput
    update: XOR<AdminOnGuildsUncheckedUpdateWithoutUserInput, AdminOnGuildsUpdateWithoutUserInput>
    create: XOR<AdminOnGuildsUncheckedCreateWithoutUserInput, AdminOnGuildsCreateWithoutUserInput>
  }

  export type AdminOnGuildsUpdateWithWhereUniqueWithoutUserInput = {
    where: AdminOnGuildsWhereUniqueInput
    data: XOR<AdminOnGuildsUncheckedUpdateWithoutUserInput, AdminOnGuildsUpdateWithoutUserInput>
  }

  export type AdminOnGuildsUpdateManyWithWhereWithoutUserInput = {
    where: AdminOnGuildsScalarWhereInput
    data: XOR<AdminOnGuildsUncheckedUpdateManyWithoutAdministatesInput, AdminOnGuildsUpdateManyMutationInput>
  }

  export type AdminOnGuildsScalarWhereInput = {
    AND?: Enumerable<AdminOnGuildsScalarWhereInput>
    OR?: Enumerable<AdminOnGuildsScalarWhereInput>
    NOT?: Enumerable<AdminOnGuildsScalarWhereInput>
    userId?: StringFilter | string
    guildId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type UsersOnGuildsUpsertWithWhereUniqueWithoutUserInput = {
    where: UsersOnGuildsWhereUniqueInput
    update: XOR<UsersOnGuildsUncheckedUpdateWithoutUserInput, UsersOnGuildsUpdateWithoutUserInput>
    create: XOR<UsersOnGuildsUncheckedCreateWithoutUserInput, UsersOnGuildsCreateWithoutUserInput>
  }

  export type UsersOnGuildsUpdateWithWhereUniqueWithoutUserInput = {
    where: UsersOnGuildsWhereUniqueInput
    data: XOR<UsersOnGuildsUncheckedUpdateWithoutUserInput, UsersOnGuildsUpdateWithoutUserInput>
  }

  export type UsersOnGuildsUpdateManyWithWhereWithoutUserInput = {
    where: UsersOnGuildsScalarWhereInput
    data: XOR<UsersOnGuildsUncheckedUpdateManyWithoutUsersOnGuildsInput, UsersOnGuildsUpdateManyMutationInput>
  }

  export type UsersOnGuildsScalarWhereInput = {
    AND?: Enumerable<UsersOnGuildsScalarWhereInput>
    OR?: Enumerable<UsersOnGuildsScalarWhereInput>
    NOT?: Enumerable<UsersOnGuildsScalarWhereInput>
    userId?: StringFilter | string
    guildId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type AdminOnGuildsCreateWithoutGuildInput = {
    createdAt?: Date | string
    user: DiscordUserCreateNestedOneWithoutAdministatesInput
  }

  export type AdminOnGuildsUncheckedCreateWithoutGuildInput = {
    userId: string
    createdAt?: Date | string
  }

  export type AdminOnGuildsCreateOrConnectWithoutguildInput = {
    where: AdminOnGuildsWhereUniqueInput
    create: XOR<AdminOnGuildsUncheckedCreateWithoutGuildInput, AdminOnGuildsCreateWithoutGuildInput>
  }

  export type UsersOnGuildsCreateWithoutGuildInput = {
    createdAt?: Date | string
    user: DiscordUserCreateNestedOneWithoutUsersOnGuildsInput
  }

  export type UsersOnGuildsUncheckedCreateWithoutGuildInput = {
    userId: string
    createdAt?: Date | string
  }

  export type UsersOnGuildsCreateOrConnectWithoutguildInput = {
    where: UsersOnGuildsWhereUniqueInput
    create: XOR<UsersOnGuildsUncheckedCreateWithoutGuildInput, UsersOnGuildsCreateWithoutGuildInput>
  }

  export type AdminOnGuildsUpsertWithWhereUniqueWithoutGuildInput = {
    where: AdminOnGuildsWhereUniqueInput
    update: XOR<AdminOnGuildsUncheckedUpdateWithoutGuildInput, AdminOnGuildsUpdateWithoutGuildInput>
    create: XOR<AdminOnGuildsUncheckedCreateWithoutGuildInput, AdminOnGuildsCreateWithoutGuildInput>
  }

  export type AdminOnGuildsUpdateWithWhereUniqueWithoutGuildInput = {
    where: AdminOnGuildsWhereUniqueInput
    data: XOR<AdminOnGuildsUncheckedUpdateWithoutGuildInput, AdminOnGuildsUpdateWithoutGuildInput>
  }

  export type AdminOnGuildsUpdateManyWithWhereWithoutGuildInput = {
    where: AdminOnGuildsScalarWhereInput
    data: XOR<AdminOnGuildsUncheckedUpdateManyWithoutAdminsInput, AdminOnGuildsUpdateManyMutationInput>
  }

  export type UsersOnGuildsUpsertWithWhereUniqueWithoutGuildInput = {
    where: UsersOnGuildsWhereUniqueInput
    update: XOR<UsersOnGuildsUncheckedUpdateWithoutGuildInput, UsersOnGuildsUpdateWithoutGuildInput>
    create: XOR<UsersOnGuildsUncheckedCreateWithoutGuildInput, UsersOnGuildsCreateWithoutGuildInput>
  }

  export type UsersOnGuildsUpdateWithWhereUniqueWithoutGuildInput = {
    where: UsersOnGuildsWhereUniqueInput
    data: XOR<UsersOnGuildsUncheckedUpdateWithoutGuildInput, UsersOnGuildsUpdateWithoutGuildInput>
  }

  export type UsersOnGuildsUpdateManyWithWhereWithoutGuildInput = {
    where: UsersOnGuildsScalarWhereInput
    data: XOR<UsersOnGuildsUncheckedUpdateManyWithoutMembersInput, UsersOnGuildsUpdateManyMutationInput>
  }

  export type guildCreateWithoutMembersInput = {
    id: number
    name: string
    admins?: AdminOnGuildsCreateNestedManyWithoutGuildInput
  }

  export type guildUncheckedCreateWithoutMembersInput = {
    id: number
    name: string
    admins?: AdminOnGuildsUncheckedCreateNestedManyWithoutGuildInput
  }

  export type guildCreateOrConnectWithoutmembersInput = {
    where: guildWhereUniqueInput
    create: XOR<guildUncheckedCreateWithoutMembersInput, guildCreateWithoutMembersInput>
  }

  export type DiscordUserCreateWithoutUsersOnGuildsInput = {
    id: string
    username: string
    discrim: number
    user?: UserCreateNestedOneWithoutDiscordInput
    administates?: AdminOnGuildsCreateNestedManyWithoutUserInput
  }

  export type DiscordUserUncheckedCreateWithoutUsersOnGuildsInput = {
    id: string
    username: string
    discrim: number
    userId?: string | null
    administates?: AdminOnGuildsUncheckedCreateNestedManyWithoutUserInput
  }

  export type DiscordUserCreateOrConnectWithoutUsersOnGuildsInput = {
    where: DiscordUserWhereUniqueInput
    create: XOR<DiscordUserUncheckedCreateWithoutUsersOnGuildsInput, DiscordUserCreateWithoutUsersOnGuildsInput>
  }

  export type guildUpsertWithoutMembersInput = {
    update: XOR<guildUncheckedUpdateWithoutMembersInput, guildUpdateWithoutMembersInput>
    create: XOR<guildUncheckedCreateWithoutMembersInput, guildCreateWithoutMembersInput>
  }

  export type guildUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    admins?: AdminOnGuildsUpdateManyWithoutGuildInput
  }

  export type guildUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    admins?: AdminOnGuildsUncheckedUpdateManyWithoutGuildInput
  }

  export type DiscordUserUpsertWithoutUsersOnGuildsInput = {
    update: XOR<DiscordUserUncheckedUpdateWithoutUsersOnGuildsInput, DiscordUserUpdateWithoutUsersOnGuildsInput>
    create: XOR<DiscordUserUncheckedCreateWithoutUsersOnGuildsInput, DiscordUserCreateWithoutUsersOnGuildsInput>
  }

  export type DiscordUserUpdateWithoutUsersOnGuildsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discrim?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutDiscordInput
    administates?: AdminOnGuildsUpdateManyWithoutUserInput
  }

  export type DiscordUserUncheckedUpdateWithoutUsersOnGuildsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discrim?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    administates?: AdminOnGuildsUncheckedUpdateManyWithoutUserInput
  }

  export type guildCreateWithoutAdminsInput = {
    id: number
    name: string
    members?: UsersOnGuildsCreateNestedManyWithoutGuildInput
  }

  export type guildUncheckedCreateWithoutAdminsInput = {
    id: number
    name: string
    members?: UsersOnGuildsUncheckedCreateNestedManyWithoutGuildInput
  }

  export type guildCreateOrConnectWithoutadminsInput = {
    where: guildWhereUniqueInput
    create: XOR<guildUncheckedCreateWithoutAdminsInput, guildCreateWithoutAdminsInput>
  }

  export type DiscordUserCreateWithoutAdministatesInput = {
    id: string
    username: string
    discrim: number
    user?: UserCreateNestedOneWithoutDiscordInput
    UsersOnGuilds?: UsersOnGuildsCreateNestedManyWithoutUserInput
  }

  export type DiscordUserUncheckedCreateWithoutAdministatesInput = {
    id: string
    username: string
    discrim: number
    userId?: string | null
    UsersOnGuilds?: UsersOnGuildsUncheckedCreateNestedManyWithoutUserInput
  }

  export type DiscordUserCreateOrConnectWithoutadministatesInput = {
    where: DiscordUserWhereUniqueInput
    create: XOR<DiscordUserUncheckedCreateWithoutAdministatesInput, DiscordUserCreateWithoutAdministatesInput>
  }

  export type guildUpsertWithoutAdminsInput = {
    update: XOR<guildUncheckedUpdateWithoutAdminsInput, guildUpdateWithoutAdminsInput>
    create: XOR<guildUncheckedCreateWithoutAdminsInput, guildCreateWithoutAdminsInput>
  }

  export type guildUpdateWithoutAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    members?: UsersOnGuildsUpdateManyWithoutGuildInput
  }

  export type guildUncheckedUpdateWithoutAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    members?: UsersOnGuildsUncheckedUpdateManyWithoutGuildInput
  }

  export type DiscordUserUpsertWithoutAdministatesInput = {
    update: XOR<DiscordUserUncheckedUpdateWithoutAdministatesInput, DiscordUserUpdateWithoutAdministatesInput>
    create: XOR<DiscordUserUncheckedCreateWithoutAdministatesInput, DiscordUserCreateWithoutAdministatesInput>
  }

  export type DiscordUserUpdateWithoutAdministatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discrim?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutDiscordInput
    UsersOnGuilds?: UsersOnGuildsUpdateManyWithoutUserInput
  }

  export type DiscordUserUncheckedUpdateWithoutAdministatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discrim?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    UsersOnGuilds?: UsersOnGuildsUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutCommandsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionCreateNestedManyWithoutOwnerInput
    Bot?: BotCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserCreateNestedOneWithoutUserInput
    Hosts?: HostCreateNestedManyWithoutOwnerInput
    Manager?: ManagerCreateNestedManyWithoutOwnerInput
    pat?: PATCreateNestedManyWithoutUserInput
    twitch?: TwitchUserCreateNestedOneWithoutUserInput
    TwitterUser?: TwitterUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommandsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionUncheckedCreateNestedManyWithoutOwnerInput
    Bot?: BotUncheckedCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserUncheckedCreateNestedOneWithoutUserInput
    Hosts?: HostUncheckedCreateNestedManyWithoutOwnerInput
    Manager?: ManagerUncheckedCreateNestedManyWithoutOwnerInput
    pat?: PATUncheckedCreateNestedManyWithoutUserInput
    twitch?: TwitchUserUncheckedCreateNestedOneWithoutUserInput
    TwitterUser?: TwitterUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutcommandsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutCommandsInput, UserCreateWithoutCommandsInput>
  }

  export type UserUpsertWithoutCommandsInput = {
    update: XOR<UserUncheckedUpdateWithoutCommandsInput, UserUpdateWithoutCommandsInput>
    create: XOR<UserUncheckedCreateWithoutCommandsInput, UserCreateWithoutCommandsInput>
  }

  export type UserUpdateWithoutCommandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUpdateManyWithoutOwnerInput
    Bot?: BotUpdateManyWithoutOwnerInput
    discord?: DiscordUserUpdateOneWithoutUserInput
    Hosts?: HostUpdateManyWithoutOwnerInput
    Manager?: ManagerUpdateManyWithoutOwnerInput
    pat?: PATUpdateManyWithoutUserInput
    twitch?: TwitchUserUpdateOneWithoutUserInput
    TwitterUser?: TwitterUserUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUncheckedUpdateManyWithoutOwnerInput
    Bot?: BotUncheckedUpdateManyWithoutOwnerInput
    discord?: DiscordUserUncheckedUpdateOneWithoutUserInput
    Hosts?: HostUncheckedUpdateManyWithoutOwnerInput
    Manager?: ManagerUncheckedUpdateManyWithoutOwnerInput
    pat?: PATUncheckedUpdateManyWithoutUserInput
    twitch?: TwitchUserUncheckedUpdateOneWithoutUserInput
    TwitterUser?: TwitterUserUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutActionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    Bot?: BotCreateNestedManyWithoutOwnerInput
    commands?: CommandCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserCreateNestedOneWithoutUserInput
    Hosts?: HostCreateNestedManyWithoutOwnerInput
    Manager?: ManagerCreateNestedManyWithoutOwnerInput
    pat?: PATCreateNestedManyWithoutUserInput
    twitch?: TwitchUserCreateNestedOneWithoutUserInput
    TwitterUser?: TwitterUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActionsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    Bot?: BotUncheckedCreateNestedManyWithoutOwnerInput
    commands?: CommandUncheckedCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserUncheckedCreateNestedOneWithoutUserInput
    Hosts?: HostUncheckedCreateNestedManyWithoutOwnerInput
    Manager?: ManagerUncheckedCreateNestedManyWithoutOwnerInput
    pat?: PATUncheckedCreateNestedManyWithoutUserInput
    twitch?: TwitchUserUncheckedCreateNestedOneWithoutUserInput
    TwitterUser?: TwitterUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutActionsInput, UserCreateWithoutActionsInput>
  }

  export type UserUpsertWithoutActionsInput = {
    update: XOR<UserUncheckedUpdateWithoutActionsInput, UserUpdateWithoutActionsInput>
    create: XOR<UserUncheckedCreateWithoutActionsInput, UserCreateWithoutActionsInput>
  }

  export type UserUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    Bot?: BotUpdateManyWithoutOwnerInput
    commands?: CommandUpdateManyWithoutOwnerInput
    discord?: DiscordUserUpdateOneWithoutUserInput
    Hosts?: HostUpdateManyWithoutOwnerInput
    Manager?: ManagerUpdateManyWithoutOwnerInput
    pat?: PATUpdateManyWithoutUserInput
    twitch?: TwitchUserUpdateOneWithoutUserInput
    TwitterUser?: TwitterUserUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    Bot?: BotUncheckedUpdateManyWithoutOwnerInput
    commands?: CommandUncheckedUpdateManyWithoutOwnerInput
    discord?: DiscordUserUncheckedUpdateOneWithoutUserInput
    Hosts?: HostUncheckedUpdateManyWithoutOwnerInput
    Manager?: ManagerUncheckedUpdateManyWithoutOwnerInput
    pat?: PATUncheckedUpdateManyWithoutUserInput
    twitch?: TwitchUserUncheckedUpdateOneWithoutUserInput
    TwitterUser?: TwitterUserUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutTwitchInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionCreateNestedManyWithoutOwnerInput
    Bot?: BotCreateNestedManyWithoutOwnerInput
    commands?: CommandCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserCreateNestedOneWithoutUserInput
    Hosts?: HostCreateNestedManyWithoutOwnerInput
    Manager?: ManagerCreateNestedManyWithoutOwnerInput
    pat?: PATCreateNestedManyWithoutUserInput
    TwitterUser?: TwitterUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTwitchInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionUncheckedCreateNestedManyWithoutOwnerInput
    Bot?: BotUncheckedCreateNestedManyWithoutOwnerInput
    commands?: CommandUncheckedCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserUncheckedCreateNestedOneWithoutUserInput
    Hosts?: HostUncheckedCreateNestedManyWithoutOwnerInput
    Manager?: ManagerUncheckedCreateNestedManyWithoutOwnerInput
    pat?: PATUncheckedCreateNestedManyWithoutUserInput
    TwitterUser?: TwitterUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithouttwitchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutTwitchInput, UserCreateWithoutTwitchInput>
  }

  export type UserUpsertWithoutTwitchInput = {
    update: XOR<UserUncheckedUpdateWithoutTwitchInput, UserUpdateWithoutTwitchInput>
    create: XOR<UserUncheckedCreateWithoutTwitchInput, UserCreateWithoutTwitchInput>
  }

  export type UserUpdateWithoutTwitchInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUpdateManyWithoutOwnerInput
    Bot?: BotUpdateManyWithoutOwnerInput
    commands?: CommandUpdateManyWithoutOwnerInput
    discord?: DiscordUserUpdateOneWithoutUserInput
    Hosts?: HostUpdateManyWithoutOwnerInput
    Manager?: ManagerUpdateManyWithoutOwnerInput
    pat?: PATUpdateManyWithoutUserInput
    TwitterUser?: TwitterUserUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutTwitchInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUncheckedUpdateManyWithoutOwnerInput
    Bot?: BotUncheckedUpdateManyWithoutOwnerInput
    commands?: CommandUncheckedUpdateManyWithoutOwnerInput
    discord?: DiscordUserUncheckedUpdateOneWithoutUserInput
    Hosts?: HostUncheckedUpdateManyWithoutOwnerInput
    Manager?: ManagerUncheckedUpdateManyWithoutOwnerInput
    pat?: PATUncheckedUpdateManyWithoutUserInput
    TwitterUser?: TwitterUserUncheckedUpdateManyWithoutUserInput
  }

  export type BotCreateWithoutTwitchAuthInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    discordToken?: string | null
    twitterToken?: string | null
    recommendedShards?: number
    currentShards?: number
    hosts: HostCreateNestedOneWithoutBotsInput
    owner: UserCreateNestedOneWithoutBotInput
    priorityHost?: HostCreateNestedOneWithoutPriorityBotInput
    shards?: ShardCreateNestedManyWithoutBotInput
  }

  export type BotUncheckedCreateWithoutTwitchAuthInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    hostsId: number
    priorityHostId?: number | null
    discordToken?: string | null
    twitterToken?: string | null
    recommendedShards?: number
    currentShards?: number
    shards?: ShardUncheckedCreateNestedManyWithoutBotInput
  }

  export type BotCreateOrConnectWithouttwitchAuthInput = {
    where: BotWhereUniqueInput
    create: XOR<BotUncheckedCreateWithoutTwitchAuthInput, BotCreateWithoutTwitchAuthInput>
  }

  export type BotUpsertWithWhereUniqueWithoutTwitchAuthInput = {
    where: BotWhereUniqueInput
    update: XOR<BotUncheckedUpdateWithoutTwitchAuthInput, BotUpdateWithoutTwitchAuthInput>
    create: XOR<BotUncheckedCreateWithoutTwitchAuthInput, BotCreateWithoutTwitchAuthInput>
  }

  export type BotUpdateWithWhereUniqueWithoutTwitchAuthInput = {
    where: BotWhereUniqueInput
    data: XOR<BotUncheckedUpdateWithoutTwitchAuthInput, BotUpdateWithoutTwitchAuthInput>
  }

  export type BotUpdateManyWithWhereWithoutTwitchAuthInput = {
    where: BotScalarWhereInput
    data: XOR<BotUncheckedUpdateManyWithoutBotInput, BotUpdateManyMutationInput>
  }

  export type UserCreateWithoutTwitterUserInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionCreateNestedManyWithoutOwnerInput
    Bot?: BotCreateNestedManyWithoutOwnerInput
    commands?: CommandCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserCreateNestedOneWithoutUserInput
    Hosts?: HostCreateNestedManyWithoutOwnerInput
    Manager?: ManagerCreateNestedManyWithoutOwnerInput
    pat?: PATCreateNestedManyWithoutUserInput
    twitch?: TwitchUserCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTwitterUserInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    isAdmin?: boolean
    actions?: ActionUncheckedCreateNestedManyWithoutOwnerInput
    Bot?: BotUncheckedCreateNestedManyWithoutOwnerInput
    commands?: CommandUncheckedCreateNestedManyWithoutOwnerInput
    discord?: DiscordUserUncheckedCreateNestedOneWithoutUserInput
    Hosts?: HostUncheckedCreateNestedManyWithoutOwnerInput
    Manager?: ManagerUncheckedCreateNestedManyWithoutOwnerInput
    pat?: PATUncheckedCreateNestedManyWithoutUserInput
    twitch?: TwitchUserUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTwitterUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserUncheckedCreateWithoutTwitterUserInput, UserCreateWithoutTwitterUserInput>
  }

  export type UserUpsertWithoutTwitterUserInput = {
    update: XOR<UserUncheckedUpdateWithoutTwitterUserInput, UserUpdateWithoutTwitterUserInput>
    create: XOR<UserUncheckedCreateWithoutTwitterUserInput, UserCreateWithoutTwitterUserInput>
  }

  export type UserUpdateWithoutTwitterUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUpdateManyWithoutOwnerInput
    Bot?: BotUpdateManyWithoutOwnerInput
    commands?: CommandUpdateManyWithoutOwnerInput
    discord?: DiscordUserUpdateOneWithoutUserInput
    Hosts?: HostUpdateManyWithoutOwnerInput
    Manager?: ManagerUpdateManyWithoutOwnerInput
    pat?: PATUpdateManyWithoutUserInput
    twitch?: TwitchUserUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutTwitterUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    actions?: ActionUncheckedUpdateManyWithoutOwnerInput
    Bot?: BotUncheckedUpdateManyWithoutOwnerInput
    commands?: CommandUncheckedUpdateManyWithoutOwnerInput
    discord?: DiscordUserUncheckedUpdateOneWithoutUserInput
    Hosts?: HostUncheckedUpdateManyWithoutOwnerInput
    Manager?: ManagerUncheckedUpdateManyWithoutOwnerInput
    pat?: PATUncheckedUpdateManyWithoutUserInput
    twitch?: TwitchUserUncheckedUpdateOneWithoutUserInput
  }

  export type ManagerUpdateWithoutParentManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
    owner?: UserUpdateOneRequiredWithoutManagerInput
    childManagers?: ManagerUpdateManyWithoutParentManagerInput
    transaction?: transactionUpdateManyWithoutResponsibleManagerInput
    Manager_B?: ManagerUpdateManyWithoutManager_AInput
    Manager_A?: ManagerUpdateManyWithoutManager_BInput
  }

  export type ManagerUncheckedUpdateWithoutParentManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
    childManagers?: ManagerUncheckedUpdateManyWithoutParentManagerInput
    transaction?: transactionUncheckedUpdateManyWithoutResponsibleManagerInput
  }

  export type ManagerUncheckedUpdateManyWithoutChildManagersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
  }

  export type transactionUpdateWithoutResponsibleManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspicious?: BoolFieldUpdateOperationsInput | boolean
    fraudulent?: BoolFieldUpdateOperationsInput | boolean
    reversedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pat?: PATUpdateOneWithoutTransactionInput
  }

  export type transactionUncheckedUpdateWithoutResponsibleManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patId?: NullableStringFieldUpdateOperationsInput | string | null
    suspicious?: BoolFieldUpdateOperationsInput | boolean
    fraudulent?: BoolFieldUpdateOperationsInput | boolean
    reversedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patId?: NullableStringFieldUpdateOperationsInput | string | null
    suspicious?: BoolFieldUpdateOperationsInput | boolean
    fraudulent?: BoolFieldUpdateOperationsInput | boolean
    reversedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ManagerUpdateWithoutManager_AInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
    owner?: UserUpdateOneRequiredWithoutManagerInput
    parentManager?: ManagerUpdateOneWithoutChildManagersInput
    childManagers?: ManagerUpdateManyWithoutParentManagerInput
    transaction?: transactionUpdateManyWithoutResponsibleManagerInput
    Manager_B?: ManagerUpdateManyWithoutManager_AInput
  }

  export type ManagerUncheckedUpdateWithoutManager_AInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    parentID?: NullableStringFieldUpdateOperationsInput | string | null
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
    childManagers?: ManagerUncheckedUpdateManyWithoutParentManagerInput
    transaction?: transactionUncheckedUpdateManyWithoutResponsibleManagerInput
  }

  export type ManagerUncheckedUpdateManyWithoutManager_BInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    parentID?: NullableStringFieldUpdateOperationsInput | string | null
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
  }

  export type ManagerUpdateWithoutManager_BInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
    owner?: UserUpdateOneRequiredWithoutManagerInput
    parentManager?: ManagerUpdateOneWithoutChildManagersInput
    childManagers?: ManagerUpdateManyWithoutParentManagerInput
    transaction?: transactionUpdateManyWithoutResponsibleManagerInput
    Manager_A?: ManagerUpdateManyWithoutManager_BInput
  }

  export type ManagerUncheckedUpdateWithoutManager_BInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    parentID?: NullableStringFieldUpdateOperationsInput | string | null
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
    childManagers?: ManagerUncheckedUpdateManyWithoutParentManagerInput
    transaction?: transactionUncheckedUpdateManyWithoutResponsibleManagerInput
  }

  export type ManagerUncheckedUpdateManyWithoutManager_AInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    parentID?: NullableStringFieldUpdateOperationsInput | string | null
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
  }

  export type BotUpdateWithoutHostsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discordToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitterToken?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedShards?: IntFieldUpdateOperationsInput | number
    currentShards?: IntFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutBotInput
    priorityHost?: HostUpdateOneWithoutPriorityBotInput
    twitchAuth?: TwitchAuthUpdateOneRequiredWithoutBotInput
    shards?: ShardUpdateManyWithoutBotInput
  }

  export type BotUncheckedUpdateWithoutHostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    priorityHostId?: NullableIntFieldUpdateOperationsInput | number | null
    discordToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitterToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitchAuthId?: IntFieldUpdateOperationsInput | number
    recommendedShards?: IntFieldUpdateOperationsInput | number
    currentShards?: IntFieldUpdateOperationsInput | number
    shards?: ShardUncheckedUpdateManyWithoutBotInput
  }

  export type BotUncheckedUpdateManyWithoutBotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    priorityHostId?: NullableIntFieldUpdateOperationsInput | number | null
    discordToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitterToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitchAuthId?: IntFieldUpdateOperationsInput | number
    recommendedShards?: IntFieldUpdateOperationsInput | number
    currentShards?: IntFieldUpdateOperationsInput | number
  }

  export type BotUpdateWithoutPriorityHostInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discordToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitterToken?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedShards?: IntFieldUpdateOperationsInput | number
    currentShards?: IntFieldUpdateOperationsInput | number
    hosts?: HostUpdateOneRequiredWithoutBotsInput
    owner?: UserUpdateOneRequiredWithoutBotInput
    twitchAuth?: TwitchAuthUpdateOneRequiredWithoutBotInput
    shards?: ShardUpdateManyWithoutBotInput
  }

  export type BotUncheckedUpdateWithoutPriorityHostInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    hostsId?: IntFieldUpdateOperationsInput | number
    discordToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitterToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitchAuthId?: IntFieldUpdateOperationsInput | number
    recommendedShards?: IntFieldUpdateOperationsInput | number
    currentShards?: IntFieldUpdateOperationsInput | number
    shards?: ShardUncheckedUpdateManyWithoutBotInput
  }

  export type BotUncheckedUpdateManyWithoutPriorityBotInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    hostsId?: IntFieldUpdateOperationsInput | number
    discordToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitterToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitchAuthId?: IntFieldUpdateOperationsInput | number
    recommendedShards?: IntFieldUpdateOperationsInput | number
    currentShards?: IntFieldUpdateOperationsInput | number
  }

  export type ShardUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lanchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShardStatusFieldUpdateOperationsInput | ShardStatus
    shardID?: IntFieldUpdateOperationsInput | number
    bot?: BotUpdateOneRequiredWithoutShardsInput
  }

  export type ShardUncheckedUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lanchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botId?: IntFieldUpdateOperationsInput | number
    status?: EnumShardStatusFieldUpdateOperationsInput | ShardStatus
    shardID?: IntFieldUpdateOperationsInput | number
  }

  export type ShardUncheckedUpdateManyWithoutShardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lanchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botId?: IntFieldUpdateOperationsInput | number
    status?: EnumShardStatusFieldUpdateOperationsInput | ShardStatus
    shardID?: IntFieldUpdateOperationsInput | number
  }

  export type ShardUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lanchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShardStatusFieldUpdateOperationsInput | ShardStatus
    shardID?: IntFieldUpdateOperationsInput | number
    Host?: HostUpdateOneRequiredWithoutShardsInput
  }

  export type ShardUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lanchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hostId?: IntFieldUpdateOperationsInput | number
    status?: EnumShardStatusFieldUpdateOperationsInput | ShardStatus
    shardID?: IntFieldUpdateOperationsInput | number
  }

  export type ActionUpdateWithoutOwnerInput = {
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    usage?: IntFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    type?: EnumDiscordExecutionTypeFieldUpdateOperationsInput | DiscordExecutionType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ActionUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    usage?: IntFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    type?: EnumDiscordExecutionTypeFieldUpdateOperationsInput | DiscordExecutionType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ActionUncheckedUpdateManyWithoutActionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    usage?: IntFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    type?: EnumDiscordExecutionTypeFieldUpdateOperationsInput | DiscordExecutionType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type BotUpdateWithoutOwnerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discordToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitterToken?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedShards?: IntFieldUpdateOperationsInput | number
    currentShards?: IntFieldUpdateOperationsInput | number
    hosts?: HostUpdateOneRequiredWithoutBotsInput
    priorityHost?: HostUpdateOneWithoutPriorityBotInput
    twitchAuth?: TwitchAuthUpdateOneRequiredWithoutBotInput
    shards?: ShardUpdateManyWithoutBotInput
  }

  export type BotUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostsId?: IntFieldUpdateOperationsInput | number
    priorityHostId?: NullableIntFieldUpdateOperationsInput | number | null
    discordToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitterToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitchAuthId?: IntFieldUpdateOperationsInput | number
    recommendedShards?: IntFieldUpdateOperationsInput | number
    currentShards?: IntFieldUpdateOperationsInput | number
    shards?: ShardUncheckedUpdateManyWithoutBotInput
  }

  export type BotUncheckedUpdateManyWithoutBotInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hostsId?: IntFieldUpdateOperationsInput | number
    priorityHostId?: NullableIntFieldUpdateOperationsInput | number | null
    discordToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitterToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitchAuthId?: IntFieldUpdateOperationsInput | number
    recommendedShards?: IntFieldUpdateOperationsInput | number
    currentShards?: IntFieldUpdateOperationsInput | number
  }

  export type CommandUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    usage?: IntFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    type?: EnumDiscordExecutionTypeFieldUpdateOperationsInput | DiscordExecutionType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type CommandUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    usage?: IntFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    type?: EnumDiscordExecutionTypeFieldUpdateOperationsInput | DiscordExecutionType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type CommandUncheckedUpdateManyWithoutCommandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    usage?: IntFieldUpdateOperationsInput | number
    cost?: IntFieldUpdateOperationsInput | number
    type?: EnumDiscordExecutionTypeFieldUpdateOperationsInput | DiscordExecutionType
    url?: StringFieldUpdateOperationsInput | string
  }

  export type HostUpdateWithoutOwnerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    shardLimit?: IntFieldUpdateOperationsInput | number
    bots?: BotUpdateManyWithoutHostsInput
    priorityBot?: BotUpdateManyWithoutPriorityHostInput
    shards?: ShardUpdateManyWithoutHostInput
  }

  export type HostUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    shardLimit?: IntFieldUpdateOperationsInput | number
    bots?: BotUncheckedUpdateManyWithoutHostsInput
    priorityBot?: BotUncheckedUpdateManyWithoutPriorityHostInput
    shards?: ShardUncheckedUpdateManyWithoutHostInput
  }

  export type HostUncheckedUpdateManyWithoutHostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    shardLimit?: IntFieldUpdateOperationsInput | number
  }

  export type ManagerUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
    parentManager?: ManagerUpdateOneWithoutChildManagersInput
    childManagers?: ManagerUpdateManyWithoutParentManagerInput
    transaction?: transactionUpdateManyWithoutResponsibleManagerInput
    Manager_B?: ManagerUpdateManyWithoutManager_AInput
    Manager_A?: ManagerUpdateManyWithoutManager_BInput
  }

  export type ManagerUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    parentID?: NullableStringFieldUpdateOperationsInput | string | null
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
    childManagers?: ManagerUncheckedUpdateManyWithoutParentManagerInput
    transaction?: transactionUncheckedUpdateManyWithoutResponsibleManagerInput
  }

  export type ManagerUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    type?: EnumManagerLevelsFieldUpdateOperationsInput | ManagerLevels
    restartSchedule?: StringFieldUpdateOperationsInput | string
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    parentID?: NullableStringFieldUpdateOperationsInput | string | null
    downtimeHistory?: ManagerUpdatedowntimeHistoryInput | Enumerable<InputJsonValue>
  }

  export type PATUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPATStatusFieldUpdateOperationsInput | PATStatus
    transaction?: transactionUpdateManyWithoutPatInput
  }

  export type PATUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPATStatusFieldUpdateOperationsInput | PATStatus
    transaction?: transactionUncheckedUpdateManyWithoutPatInput
  }

  export type PATUncheckedUpdateManyWithoutPatInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPATStatusFieldUpdateOperationsInput | PATStatus
  }

  export type TwitterUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discrim?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discrim?: IntFieldUpdateOperationsInput | number
  }

  export type TwitterUserUncheckedUpdateManyWithoutTwitterUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    discrim?: IntFieldUpdateOperationsInput | number
  }

  export type transactionUpdateWithoutPatInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspicious?: BoolFieldUpdateOperationsInput | boolean
    fraudulent?: BoolFieldUpdateOperationsInput | boolean
    reversedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsibleManager?: ManagerUpdateOneRequiredWithoutTransactionInput
  }

  export type transactionUncheckedUpdateWithoutPatInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managerId?: StringFieldUpdateOperationsInput | string
    suspicious?: BoolFieldUpdateOperationsInput | boolean
    fraudulent?: BoolFieldUpdateOperationsInput | boolean
    reversedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminOnGuildsUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guild?: guildUpdateOneRequiredWithoutAdminsInput
  }

  export type AdminOnGuildsUncheckedUpdateWithoutUserInput = {
    guildId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminOnGuildsUncheckedUpdateManyWithoutAdministatesInput = {
    guildId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersOnGuildsUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guild?: guildUpdateOneRequiredWithoutMembersInput
  }

  export type UsersOnGuildsUncheckedUpdateWithoutUserInput = {
    guildId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersOnGuildsUncheckedUpdateManyWithoutUsersOnGuildsInput = {
    guildId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminOnGuildsUpdateWithoutGuildInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: DiscordUserUpdateOneRequiredWithoutAdministatesInput
  }

  export type AdminOnGuildsUncheckedUpdateWithoutGuildInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminOnGuildsUncheckedUpdateManyWithoutAdminsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersOnGuildsUpdateWithoutGuildInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: DiscordUserUpdateOneRequiredWithoutUsersOnGuildsInput
  }

  export type UsersOnGuildsUncheckedUpdateWithoutGuildInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersOnGuildsUncheckedUpdateManyWithoutMembersInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotUpdateWithoutTwitchAuthInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discordToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitterToken?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedShards?: IntFieldUpdateOperationsInput | number
    currentShards?: IntFieldUpdateOperationsInput | number
    hosts?: HostUpdateOneRequiredWithoutBotsInput
    owner?: UserUpdateOneRequiredWithoutBotInput
    priorityHost?: HostUpdateOneWithoutPriorityBotInput
    shards?: ShardUpdateManyWithoutBotInput
  }

  export type BotUncheckedUpdateWithoutTwitchAuthInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    hostsId?: IntFieldUpdateOperationsInput | number
    priorityHostId?: NullableIntFieldUpdateOperationsInput | number | null
    discordToken?: NullableStringFieldUpdateOperationsInput | string | null
    twitterToken?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedShards?: IntFieldUpdateOperationsInput | number
    currentShards?: IntFieldUpdateOperationsInput | number
    shards?: ShardUncheckedUpdateManyWithoutBotInput
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}